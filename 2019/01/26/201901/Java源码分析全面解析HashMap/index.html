<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <link rel="dns-prefetch" href="http://example.com">
  
  <title>Java源码分析--全面解析HashMap | Hexo</title>
  <meta name="author" content="Gavin">
  
  <meta name="description" content="介绍HashMap是基于哈希表的Map接口的实现，并允许使用 null 值和 null 键。HashMap在JDK1.8之前使用的是哈希表+链表的方式存储数据。在JDK1.8之后，如果链表过长则将链表转成红黑树。 
源码分析继承123public class HashMap&amp;lt;K,V&amp;gt; e">
  
  
  <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

  <meta property="og:title" content="Java源码分析--全面解析HashMap"/>
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">

  <link rel="preload" as="style" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <link rel="icon" class="js-site-favicon" type="image/svg+xml" href="https://github.githubassets.com/favicons/favicon.svg">
  <link href="https://unpkg.com" rel="dns-prefetch" />
  <link href="https://busuanzi.ibruce.info" rel="dns-prefetch" />
  <link href="https://cdn1.lncld.net" rel="dns-prefetch" />
  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div class="container">
    <div class="left-col" style="background-image:url('../img/sider.jpg')">
      <div class="intrude-less">
        <header id="header" class="inner">
          <a href="/">
            <div class="profilepic"><img src='../img/user.png'></div>
          </a>
          <div class="author-name"><a href="/">Gavin</a></div>
          
          <nav id="main-nav">
            <ul class="main">
              
              <li>
                
                  <a href="/archives">归档</a>
                
              </li>
              
              <li>
                
                  <a href="/tags">专题</a>
                
              </li>
              
              <li>
                
                  <a href="/friendlinks">友链</a>
                
              </li>
              
              <li>
                
                  <a href="/life">关于</a>
                
              </li>
              
              <li>
                
                  <a href="/search">搜索</a>
                
              </li>
              
            </ul>
          </nav>
          <nav id="sub-nav">
            <div class="social">
              
              
              
              <a class="github" target="_blank" rel="noopener" href="https://github.com/" title="Github">Github</a>
              
              

              
              <a class="rss" href="/atom.xml" title="RSS">RSS</a>
              
            </div>
          </nav>
        </header>
      </div>
    </div>
    <div class="mid-col">
      <div class="mid-col-container">
        <div id="content" class="inner">
          <article class="post">

  
    <div class="meta">
      
<div class="date">

<time datetime="2019-01-26T15:00:56.000Z"
      
      data-updated="true"
       itemprop="datePublished">
  2019-01-26
</time>





</div>

    </div>
  
  <h1 class="title" itemprop="name">Java源码分析--全面解析HashMap</h1>
  <div class="entry-content" itemprop="articleBody">
    
    <div class="post-toc">
      <div class="toc-title">TOC</div>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-%E7%BB%93%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">Node 结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#table-length-1-amp-hash"><span class="toc-number">2.5.1.</span> <span class="toc-text">(table.length - 1) &amp; hash</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get"><span class="toc-number">2.5.2.</span> <span class="toc-text">get</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.6.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put-K-V"><span class="toc-number">2.7.</span> <span class="toc-text">put(K,V)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize"><span class="toc-number">2.8.</span> <span class="toc-text">resize()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#treeifyBin"><span class="toc-number">2.9.</span> <span class="toc-text">treeifyBin()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </div>
    
    <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>HashMap是基于哈希表的Map接口的实现，并允许使用 null 值和 null 键。HashMap在JDK1.8之前使用的是哈希表+链表的方式存储数据。在JDK1.8之后，如果链表过长则将链表转成红黑树。 <img src="https://www.gwt.fun/upload/6a3271867a834964a39ec8afbbe80571_timg.jpg?ynotemdtimestamp=1548434457403"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"></a>源码分析</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><a href="#%E7%BB%A7%E6%89%BF"></a>继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HashMap继承了AbstractMap及实现了Map、Cloneable和Serializable接口。</p>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a><a href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"></a>成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID &#x3D; 362498820763181265L;</span><br><span class="line">&#x2F;&#x2F; aka 16 默认的初始容量  1*2*2*2*2 &#x3D; 16</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; </span><br><span class="line">&#x2F;&#x2F;最大容量是2的30次方</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;   </span><br><span class="line">&#x2F;&#x2F;填充因子是0.75.如果哈希表中的元素超过了加载因子与当前容量的乘积，就调用rehash方法</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f; </span><br><span class="line">&#x2F;&#x2F;阈值，当桶上的链表数大于这个值会转成红黑树</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">&#x2F;&#x2F;当桶中的立案表述小于这个值则红黑树转成链表</span><br><span class="line">static final int UNTREEIFY_THRESHOLD &#x3D; 6; </span><br><span class="line">&#x2F;&#x2F;转成红黑树之前，判断键值对数量大于64才会转换。</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">&#x2F;&#x2F;哈希表数组，长度一直为2的幂次</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">&#x2F;&#x2F;键值对集合</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">&#x2F;&#x2F;键值对的数量</span><br><span class="line">transient int size;</span><br><span class="line">&#x2F;&#x2F;统计操作次数，迭代的时候判断这个值是否变化，fail-fast抛出ConcurrentModificationException</span><br><span class="line">transient int modCount;</span><br><span class="line">&#x2F;&#x2F;阈值，键值对数量大于这个值将开始扩容。threshold &#x3D; table.length * loadFactor</span><br><span class="line">int threshold;</span><br><span class="line">&#x2F;&#x2F;这个才是填充因子，上面DEFAULT_LOAD_FACTOR是默认的</span><br><span class="line">final float loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Node-结点"><a href="#Node-结点" class="headerlink" title="Node 结点"></a><a href="#node-%E7%BB%93%E7%82%B9"></a>Node 结点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;存的结点的hash值</span><br><span class="line">    final int hash;  </span><br><span class="line">    &#x2F;&#x2F;K和V的值，这里V不用final修饰。K用final修饰，说明键只能赋值一次，不能改变，但是值可以改变</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    &#x2F;&#x2F;指向下一个结点</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    &#x2F;&#x2F;创建一个结点</span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash &#x3D; hash;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue &#x3D; value;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; this)</span><br><span class="line">            return true;</span><br><span class="line">        &#x2F;&#x2F;instanceof 判断对象o是否是类Map.Entry的一个实例</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"></a>构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传入初始容量和填充因子</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    &#x2F;&#x2F;判断初始容量是否合法</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity)</span><br><span class="line">    &#x2F;&#x2F;如果传入的初始容量大于最大容量，将用最大容量作为初始容量</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        &#x2F;&#x2F;初始容量在这里有啥用？？？</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    &#x2F;&#x2F;判断填充因子是否合法</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    &#x2F;&#x2F;计算出来threshold阈值</span><br><span class="line">    this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*将初始化容量转化为大于等于最接近cap的2的整数次幂</span><br><span class="line">|是或运算，&gt;&gt;&gt;是无符号右移，空位0补齐</span><br><span class="line">以n &#x3D; 011011，</span><br><span class="line">011011 &gt;&gt;&gt; 1 &#x3D; 001101 </span><br><span class="line">011011 | 001101 &#x3D; 011111</span><br><span class="line">.....</span><br><span class="line">然后继续下去，最后得到最高位和后面的都是1，就能保证结果大于等于n，并且n为奇数，最后再加1.</span><br><span class="line">因为int为32位，所以最后肯定能让所有位都为1</span><br><span class="line">*&#x2F;</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    &#x2F;&#x2F;cap减一，是防止传进来的是2的整数次幂，减一后保证最后结果是cap本身</span><br><span class="line">    int n &#x3D; cap - 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果没有传入填充因子，则使用默认的填充因子</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;只默认了填充因子</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传入一个Map初始化</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    &#x2F;&#x2F;使用默认填充因子</span><br><span class="line">    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">    &#x2F;&#x2F;s是长度</span><br><span class="line">    int s &#x3D; m.size();</span><br><span class="line">    if (s &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果哈希表没有初始化</span><br><span class="line">        if (table &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; pre-size</span><br><span class="line">            float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F;</span><br><span class="line">            int t &#x3D; ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            &#x2F;&#x2F;计算出来的t大于阈值，则用t初始化阈值</span><br><span class="line">            if (t &gt; threshold)</span><br><span class="line">                threshold &#x3D; tableSizeFor(t);</span><br><span class="line">        &#125; &#x2F;&#x2F;m的个数大于阈值，则进行扩容</span><br><span class="line">        else if (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key &#x3D; e.getKey();</span><br><span class="line">            V value &#x3D; e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, false, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a><a href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"></a>其他方法</h4><h5 id="table-length-1-amp-hash"><a href="#table-length-1-amp-hash" class="headerlink" title="(table.length - 1) &amp; hash"></a><a href="#tablelength-1-hash"></a>(table.length - 1) &amp; hash</h5><p>HashMap根据key的hashCode计算hash值，知道hash值之后怎么确定key在数组中的位置呢，这里就用到了(table.length - 1) &amp; hash；<br>首先使用(table.length - 1) 和hash进行与操作，不用担心数组越界。那为什么要数组长度减一呢？假设数组长度是16,假设有两个hashcode是8和9:<br>8的二进制：1000<br>9的二进制：1001<br>16的二进制是：10000<br>8 &amp; 16 = 10000<br>9 &amp; 16 = 10000<br>这样出现了两个不同的hashcode在一个数组中，增加了查找的次数<br>如果table.length - 1，也就是16-1：<br>15的二进制：1111<br>8 &amp; 15 = 1000<br>9 &amp; 15 = 1001</p>
<h5 id="get"><a href="#get" class="headerlink" title="get"></a><a href="#get"></a>get</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传入Key，返回Value</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F;这里也能看到hashmap可以保存null</span><br><span class="line">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;传入Key的hash值和key的值</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    &#x2F;&#x2F;判断数组是否是null，数组长度是否大于0，取出来的结点是否为null</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;先判断结点的hash值是否相同，再判断key是否相同，都相同就返回这个结点</span><br><span class="line">        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        &#x2F;&#x2F;如果数组中还有其他的结点，就继续查找</span><br><span class="line">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;判断first是不是红黑树</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                &#x2F;&#x2F;调用TreeNode中的getTreeNode方法，我还没看TreeNode类，一会写</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            &#x2F;&#x2F;不是红黑树，是链表，开始遍历链表</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91"></a>红黑树</h4><p>红黑树不是严格的平衡二叉树，红黑树比AVL树不平衡最多一层，查询上比AVL最多多一次比较。红黑树在添加和删除结点时比AVL减少旋转次数，旋转三次以内就会解决不平衡，而AVL树追求严格平衡，旋转次数很多。因此大多选用红黑树。</p>
<ul>
<li>  树根：必须是黑色</li>
<li>  叶子节点：黑色（NULL）</li>
<li>  红色节点的子节点都是黑色（不存在两个红色节点连续）</li>
<li>  从任一节点到每个叶子节点路径包含相同数量的黑色节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  &#x2F;&#x2F; 父节点</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    &#x2F;&#x2F; 前一个节点</span><br><span class="line">    boolean red;  &#x2F;&#x2F;颜色</span><br><span class="line">    &#x2F;*</span><br><span class="line">    这个构造函数调用了super()，LinkedHashMap.Entry的构造函数中也是调用super();就回到了上面的Node类中：</span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    *&#x2F;</span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回这个节点的根节点，就是不断向上找</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line">        for (TreeNode&lt;K,V&gt; r &#x3D; this, p;;) &#123;</span><br><span class="line">            &#x2F;&#x2F;根节点的父节点是null</span><br><span class="line">            if ((p &#x3D; r.parent) &#x3D;&#x3D; null)</span><br><span class="line">                return r;</span><br><span class="line">            r &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 确保传进来的root节点是这个二叉树的根节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123;</span><br><span class="line">        int n;&#x2F;&#x2F;n是HashMap的数组长度</span><br><span class="line">        &#x2F;&#x2F;验证传进来的参数是否合法，tab是HashMap的哈希表</span><br><span class="line">        if (root !&#x3D; null &amp;&amp; tab !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;上面解释过了，index是哈希表数组的索引</span><br><span class="line">            int index &#x3D; (n - 1) &amp; root.hash;</span><br><span class="line">            &#x2F;&#x2F;如果是红黑树的结构，哈希表数组中存储的结点是红黑树的头节点，所以这里直接取tab[index]就是取出来红黑树的头节点，可以看上面的图</span><br><span class="line">            TreeNode&lt;K,V&gt; first &#x3D; (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">            &#x2F;&#x2F;如果头节点和传进来的root不相同</span><br><span class="line">            if (root !&#x3D; first) &#123;</span><br><span class="line">                Node&lt;K,V&gt; rn;</span><br><span class="line">                &#x2F;&#x2F;直接把root放进去</span><br><span class="line">                tab[index] &#x3D; root;</span><br><span class="line">                TreeNode&lt;K,V&gt; rp &#x3D; root.prev;&#x2F;&#x2F;rp等于root结点的前一个结点</span><br><span class="line">                &#x2F;&#x2F;如果存在下一个结点</span><br><span class="line">                &#x2F;*</span><br><span class="line">                这里是这样：rp--&gt;root--&gt;rn 现在把root拿出来当红黑树的根结点了变成了：rp--&gt;rn</span><br><span class="line">                因为是双向链表,需要：rp&lt;--rn</span><br><span class="line">                *&#x2F;</span><br><span class="line">                if ((rn &#x3D; root.next) !&#x3D; null)</span><br><span class="line">                    &#x2F;&#x2F;下一个结点rn的前驱结点设置为root的前驱rp&lt;--rn</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)rn).prev &#x3D; rp;</span><br><span class="line">                if (rp !&#x3D; null)</span><br><span class="line">                    &#x2F;&#x2F;rp--&gt;rn</span><br><span class="line">                    rp.next &#x3D; rn;</span><br><span class="line">                &#x2F;*</span><br><span class="line">                这里变成了：root--&gt;frist；null&lt;--root&lt;--frist</span><br><span class="line">                *&#x2F;</span><br><span class="line">                if (first !&#x3D; null)</span><br><span class="line">                    first.prev &#x3D; root;</span><br><span class="line">                root.next &#x3D; first;</span><br><span class="line">                root.prev &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;checkInvariants()方法还没看，这里如果返回false就会抛出AssertionError错误，然后终止执行</span><br><span class="line">            assert checkInvariants(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Finds the node starting at root p with the given hash and key.</span><br><span class="line">     * The kc argument caches comparableClassFor(key) upon first use</span><br><span class="line">     * comparing keys.</span><br><span class="line">     h：hash值   k：key   kc:缓存key？</span><br><span class="line">     给定hash值和key找到这个节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">        &#x2F;&#x2F;从节点p还是查找</span><br><span class="line">        TreeNode&lt;K,V&gt; p &#x3D; this;</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F;ph:p节点的hash值； pk:节点p的key</span><br><span class="line">            int ph, dir; K pk;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl &#x3D; p.left, pr &#x3D; p.right, q;</span><br><span class="line">            &#x2F;*</span><br><span class="line">                这里能看出来，红黑树是根据hash值来判断一个节点应该去左边还是右边。这里可能会有个疑问，前面判断在哈希表数组索引也是用的hash值，那红黑树中所有的hash值不应该一样吗？其实，前面哈希表数组中判断的hash值是Node节点的hash值：Objects.hashCode(key) ^ Objects.hashCode(value);也就是key的hash值和value的hash值取异或，而这里用到的hash值是key的hash值，还不知道value是多少。</span><br><span class="line">            *&#x2F;</span><br><span class="line">            &#x2F;&#x2F;h小于p节点的hash值，向左查找</span><br><span class="line">            if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                p &#x3D; pl;</span><br><span class="line">            &#x2F;&#x2F;h大于p节点的hash值，向右查找</span><br><span class="line">            else if (ph &lt; h)</span><br><span class="line">                p &#x3D; pr;</span><br><span class="line">            &#x2F;&#x2F;判断key是否相同，相同就查找到了</span><br><span class="line">            else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (k !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                return p;</span><br><span class="line">            &#x2F;&#x2F;这是出现hash值相同但是key不同的情况？</span><br><span class="line">            else if (pl &#x3D;&#x3D; null)</span><br><span class="line">                &#x2F;&#x2F;左子树是null就去右子树找</span><br><span class="line">                p &#x3D; pr;</span><br><span class="line">            else if (pr &#x3D;&#x3D; null)</span><br><span class="line">                &#x2F;&#x2F;左子树是null去右子树找</span><br><span class="line">                p &#x3D; pl;</span><br><span class="line">            &#x2F;&#x2F;comparableClassFor方法是获取k的运行时类型，compareComparables方法先判断，key与运行时kc是同类型，在通过调用k和kc实现的Comparable接口的compareTo进行比较</span><br><span class="line">            else if ((kc !&#x3D; null ||</span><br><span class="line">                      (kc &#x3D; comparableClassFor(k)) !&#x3D; null) &amp;&amp;</span><br><span class="line">                     (dir &#x3D; compareComparables(kc, k, pk)) !&#x3D; 0)</span><br><span class="line">                p &#x3D; (dir &lt; 0) ? pl : pr;</span><br><span class="line">            &#x2F;&#x2F;在右子树里面递归</span><br><span class="line">            else if ((q &#x3D; pr.find(h, k, kc)) !&#x3D; null)</span><br><span class="line">                return q;</span><br><span class="line">            else</span><br><span class="line">                p &#x3D; pl;</span><br><span class="line">        &#125; while (p !&#x3D; null);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从根节点开始查找</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123;</span><br><span class="line">        &#x2F;&#x2F;parent&#x3D;&#x3D;null 就说明是根结点，否则就找到根结点再查找</span><br><span class="line">        return ((parent !&#x3D; null) ? root() : this).find(h, k, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">        比较两个对象的大小，不会返回0</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static int tieBreakOrder(Object a, Object b) &#123;</span><br><span class="line">        int d;</span><br><span class="line">        &#x2F;&#x2F;比较类名，如果相同，调用本地方法为对象生成hashcode值，再继续比较</span><br><span class="line">        if (a &#x3D;&#x3D; null || b &#x3D;&#x3D; null ||</span><br><span class="line">            (d &#x3D; a.getClass().getName().</span><br><span class="line">             compareTo(b.getClass().getName())) &#x3D;&#x3D; 0)</span><br><span class="line">            d &#x3D; (System.identityHashCode(a) &lt;&#x3D; System.identityHashCode(b) ?</span><br><span class="line">                 -1 : 1);</span><br><span class="line">        return d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 链表转成红黑树</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final void treeify(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root &#x3D; null;</span><br><span class="line">        for (TreeNode&lt;K,V&gt; x &#x3D; this, next; x !&#x3D; null; x &#x3D; next) &#123;</span><br><span class="line">            &#x2F;&#x2F;把x在链表里面取出来，next指向下一个结点</span><br><span class="line">            next &#x3D; (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left &#x3D; x.right &#x3D; null;&#x2F;&#x2F;设置左右子树为null</span><br><span class="line">            &#x2F;&#x2F;如果x是第一个结点，也就是root为null的情况，将父结点指向null，颜色是黑色</span><br><span class="line">            if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">                x.parent &#x3D; null;</span><br><span class="line">                x.red &#x3D; false;</span><br><span class="line">                root &#x3D; x;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                K k &#x3D; x.key;</span><br><span class="line">                int h &#x3D; x.hash;</span><br><span class="line">                Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F;下面的代码和find函数差不多，就是找到k应该去的位置。</span><br><span class="line">                for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">                    int dir, ph;</span><br><span class="line">                    K pk &#x3D; p.key;</span><br><span class="line">                    if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                        dir &#x3D; -1;</span><br><span class="line">                    else if (ph &lt; h)</span><br><span class="line">                        dir &#x3D; 1;</span><br><span class="line">                    else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                              (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                             (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0)</span><br><span class="line">                        dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line">                    TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">                    &#x2F;&#x2F;dir小于等于0去左边，大于0去右边。这里找到了应该去的位置</span><br><span class="line">                    if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        x.parent &#x3D; xp;</span><br><span class="line">                        if (dir &lt;&#x3D; 0)</span><br><span class="line">                            xp.left &#x3D; x;</span><br><span class="line">                        else</span><br><span class="line">                            xp.right &#x3D; x;</span><br><span class="line">                        &#x2F;&#x2F;旋转节点，保持平衡</span><br><span class="line">                        root &#x3D; balanceInsertion(root, x);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将根节点放进去</span><br><span class="line">        moveRootToFront(tab, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将树转成链表</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123;</span><br><span class="line">        Node&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">        for (Node&lt;K,V&gt; q &#x3D; this; q !&#x3D; null; q &#x3D; q.next) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p &#x3D; map.replacementNode(q, null);</span><br><span class="line">            if (tl &#x3D;&#x3D; null)</span><br><span class="line">                hd &#x3D; p;</span><br><span class="line">            else</span><br><span class="line">                tl.next &#x3D; p;</span><br><span class="line">            tl &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        return hd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 插入元素</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span><br><span class="line">                                   int h, K k, V v) &#123;</span><br><span class="line">        Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">        boolean searched &#x3D; false;&#x2F;&#x2F;标记是否查找一次</span><br><span class="line">        TreeNode&lt;K,V&gt; root &#x3D; (parent !&#x3D; null) ? root() : this; &#x2F;&#x2F;获取根结点</span><br><span class="line">        for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">            int dir, ph; K pk;</span><br><span class="line">            if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                dir &#x3D; -1;</span><br><span class="line">            else if (ph &lt; h)</span><br><span class="line">                dir &#x3D; 1;</span><br><span class="line">            else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (k !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                return p;</span><br><span class="line">            else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                      (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                     (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果K和PK通过COMPARATO比较之后，如果相同就进来，并且只会进来一次</span><br><span class="line">                if (!searched) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                    searched &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F;从左子树或者右子树中找到就返回</span><br><span class="line">                    if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;</span><br><span class="line">                         (q &#x3D; ch.find(h, k, kc)) !&#x3D; null) ||</span><br><span class="line">                        ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;</span><br><span class="line">                         (q &#x3D; ch.find(h, k, kc)) !&#x3D; null))</span><br><span class="line">                        return q;</span><br><span class="line">                &#125;</span><br><span class="line">                dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;找到合适的位置，然后插入</span><br><span class="line">            TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">            if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Node&lt;K,V&gt; xpn &#x3D; xp.next;</span><br><span class="line">                &#x2F;&#x2F;创建一个新的节点</span><br><span class="line">                TreeNode&lt;K,V&gt; x &#x3D; map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                if (dir &lt;&#x3D; 0)</span><br><span class="line">                    xp.left &#x3D; x;</span><br><span class="line">                else</span><br><span class="line">                    xp.right &#x3D; x;</span><br><span class="line">                xp.next &#x3D; x;</span><br><span class="line">                x.parent &#x3D; x.prev &#x3D; xp;</span><br><span class="line">                if (xpn !&#x3D; null)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)xpn).prev &#x3D; x;</span><br><span class="line">                moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">           &#x2F;*</span><br><span class="line">        删除结点</span><br><span class="line">        1.如果删除的是红色结点则不影响性质</span><br><span class="line">        2。如果删除的是黑色结点，那么路径上会少一个黑色结点，破坏了性质</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span><br><span class="line">                              boolean movable) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            return;</span><br><span class="line">        int index &#x3D; (n - 1) &amp; hash;</span><br><span class="line">        &#x2F;&#x2F;找到根结点</span><br><span class="line">        TreeNode&lt;K,V&gt; first &#x3D; (TreeNode&lt;K,V&gt;)tab[index], root &#x3D; first, rl;</span><br><span class="line">        &#x2F;&#x2F;succ表示下一个结点，pred表示上一个结点</span><br><span class="line">        TreeNode&lt;K,V&gt; succ &#x3D; (TreeNode&lt;K,V&gt;)next, pred &#x3D; prev;</span><br><span class="line">        &#x2F;&#x2F;如果要删除根结点，直接将下一个结点提上来</span><br><span class="line">        if (pred &#x3D;&#x3D; null)</span><br><span class="line">            tab[index] &#x3D; first &#x3D; succ;</span><br><span class="line">        &#x2F;&#x2F;否则就直接将当前结点的上一个结点指向当前结点的下一个结点</span><br><span class="line">        else</span><br><span class="line">            pred.next &#x3D; succ;</span><br><span class="line">        if (succ !&#x3D; null)</span><br><span class="line">            succ.prev &#x3D; pred;</span><br><span class="line">        if (first &#x3D;&#x3D; null)</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F;根结点赋值到root</span><br><span class="line">        if (root.parent !&#x3D; null)</span><br><span class="line">            root &#x3D; root.root();</span><br><span class="line">        &#x2F;&#x2F;红黑树结点太少，转换成链表返回</span><br><span class="line">        if (root &#x3D;&#x3D; null</span><br><span class="line">            || (movable</span><br><span class="line">                &amp;&amp; (root.right &#x3D;&#x3D; null</span><br><span class="line">                    || (rl &#x3D; root.left) &#x3D;&#x3D; null</span><br><span class="line">                    || rl.left &#x3D;&#x3D; null))) &#123;</span><br><span class="line">            tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode&lt;K,V&gt; p &#x3D; this, pl &#x3D; left, pr &#x3D; right, replacement;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        找到结点之后，需要删除结点，红黑树删除结点分为几种情况：</span><br><span class="line">        情况1：删除的结点左右子树都非空（按其他二叉树删除的方式处理，转变成其他的下面的三种情况）</span><br><span class="line">        情况2：删除的结点左子树为空，右子树非空</span><br><span class="line">        情况3：删除的结点右子树为空，左子树非空</span><br><span class="line">        情况4：删除的结点左右子树都为空</span><br><span class="line">        *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;情况1</span><br><span class="line">        if (pl !&#x3D; null &amp;&amp; pr !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;这里s指向的是当前结点p的右节点</span><br><span class="line">            TreeNode&lt;K,V&gt; s &#x3D; pr, sl;</span><br><span class="line">            &#x2F;&#x2F;不断找要删除结点的右子树里面的最左结点，赋值给s</span><br><span class="line">            while ((sl &#x3D; s.left) !&#x3D; null) &#x2F;&#x2F; find successor</span><br><span class="line">                s &#x3D; sl;</span><br><span class="line">            &#x2F;&#x2F;交换要删除结点右子树的最左叶子节点s和要删除结点p的颜色</span><br><span class="line">            boolean c &#x3D; s.red; s.red &#x3D; p.red; p.red &#x3D; c; &#x2F;&#x2F; swap colors</span><br><span class="line">            TreeNode&lt;K,V&gt; sr &#x3D; s.right;</span><br><span class="line">            TreeNode&lt;K,V&gt; pp &#x3D; p.parent;</span><br><span class="line">            &#x2F;&#x2F;特殊情况，如果p结点的右结点s没有左孩子</span><br><span class="line">            if (s &#x3D;&#x3D; pr) &#123; &#x2F;&#x2F; p was s&#39;s direct parent</span><br><span class="line">                &#x2F;&#x2F;直接交换p结点和s结点</span><br><span class="line">                p.parent &#x3D; s;</span><br><span class="line">                s.right &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sp &#x3D; s.parent;</span><br><span class="line">                &#x2F;&#x2F;还是交换s结点和p结点</span><br><span class="line">                if ((p.parent &#x3D; sp) !&#x3D; null) &#123;</span><br><span class="line">                    if (s &#x3D;&#x3D; sp.left)</span><br><span class="line">                        sp.left &#x3D; p;</span><br><span class="line">                    else</span><br><span class="line">                        sp.right &#x3D; p;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((s.right &#x3D; pr) !&#x3D; null)</span><br><span class="line">                    pr.parent &#x3D; s;</span><br><span class="line">            &#125;</span><br><span class="line">            p.left &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F;如果s存在右结点，就将p设置为sr的父结点</span><br><span class="line">            if ((p.right &#x3D; sr) !&#x3D; null)</span><br><span class="line">                sr.parent &#x3D; p;</span><br><span class="line">            &#x2F;&#x2F;p的左结点给s</span><br><span class="line">            if ((s.left &#x3D; pl) !&#x3D; null)</span><br><span class="line">                pl.parent &#x3D; s;</span><br><span class="line">            &#x2F;&#x2F;p的父结点给s</span><br><span class="line">            if ((s.parent &#x3D; pp) &#x3D;&#x3D; null)</span><br><span class="line">                root &#x3D; s;</span><br><span class="line">            else if (p &#x3D;&#x3D; pp.left)</span><br><span class="line">                pp.left &#x3D; s;</span><br><span class="line">            else</span><br><span class="line">                pp.right &#x3D; s;</span><br><span class="line">            &#x2F;&#x2F;如果s有右结点，则replacement等于右结点，否则为p</span><br><span class="line">            if (sr !&#x3D; null)</span><br><span class="line">                replacement &#x3D; sr;</span><br><span class="line">            else</span><br><span class="line">                replacement &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;情况3</span><br><span class="line">        else if (pl !&#x3D; null)</span><br><span class="line">            replacement &#x3D; pl;</span><br><span class="line">        &#x2F;&#x2F;情况2</span><br><span class="line">        else if (pr !&#x3D; null)</span><br><span class="line">            replacement &#x3D; pr;</span><br><span class="line">        else       &#x2F;&#x2F;情况4</span><br><span class="line">            replacement &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F;当p有孩子或者s有孩子，进行删除结点操作</span><br><span class="line">        if (replacement !&#x3D; p) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; pp &#x3D; replacement.parent &#x3D; p.parent;</span><br><span class="line">            if (pp &#x3D;&#x3D; null)</span><br><span class="line">                root &#x3D; replacement;</span><br><span class="line">            else if (p &#x3D;&#x3D; pp.left)</span><br><span class="line">                pp.left &#x3D; replacement;</span><br><span class="line">            else</span><br><span class="line">                pp.right &#x3D; replacement;</span><br><span class="line">            p.left &#x3D; p.right &#x3D; p.parent &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;对红黑树进行调整</span><br><span class="line">        TreeNode&lt;K,V&gt; r &#x3D; p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line">        &#x2F;&#x2F;当p结点没有孩子，或者s结点没有孩子，进行删除操作</span><br><span class="line">        if (replacement &#x3D;&#x3D; p) &#123;  &#x2F;&#x2F; detach</span><br><span class="line">            TreeNode&lt;K,V&gt; pp &#x3D; p.parent;</span><br><span class="line">            p.parent &#x3D; null;</span><br><span class="line">            if (pp !&#x3D; null) &#123;</span><br><span class="line">                if (p &#x3D;&#x3D; pp.left)</span><br><span class="line">                    pp.left &#x3D; null;</span><br><span class="line">                else if (p &#x3D;&#x3D; pp.right)</span><br><span class="line">                    pp.right &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (movable)</span><br><span class="line">            moveRootToFront(tab, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">        红黑树扩容时调用拆分方法，将红黑树拆成两个链表</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; b &#x3D; this;</span><br><span class="line">        &#x2F;&#x2F; Relink into lo and hi lists, preserving order</span><br><span class="line">        TreeNode&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">        TreeNode&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;两个变量计数，如果很小将变成链表，否则变成红黑树</span><br><span class="line">        int lc &#x3D; 0, hc &#x3D; 0;</span><br><span class="line">        for (TreeNode&lt;K,V&gt; e &#x3D; b, next; e !&#x3D; null; e &#x3D; next) &#123;</span><br><span class="line">            next &#x3D; (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">            e.next &#x3D; null;</span><br><span class="line">            if ((e.hash &amp; bit) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if ((e.prev &#x3D; loTail) &#x3D;&#x3D; null)</span><br><span class="line">                    loHead &#x3D; e;</span><br><span class="line">                else</span><br><span class="line">                    loTail.next &#x3D; e;</span><br><span class="line">                loTail &#x3D; e;</span><br><span class="line">                ++lc;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if ((e.prev &#x3D; hiTail) &#x3D;&#x3D; null)</span><br><span class="line">                    hiHead &#x3D; e;</span><br><span class="line">                else</span><br><span class="line">                    hiTail.next &#x3D; e;</span><br><span class="line">                hiTail &#x3D; e;</span><br><span class="line">                ++hc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (loHead !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;UNTREEIFY_THRESHOLD &#x3D; 6  ,如果拆分后小于这个值就转成链表，否则就转成红黑树</span><br><span class="line">            if (lc &lt;&#x3D; UNTREEIFY_THRESHOLD)</span><br><span class="line">                tab[index] &#x3D; loHead.untreeify(map);</span><br><span class="line">            else &#123;</span><br><span class="line">                tab[index] &#x3D; loHead;</span><br><span class="line">                if (hiHead !&#x3D; null) &#x2F;&#x2F; (else is already treeified)</span><br><span class="line">                    loHead.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (hiHead !&#x3D; null) &#123;</span><br><span class="line">            if (hc &lt;&#x3D; UNTREEIFY_THRESHOLD)</span><br><span class="line">                tab[index + bit] &#x3D; hiHead.untreeify(map);</span><br><span class="line">            else &#123;</span><br><span class="line">                tab[index + bit] &#x3D; hiHead;</span><br><span class="line">                if (loHead !&#x3D; null)</span><br><span class="line">                    hiHead.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* ------------------------------------------------------------ *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; Red-black tree methods, all adapted from CLR</span><br><span class="line">    &#x2F;&#x2F;下面是左旋和右旋调整结点，在我另外一篇博客中已经将清楚了[算法导论学习笔记--红黑树](https:&#x2F;&#x2F;www.gwt.fun&#x2F;articles&#x2F;2017&#x2F;08&#x2F;26&#x2F;1546585401831.html#%E6%97%8B%E8%BD%AC)</span><br><span class="line">    &#x2F;&#x2F;左旋</span><br><span class="line">    static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                          TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">        if (p !&#x3D; null &amp;&amp; (r &#x3D; p.right) !&#x3D; null) &#123;</span><br><span class="line">            if ((rl &#x3D; p.right &#x3D; r.left) !&#x3D; null)</span><br><span class="line">                rl.parent &#x3D; p;</span><br><span class="line">            if ((pp &#x3D; r.parent &#x3D; p.parent) &#x3D;&#x3D; null)</span><br><span class="line">                (root &#x3D; r).red &#x3D; false;</span><br><span class="line">            else if (pp.left &#x3D;&#x3D; p)</span><br><span class="line">                pp.left &#x3D; r;</span><br><span class="line">            else</span><br><span class="line">                pp.right &#x3D; r;</span><br><span class="line">            r.left &#x3D; p;</span><br><span class="line">            p.parent &#x3D; r;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;右旋</span><br><span class="line">    static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                           TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">        if (p !&#x3D; null &amp;&amp; (l &#x3D; p.left) !&#x3D; null) &#123;</span><br><span class="line">            if ((lr &#x3D; p.left &#x3D; l.right) !&#x3D; null)</span><br><span class="line">                lr.parent &#x3D; p;</span><br><span class="line">            if ((pp &#x3D; l.parent &#x3D; p.parent) &#x3D;&#x3D; null)</span><br><span class="line">                (root &#x3D; l).red &#x3D; false;</span><br><span class="line">            else if (pp.right &#x3D;&#x3D; p)</span><br><span class="line">                pp.right &#x3D; l;</span><br><span class="line">            else</span><br><span class="line">                pp.left &#x3D; l;</span><br><span class="line">            l.right &#x3D; p;</span><br><span class="line">            p.parent &#x3D; l;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    插入结点后调整方法，插入结点遵循下面的规则：</span><br><span class="line">    1、插入的结点重视红色</span><br><span class="line">    2、如果插入结点的父结点是黑色，能保证性质</span><br><span class="line">    3、如果是红色，则破坏了性质，必须进行重新染色或者旋转</span><br><span class="line">    插入过程详解过程：https:&#x2F;&#x2F;www.gwt.fun&#x2F;articles&#x2F;2017&#x2F;08&#x2F;26&#x2F;1546585401831.html#%E6%8F%92%E5%85%A5</span><br><span class="line">    *&#x2F;</span><br><span class="line">    static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                                TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">        x.red &#x3D; true; &#x2F;&#x2F;先设置插入的结点为红色</span><br><span class="line">        &#x2F;&#x2F;xp：x的父结点；xpp：x的父结点的父结点，也就是爷爷结点；xppl：爷爷结点的左节点；xppr：爷爷结点的右结点</span><br><span class="line">        for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果x的父结点是null，表示x是根结点，直接返回x</span><br><span class="line">            if ((xp &#x3D; x.parent) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                x.red &#x3D; false;</span><br><span class="line">                return x;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果父结点是黑色或者不存在爷爷结点，就直接返回</span><br><span class="line">            else if (!xp.red || (xpp &#x3D; xp.parent) &#x3D;&#x3D; null)</span><br><span class="line">                return root;</span><br><span class="line">            &#x2F;&#x2F;如果父结点是爷爷结点的左结点</span><br><span class="line">            if (xp &#x3D;&#x3D; (xppl &#x3D; xpp.left)) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果爷爷结点的右结点存在，并且该结点是红色</span><br><span class="line">                if ((xppr &#x3D; xpp.right) !&#x3D; null &amp;&amp; xppr.red) &#123;</span><br><span class="line">                    &#x2F;&#x2F;这里结合图看的会更明白，把叔叔结点设置成黑色，父结点设置为黑色，爷爷结点设置成红色</span><br><span class="line">                    xppr.red &#x3D; false;</span><br><span class="line">                    xp.red &#x3D; false;</span><br><span class="line">                    xpp.red &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F;爷爷结点赋值给x，继续循环</span><br><span class="line">                    x &#x3D; xpp;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;爷爷结点的右结点不存在或者叔叔结点是黑色</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F;判断x是否是父结点的右节点</span><br><span class="line">                    if (x &#x3D;&#x3D; xp.right) &#123;</span><br><span class="line">                        &#x2F;&#x2F;x上升至父结点，并左旋</span><br><span class="line">                        root &#x3D; rotateLeft(root, x &#x3D; xp);</span><br><span class="line">                        xpp &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.parent;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xp !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F;x是左孩子，x的父结点设置为黑色，x的爷爷改成红色然后右旋</span><br><span class="line">                        xp.red &#x3D; false;</span><br><span class="line">                        if (xpp !&#x3D; null) &#123;</span><br><span class="line">                            xpp.red &#x3D; true;</span><br><span class="line">                            root &#x3D; rotateRight(root, xpp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;  &#x2F;&#x2F;将上面的过程反过来</span><br><span class="line">                if (xppl !&#x3D; null &amp;&amp; xppl.red) &#123;</span><br><span class="line">                    xppl.red &#x3D; false;</span><br><span class="line">                    xp.red &#x3D; false;</span><br><span class="line">                    xpp.red &#x3D; true;</span><br><span class="line">                    x &#x3D; xpp;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if (x &#x3D;&#x3D; xp.left) &#123;</span><br><span class="line">                        root &#x3D; rotateRight(root, x &#x3D; xp);</span><br><span class="line">                        xpp &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.parent;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xp !&#x3D; null) &#123;</span><br><span class="line">                        xp.red &#x3D; false;</span><br><span class="line">                        if (xpp !&#x3D; null) &#123;</span><br><span class="line">                            xpp.red &#x3D; true;</span><br><span class="line">                            root &#x3D; rotateLeft(root, xpp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    删除结点后调整规则：</span><br><span class="line">    1、如果删除红色结点，不破坏规则</span><br><span class="line">    2、如果是黑色，就少了一个黑色</span><br><span class="line">    </span><br><span class="line">    https:&#x2F;&#x2F;www.gwt.fun&#x2F;articles&#x2F;2017&#x2F;08&#x2F;26&#x2F;1546585401831.html#%E5%88%A0%E9%99%A4</span><br><span class="line">    *&#x2F;</span><br><span class="line">    static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                               TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">        for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">            &#x2F;&#x2F;删除后结点是null或者是根结点，不调整</span><br><span class="line">            if (x &#x3D;&#x3D; null || x &#x3D;&#x3D; root)</span><br><span class="line">                return root;</span><br><span class="line">            &#x2F;&#x2F;x成为根结点，将x设置为黑色</span><br><span class="line">            else if ((xp &#x3D; x.parent) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                x.red &#x3D; false;</span><br><span class="line">                return x;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果x是红的，设置成黑</span><br><span class="line">            else if (x.red) &#123;</span><br><span class="line">                x.red &#x3D; false;</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;x是父亲的左孩子</span><br><span class="line">            else if ((xpl &#x3D; xp.left) &#x3D;&#x3D; x) &#123;</span><br><span class="line">                &#x2F;&#x2F;x的兄弟是红色的</span><br><span class="line">                if ((xpr &#x3D; xp.right) !&#x3D; null &amp;&amp; xpr.red) &#123;</span><br><span class="line">                    xpr.red &#x3D; false;</span><br><span class="line">                    xp.red &#x3D; true;</span><br><span class="line">                    root &#x3D; rotateLeft(root, xp);</span><br><span class="line">                    xpr &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.right;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;没有兄弟，则x到父结点位置</span><br><span class="line">                if (xpr &#x3D;&#x3D; null)</span><br><span class="line">                    x &#x3D; xp;</span><br><span class="line">                else &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sl &#x3D; xpr.left, sr &#x3D; xpr.right;</span><br><span class="line">                    if ((sr &#x3D;&#x3D; null || !sr.red) &amp;&amp;</span><br><span class="line">                        (sl &#x3D;&#x3D; null || !sl.red)) &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果x结点的兄弟是黑色的，并且左右结点都是黑色</span><br><span class="line">                        xpr.red &#x3D; true;</span><br><span class="line">                        x &#x3D; xp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (sr &#x3D;&#x3D; null || !sr.red) &#123;</span><br><span class="line">                            &#x2F;&#x2F;x的兄弟是黑色，右结点是黑色，左结点是红色</span><br><span class="line">                            if (sl !&#x3D; null)</span><br><span class="line">                                sl.red &#x3D; false;</span><br><span class="line">                            &#x2F;&#x2F;将x的兄弟结点变成红色,然后右旋</span><br><span class="line">                            &#x2F;&#x2F;下面的不写了，就是那几个过程，看明白就行，代码看不看都可以</span><br><span class="line">                            xpr.red &#x3D; true;</span><br><span class="line">                            root &#x3D; rotateRight(root, xpr);</span><br><span class="line">                            xpr &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ?</span><br><span class="line">                                null : xp.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xpr !&#x3D; null) &#123;</span><br><span class="line">                            xpr.red &#x3D; (xp &#x3D;&#x3D; null) ? false : xp.red;</span><br><span class="line">                            if ((sr &#x3D; xpr.right) !&#x3D; null)</span><br><span class="line">                                sr.red &#x3D; false;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xp !&#x3D; null) &#123;</span><br><span class="line">                            xp.red &#x3D; false;</span><br><span class="line">                            root &#x3D; rotateLeft(root, xp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        x &#x3D; root;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; &#x2F;&#x2F; 反过来的</span><br><span class="line">                if (xpl !&#x3D; null &amp;&amp; xpl.red) &#123;</span><br><span class="line">                    xpl.red &#x3D; false;</span><br><span class="line">                    xp.red &#x3D; true;</span><br><span class="line">                    root &#x3D; rotateRight(root, xp);</span><br><span class="line">                    xpl &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.left;</span><br><span class="line">                &#125;</span><br><span class="line">                if (xpl &#x3D;&#x3D; null)</span><br><span class="line">                    x &#x3D; xp;</span><br><span class="line">                else &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sl &#x3D; xpl.left, sr &#x3D; xpl.right;</span><br><span class="line">                    if ((sl &#x3D;&#x3D; null || !sl.red) &amp;&amp;</span><br><span class="line">                        (sr &#x3D;&#x3D; null || !sr.red)) &#123;</span><br><span class="line">                        xpl.red &#x3D; true;</span><br><span class="line">                        x &#x3D; xp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (sl &#x3D;&#x3D; null || !sl.red) &#123;</span><br><span class="line">                            if (sr !&#x3D; null)</span><br><span class="line">                                sr.red &#x3D; false;</span><br><span class="line">                            xpl.red &#x3D; true;</span><br><span class="line">                            root &#x3D; rotateLeft(root, xpl);</span><br><span class="line">                            xpl &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ?</span><br><span class="line">                                null : xp.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xpl !&#x3D; null) &#123;</span><br><span class="line">                            xpl.red &#x3D; (xp &#x3D;&#x3D; null) ? false : xp.red;</span><br><span class="line">                            if ((sl &#x3D; xpl.left) !&#x3D; null)</span><br><span class="line">                                sl.red &#x3D; false;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xp !&#x3D; null) &#123;</span><br><span class="line">                            xp.red &#x3D; false;</span><br><span class="line">                            root &#x3D; rotateRight(root, xp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        x &#x3D; root;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从根结点开始检查红黑树，是否符合红黑树的性质</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; tp &#x3D; t.parent, tl &#x3D; t.left, tr &#x3D; t.right,</span><br><span class="line">            tb &#x3D; t.prev, tn &#x3D; (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">        if (tb !&#x3D; null &amp;&amp; tb.next !&#x3D; t)</span><br><span class="line">            return false;</span><br><span class="line">        if (tn !&#x3D; null &amp;&amp; tn.prev !&#x3D; t)</span><br><span class="line">            return false;</span><br><span class="line">        if (tp !&#x3D; null &amp;&amp; t !&#x3D; tp.left &amp;&amp; t !&#x3D; tp.right)</span><br><span class="line">            return false;</span><br><span class="line">        if (tl !&#x3D; null &amp;&amp; (tl.parent !&#x3D; t || tl.hash &gt; t.hash))</span><br><span class="line">            return false;</span><br><span class="line">        if (tr !&#x3D; null &amp;&amp; (tr.parent !&#x3D; t || tr.hash &lt; t.hash))</span><br><span class="line">            return false;</span><br><span class="line">        if (t.red &amp;&amp; tl !&#x3D; null &amp;&amp; tl.red &amp;&amp; tr !&#x3D; null &amp;&amp; tr.red)</span><br><span class="line">            return false;</span><br><span class="line">        if (tl !&#x3D; null &amp;&amp; !checkInvariants(tl))</span><br><span class="line">            return false;</span><br><span class="line">        if (tr !&#x3D; null &amp;&amp; !checkInvariants(tr))</span><br><span class="line">            return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="put-K-V"><a href="#put-K-V" class="headerlink" title="put(K,V)"></a>put(K,V)</h4><p>终于看完了TreeNode类，现在继续看HashMap。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    &#x2F;&#x2F;如果tab是空或者长度为0，就扩容</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    &#x2F;&#x2F;如果哈希表数组中是空，就创建一个结点放进去</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        &#x2F;&#x2F;hash 相同，并且key相同</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F;如果是红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历链表</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果遍历完链表也没找到，就直接加在最后</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    &#x2F;&#x2F;如果链表长度大于等于8就变成红黑树，同理，红黑树小于6就转成链表</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;在链表中找到</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;更新value值</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">            &#x2F;&#x2F;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    &#x2F;&#x2F;threshold是阈值，超过就要扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length; &#x2F;&#x2F;获取旧哈希表长度</span><br><span class="line">        int oldThr &#x3D; threshold; &#x2F;&#x2F;获取旧阈值</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;超过Integer最大值，就不能加了</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;扩容2倍</span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">            newCap &#x3D; oldThr;</span><br><span class="line">        &#x2F;&#x2F;调用了无参构造函数，使用默认容量16，阈值为0.75*16</span><br><span class="line">        else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果新阈值为0，则重新计算，如果超过了Integer最大值，就直接赋值最大值</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold &#x3D; newThr;&#x2F;&#x2F;更新阈值</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table &#x3D; newTab;</span><br><span class="line">        &#x2F;&#x2F;如果旧tab里面有数据</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历每一个哈希表数组</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                &#x2F;&#x2F;临时将结点赋值给e</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;如果e只有一个结点，就重新计算然后存到新tab里面</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                    &#x2F;&#x2F;如果结点多，是红黑树，就拆分</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next &#x3D; e.next;</span><br><span class="line">                            &#x2F;*</span><br><span class="line">                            e.hash &amp; oldCap,这个也非常的巧妙，刚在红黑树的split中看这个式子还没闷过来弯，在这里看明白了。(table.length - 1) &amp; hash是查找索引，而这里没有减一。</span><br><span class="line">                            这样就得出来两个值，0或者oldCap，这样就能拆成两个链表</span><br><span class="line">                            </span><br><span class="line">                            </span><br><span class="line">                            *&#x2F;</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin()"></a>treeifyBin()</h4><p>这个方法的作用是将链表转成红黑树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F;如果链表达到了转换成红黑树的阈值，但是tab的数量没到变成红黑树的阈值，也不会变化。MIN_TREEIFY_CAPACITY &#x3D; 64</span><br><span class="line">    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">        do &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);</span><br><span class="line">            if (tl &#x3D;&#x3D; null)</span><br><span class="line">                hd &#x3D; p;</span><br><span class="line">            else &#123;</span><br><span class="line">                p.prev &#x3D; tl;</span><br><span class="line">                tl.next &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl &#x3D; p;</span><br><span class="line">        &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        if ((tab[index] &#x3D; hd) !&#x3D; null)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"></a>参考资料</h3><p>1.<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b9558ad35f70">hashcode()和hash()</a></p>


    

      
  </div>

</article>


  <nav id="pagenavi">
    
    <a href="/2019/01/28/201901/Java源码分析Object详解/" class="prev">上一篇：Java源码分析--Object详解</a>
    
    
    <a href="/2019/01/18/201901/Java源码分析Stack/" class="next">下一篇：Java源码分析--Stack</a>
    
  </nav>

        </div>
        
        
      </div>
      <footer id="footer" class="inner">
        © 2021 - Gavin -
        <span id="busuanzi_container_site_pv">PV <span id="busuanzi_value_site_pv"></span></span>
        <p>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/thinkerchan/hexo-theme-greyshade">GreyShade</a></p>
      </footer>
    </div>
  </div>
  
  <script async defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
</body>
</html>