<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <link rel="dns-prefetch" href="http://example.com">
  
  <title>站内搜索 | Hexo</title>
  <meta name="author" content="Gavin">
  
  
  <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

  <meta property="og:title" content="站内搜索"/>
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">

  <link rel="preload" as="style" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <link rel="icon" class="js-site-favicon" type="image/svg+xml" href="https://github.githubassets.com/favicons/favicon.svg">
  <link href="https://unpkg.com" rel="dns-prefetch" />
  <link href="https://busuanzi.ibruce.info" rel="dns-prefetch" />
  <link href="https://cdn1.lncld.net" rel="dns-prefetch" />
  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div class="container">
    <div class="left-col" style="background-image:url('../img/sider.jpg')">
      <div class="intrude-less">
        <header id="header" class="inner">
          <a href="/">
            <div class="profilepic"><img src='../img/user.png'></div>
          </a>
          <div class="author-name"><a href="/">Gavin</a></div>
          
          <nav id="main-nav">
            <ul class="main">
              
              <li>
                
                  <a href="/archives">归档</a>
                
              </li>
              
              <li>
                
                  <a href="/tags">专题</a>
                
              </li>
              
              <li>
                
                  <a href="/friendlinks">友链</a>
                
              </li>
              
              <li>
                
                  <a href="/life">关于</a>
                
              </li>
              
              <li>
                
                  <a href="/search">搜索</a>
                
              </li>
              
            </ul>
          </nav>
          <nav id="sub-nav">
            <div class="social">
              
              
              
              <a class="github" target="_blank" rel="noopener" href="https://github.com/" title="Github">Github</a>
              
              

              
              <a class="rss" href="/atom.xml" title="RSS">RSS</a>
              
            </div>
          </nav>
        </header>
      </div>
    </div>
    <div class="mid-col">
      <div class="mid-col-container">
        <div id="content" class="inner">
          <article>
  <h1 class="title">站内搜索 </h1>
  <div class="entry-content wrapper">
    <div id="search">
      <input type="text" placeholder="请输入关键字" id="Jinput">
    </div>
    <div class="info">
      本次搜索结果共<span id="Jcount">0</span>条
    </div>
    <div id="JresList"></div>

  


    <script>
      let searchData = [{"title":"Linux文件和用户权限以及SSH操作","content":"一、文件和用户权限1.文件详细信息　　使用ls -l可以查看文件详细信息在显示的文件详细信息中：　　1列：表示文件的属性。“-”表示文件，“d”表示文件夹，“l”表示快捷方式（链接）　　2-4列：表示当前用户对文件的操作权限　　　1). r 可读  2^2 = 4　　　2). w可写  2^1 = 2　　　3). x可执行2^0= 1    (最高权限是7)　　5-7列：表示当前用户所在的用户组对文件的操作权限　　8-10列：表示当前用户所在的用户组以外的用户对文件的操作权限　　11列：代表文件的链接数　　12列：代表当前用户　　13列：代表当前用户所在的用户组　　14列：代表文件大小　　15列：代表文件创建或修改时间\n2.更改文件所属用户和用户组 123　　chown  用户名   文件名    #改变文件所属用户名　　chgrp   用户组   文件名    #改变文件所属的用户组　　chown  用户名：用户组   文件名   #直接改变用户名和用户组 \n3.更改文件权限　　上面介绍了文件的三种权限，分别是当前用户权限，当前用户组权限，用户组以外的用户权限，权限最高是7。\n1 　chmod   700  文件名　　　＃当前用户有所有权限，其他用户没有权限.\n　　使用这个语句来改变文件的操作权限。\n删除文件rm -d 目录名              #删除一个空目录rmdir 目录名              #删除一个空目录rm -r 目录名              #删除一个非空目录rm 文件名                  #删除文件\n二、SSH服务器远程登录1.映射关系　　我使用两台虚拟机来模拟多台服务器之间的远程登录。使用Vmware虚拟机，安装了两个ubuntu（ubuntu kylin 16.04 LTS）的系统。　　首先通过ifconfig查看两台linux的ip地址。如下图所示：\n　　使用vim打开vim /etc/hosts 查看ip和域名之间的映射关系（这里的域名是指电脑的名称，例如我的电脑名是：work1-pc，另一台电脑的名称是：gavin-pc。使用vim /etc/hostname 可以更改这个域名，不会使用vim的可以直接在/etc/hostname这个路径里面找到hostname文件，直接使用gedit **打开。注意：这里的电脑名不是管理员用户名！），当我们要访问远程服务器的时候，可以直接访问域名，远程服务器就会自动解析/etc/hosts 来定位远程机器的ip地址，从而访问远程机器。打开/etc/hosts**文件：\n　　在这个我们可以看到，work1-pc域名对应的ip地址是127.0.1.1，都是本机地址。使用work1-pc，要想ping gavin-pc，我们可以ping 192.168.111.136.但是如果我们想直接ping gavin-pc，只能把192.168.111.136  gavin-pc 这个映射关系添加在work-pc的hosts文件中。于是这样：这时我们直接ping gavin-pc 就能ping通。同理，我们可以在另一台电脑ping通这台电脑，这里就不演示了。\n\n2.SSH远程登录　　SSH是linux中一种网络协议，用来计算机中加密登录，是在用户计算机中登录另一台远程计算机。　　首先安装SSH和rsync自动同步服务\n12apt-get install ssh   安装ssh服务apt-get install rsync 安装自动同步服务\n安装完SSH，可以使用SSH localhost来测试SSH服务是否安装成功。　　SSH是由客户端和服务端，这里我两个电脑都安装了客户端和服务端。　　那么一台计算机是怎样通过SSH来远程控制另一台电脑的呢？这里要说一下SSH的公钥加密方式。\n123　　1.远程主机接收到用户的登录请求，主机就会把自己的公钥发给用户计算机；　　2.用户使用公钥，然后把加密后的登录密码发送给远程主机；　　3.远程主机使用自己的私钥，解密登录密码，如果正确同意登录。\n　　但是这种加密方式是有风险的，因为如果一个人伪造公钥，将公钥发送给用户，解密登录密码后登录远程主机。这就是中间人攻击　　SSH协议使用口令登录的方式来解决这个问题。当第一次登录的时候，会显示：　　显示无法验证远程主机的真实性，知道公钥，询问是否连接。　　远程主机将用户的公钥，保存在登录后的用户主目录的**/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。于是我们可以将远程主机的公钥文件~/.ssh/id_rsa.pub复制到用户计算机上，然后将公钥文件追加到authorized_keys文件中，然后将追加过的authorized_keys文件，直接覆盖远程主机的authorized_keys**文件，于是此时两台计算机可以相互通过SSH连接。\n123456gavin-pc中：root@gavin-pc:~#    scp   ~&#x2F;.ssh&#x2F;id_rsa.pub   root@work1-pc:&#x2F;root&#x2F;Downlpads  &#x2F;&#x2F;将公钥文件发送到work1-pc的downloads文件夹中work1-pc中：root@work1-pc:~&#x2F;Downloads#   cat ~&#x2F;.ssh&#x2F;id_dsa.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys  &#x2F;&#x2F;将公钥追加进authorized_keys文件中root@work1-pc:~#  scp  ~&#x2F;.ssh&#x2F;authorized_keys    root@gavin-pc:~&#x2F;.ssh&#x2F;authorized_keys &#x2F;&#x2F;将authorized_keys  文件，同步到gavin-pc中\n　　操作完成后，可以通过任意一台计算机远程连接另外一台计算机。","url":"/2016/07/21/201607/Linux文件和用户权限以及SSH操作/","link":"","plink":"http://example.com/2016/07/21/201607/Linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E4%BB%A5%E5%8F%8ASSH%E6%93%8D%E4%BD%9C/"},{"title":"Redis数据类型","content":"一、基础操作1.创建键值：\n1redis&gt; SET bar 1       &#x2F;&#x2F;创建键值bar  值为1\n2.显示key\n1redis&gt; keys *\n3.判断key是否存在\n1redis&gt; exists bar\n如果存在显示整数1，否则显示整数04.删除key\n1redis&gt; del line\n成功返回整数1，失败返回整数0\n5.获取数据类型\n1redis&gt; type bar\n数据类型有string（字符串类型），hash（散列类型），list（列表类型），set（集合类型），zset（有序集合类型）\n\n二、字符串类型字符串是redis中最基本的数据类型，可以用字符串存储json数据或者是图片等数据。一个字符串类型的键允许存储的最大容量是512M.1.得到key的value\n1redis&gt; get bar\n2.递增当字符串为整数形式时，可以使用incr，让键值递增，并返回 递增后的值。如果这个value不存在，则默认为0；\n1redis&gt; incr line\n3.增加指定的整数\n1redis&gt; incrby line 2\n4.减少指定的整数\n12redis&gt; decr lineredis&gt; decrby line 2\n5.增加指定浮点数\n1redis&gt; incrbyfloat line 2.7\n6.向尾部追加值\n1redis&gt; append bar &quot; nihao&quot;\n\n7.获取字符串长度\n1redis&gt; strlen bar\n8.同时设置/获得多个键值\n12redis&gt; mset bar 2 line 2 redis&gt; mget bar line\n\n三、散列类型redis中的数据类型不支持其他数据类型的嵌套。1.赋值和取值 \n12redis&gt; hset car price 500redis&gt;hget car price \n2.设置/读取多个值\n123redis&gt; hmset student id &quot;2014&quot; sex manredis&gt; hmget student id sexredis&gt; hgetall student\n3.判断字段是否存在\n1redis&gt; hexists student sex\n存在返回数字1.不存在返回数字04.增加数字\n1redis&gt; hincrby student score 100\n5.删除字段\n1redis&gt; hdel student sex\n6.只获取字段名或者字段值\n12redis&gt; hkeys studentredis&gt; hvals student\n7.获得字段数量\n1redis&gt; hlen student \n\n四、列表1.向列表两端添加元素\n12redis&gt; lpush arr 12 13 14 15redis&gt; rpush arr 16 17 18\n2.获取列表片段\n1redis&gt; lrange arr 0 7\n3.从列表两端弹出元素\n12redis&gt; lpopredis&gt; rpop\n4.获取列表中元素的 个数\n1redis&gt; llen arr\n5.删除列表中指定元素\n1redis&gt; lrem arr 1 12 \n删除列表中前1个126.获得/设置指定索引的元素值\n12redis&gt; lindex arr 0redis&gt; lset arr 2 19\n7.只保留列表指定片段\n1redis&gt; ltrim arr 1 2\n8.向列表中插入元素\n12redis&gt; linsert arr after 13 12redis&gt; linsert arr before 19  14\n\n五 、集合1.增加 /删除元素\n12redis&gt; sadd obj 12 13 14 15 16 17redis&gt; srem obj 12\n2.获得元素中的所有元素\n1redis&gt; smembers obj \n3.判断元素是否在集合中\n12redis&gt; sismembers 13redis&gt; sismembers 11\n4.集合间运算\n123redis&gt; sdiff obj obj1        &#x2F;&#x2F;差集redis&gt; sinter obj obj1    &#x2F;&#x2F;交集redis&gt; sunion obj obj1      &#x2F;&#x2F;并集\n5.获得集合中元素个数\n1redis&gt; scard obj\n6.进行集合运算并将结果存储\n123redis&gt; sdiffstore  obj_sum obj obj1        redis&gt; sinterstore obj_sum obj obj1   redis&gt; sunionstore obj_sum obj obj1      \n7.随机获得集合中的元素\n1redis&gt; srandmember obj  [count]\ncount 可不写，用来确认随机返回多少个值8.从集合中弹出一个元素\n1redis&gt; spop obj [count]\n\n六、有序集合类型1.增加元素\n1redis&gt;&gt; zadd scoreboard 89 gavin 66 haha\n2.获得元素分数\n1redis&gt; zscore scoreboard gavin\n\n3.获得排名在某个范围的元素列表\n1redis&gt;zrange scoreboard 0 1\n4.获得指定分数范围的元素\n1redis&gt; zrangebyscore scoreboard 50 70\n5.增加某个元素的分数\n1redis&gt; zincrby scoreboard 4 haha\n6.获得集合中 元素的数量\n1redis&gt; zcard scoreboard\n7.获得指定分数范围内的元素个数\n1redis&gt; zcount scoreboard 60 71\n8.删除一个或多个元素\n1redis&gt; zrem scoreboard haha\n\n9.按照排名范围删除元素\n1redis&gt; zremrangebyrank scoreboard 0 1\n\n10.按照分数范围删除元素\n1redis&gt; zremrangebyscore scoreboard 10 30\n\n11.获得元素的排名\n12redis&gt; zrank scoreboard c #元素最小的是0redis&gt;  zrevrank scoreboard gavin # 元素最大的是0","url":"/2016/10/11/201610/Redis数据类型/","link":"","plink":"http://example.com/2016/10/11/201610/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Redis高级应用--数据持久化","content":"一、Redis数据持久化Redis数据保存在内存中，服务器由于一些原因断电后会丢失数据，因此需要将数据保存在硬盘上，防止服务器断电后数据丢失。将数据保存在硬盘上的过程就叫做数据持久化。持久化方式可分为两种：\n\n将数据当前的状态进行保存，通过快照的方式，只保存数据；\n将数据操作的过程进行保存，只保存数据的操作过程；\n\nreids支持两种持久化操作，一种是RDB方式，一种是AOF操作方式。RDB方式会根据制定规则“定时”将数据保存在硬盘上。而AOF方式会在每次执行命令后将命令本身记录下来。\n二、RDB方式RDB文件的创建RDB方式当符合条件时，redis会将 所有数据生成副本保存在本地，这个过程成为快照。以下几种方式对数据进行快照：\n\n配置的规则\n执行save或者bgsave命令\n执行flushall命令\n执行复制1.配置在redis安装文件中，打开redis.conf文件123save 900 1save 300 10save 60 10000\n条件之间是“或”的关系。save 900 1 是指在15分钟（900秒）内有一个或者一个以上键被更改就进行快照。值得注意的是，这里使用的是BGSAVE命令而不是SAVE命令。\n\n2.用户执行save 或bgsave命令服务器进行重启或者是备份时，需要手动对redis进行快照。  \n\n当执行save时，redis会执行快照操作，此时该过程会阻塞所有请求。  \nbgsave会异步的执行快照操作。，执行bgsave后会返回ok，然后通过lastsave来返回最近一次执行快照成功的时间。  3.执行flushall命令当执行flushall命令，redis会清空数据库中所有数据。4.执行复制时当设置主从模式之后，redis会在复制开始之前进行自动快照。SAVE指令相关配置创建新的redis.conf文件，文件内容如下：1234567port 6379daemonize yeslogfile &quot;6379.log&quot;  #配置redis的log文件名称dir &#x2F;data&#x2F;redis&#x2F;   #设置存储rdb文件的路径，应该存在存储空间较大的目录中dbfilename dump-6379.rdb #设置rdb文件的名称，通常为dump-端口号.rdbrdbcompression yes #设置rdb文件是否压缩，默认为yes，采用lzf压缩，如果设置为no，可以节省CPU运行时间，但是存储文件会变大。rdbchecksum yes #设置rdb文件是否进行格式校验，校验在读文件和写文件过程均进行。默认为开启状态，如果设置为no，可以节约10%时间，但是数据可能会损坏。\n并且使用一下命令启动redis，即可通过新的配置文件启动redis:1redis-server redis.conf \n\n\n\n\nRDB文件的载入RDB文件的载入是在服务器启动时自动执行，Redis没有专门用于载入RDB文件的命令，如果服务器启动时检测到RDB文件的存在则自动载入RDB文件。如果开启AOF持久化，那么服务器会优先使用AOF文件载入数据库。另外服务器载入RDB文件期间，数据库会处于阻塞状态，拒绝所有命令请求，直到载入数据完成。\n三、AOF方式AOF设置AOF（Append Only File）方式可以将redis的每一条命令追加到硬盘文件中。默认AOF是没有开启的。通过\n1appendonly yes \n开启AOF模式。\n\n但是由于操作系统原因，AOF模式保存的数据并没有保存到硬盘，而是保存在硬盘缓存。默认情况下是30秒执行一次同步。redis无法容忍这样的损失。这就要AOF模式将硬盘缓存中的数据立即同步到硬盘。在redis中可以通过appendfsync参数设置同步时机。\n12345# appendfsync always  # 每次，数据零误差，性能较低，不建议使用appendfsync everysec  # 每秒，性能较高，建议使用# appendfsync no      # 系统控制，不可控appendfilename appendonly-端口号.aof # 配置aof持久化文件名，默认为appendonly.aof，建议为appendonly-端口号.aofdir  &#x2F;data  # aof文件存储目录\n同时开启AOF和RDB，保证数据安全和备份。当服务器redis开启后，会首先加载AOF中的数据。因为AOF方式丢失的数据更少。\nAOF重写命令不断写入AOF，文件会越来越大，因此Redis引入AOF重写机制压缩文件体积。AOF重写是将多条命令合并为一条命令，例如：\n123lpush list alpush list blpush list c\n重写为：\n1lpush list a b c\n值得注意的是，AOF重写不会对原来的文件进行读取、修改和分析，而是创建新的AOF文件，来替换旧AOF文件。AOF重写不是读取和分析旧AOF文件，而是直接去数据库读取list的值，然后用新的命令代替原来的命令。\n手动重写1bgrewriteaof     # 执行指令重写aof文件\nbgrewriteaof命令是调用fork函数，创建子进程去重写文件\n自动重写12auto-aof-rewrite-min-size size  # AOF文件达到这个大小就重写auto-aof-rewrite-percentage percentage  # 达到这个比例就重写\n自动重写出发条件：\n1234aof_current_size &gt; auto-aof-rewrite-min-size(aof_current_size - aof_base_size) &#x2F;aof_base_size &gt;&#x3D; auto-aof-rewrite-percentage\n其中aof_current_size和aof_base_size参数可以通过info指令查看当前redis的参数值。","url":"/2016/10/25/201610/Redis高级应用数据持久化/","link":"","plink":"http://example.com/2016/10/25/201610/Redis%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"title":"【计算几何】Convex Hull凸包问题（一）","content":"一、什么是凸包在桌子上订上几个钉子，然后在这些钉子外围放上一个皮筋，将这些钉子包含进来，就形成了一个凸包。在一些点中，判断出来一个凸包的算法有很多，这里先介绍最基本的算法，然后再深入。\n\n二、算法    一般把p，q，r这些在凸包上的点称为极点。    这里判断一个点是不是极点的方法就是：在这个点画一条线，如果在这个点的另一侧没有其他的点，我们就认为这是一个极点。但是我们怎么判断这个点的另一侧有没有点呢？\n\n使用三角形来判断一个点是不是极点。在这些点中，任意选择三个点组成三角形，如果有一个点在三角形中，那么我们就认为这个点不是极点。遍历下来就可以确定极点和非极点\n使用python，算法就是这样\n123456789101112pointList &#x3D; [[1,1,1],[1,3,1],[2,4,1],[4,3,1],[2,3,1],[3,0,1],[3,4,1]]    #二维数组，前两位表示坐标（x，y），后一位表示是否为极点，1极点，0非极点p&#x3D;q&#x3D;r&#x3D;s&#x3D;0tempNum &#x3D; len(pointList)for p in range(0,tempNum):    for q in range(p+1,tempNum):        for r in range(q+1,tempNum):            for s in range(0,tempNum):                if s&#x3D;&#x3D;p or s&#x3D;&#x3D;q or s&#x3D;&#x3D;r or not(pointList[s][2]):                    continue                boolValue &#x3D; InTriangle(pointList[p],pointList[q],pointList[r],pointList[s])                if boolValue:                    pointList[s][2] &#x3D; 0\n但是怎么判断一个点是否在三角形中呢?我们可以为三角形中的三条边标注方向，如下图。如果点S在向量pq，qr，rp的左侧，我们就认为这个点在三角形内部。当然，如果每条边取相反的方向，这个点在每条边的右侧，我们也可以认为这个点在三角形内部。\n\n使用程序就是这样判断\n12345def InTriangle (p,q,r,s):    pqLeft &#x3D; toLeft(p,q,s)    qrLeft &#x3D; toLeft(q,r,s)    rpLeft &#x3D; toLeft(r,p,s)    return (pqLeft &#x3D;&#x3D; qrLeft)and(qrLeft &#x3D;&#x3D; rpLeft)\n我们可以使用线性代数上的二维向量组的行列式来解决判断一个点在直线的位置。连接上图的p，q，s作一个三角形。使用公式：\n\n这里是2倍的三角形面积，解行列式，如果值大于0，S在向量pq的左侧，小于0，S在向量pq的右侧。 \n1234567def Area(p,q,s):    return                                     p[0]*q[1]-p[1]*q[0]          +q[0]*s[1]-q[1]*s[0]           +s[0]*p[1]-s[1]*p[0]def toLeft(p,q,s):    return Area(p,q,s)&gt;0\n完整程序如下\n1234567891011121314151617181920212223def Area(p,q,s):    return p[0]*q[1]-p[1]*q[0]+q[0]*s[1]-q[1]*s[0]+s[0]*p[1]-s[1]*p[0]def toLeft(p,q,s):    return Area(p,q,s)&gt;0def InTriangle (p,q,r,s):    pqLeft &#x3D; toLeft(p,q,s)    qrLeft &#x3D; toLeft(q,r,s)    rpLeft &#x3D; toLeft(r,p,s)    return (pqLeft &#x3D;&#x3D; qrLeft)and(qrLeft &#x3D;&#x3D; rpLeft)pointList &#x3D; [[1,1,1],[1,3,1],[2,4,1],[4,3,1],[2,3,1],[3,0,1],[3,4,1]]tempList &#x3D; []p&#x3D;q&#x3D;r&#x3D;s&#x3D;0tempNum &#x3D; len(pointList)for p in range(0,tempNum):    for q in range(p+1,tempNum):        for r in range(q+1,tempNum):            for s in range(0,tempNum):                if s&#x3D;&#x3D;p or s&#x3D;&#x3D;q or s&#x3D;&#x3D;r or not(pointList[s][2]):                    continue                boolValue &#x3D; InTriangle(pointList[p],pointList[q],pointList[r],pointList[s])                if boolValue:                    pointList[s][2] &#x3D; 0print pointList\n\n这个算法的时间复杂度是O(n^4)，我们只用它来演示原理，不适合在项目中。","url":"/2016/11/14/201611/计算几何ConvexHull凸包问题一/","link":"","plink":"http://example.com/2016/11/14/201611/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95ConvexHull%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%80/"},{"title":"【计算几何】Convex Hull凸包问题（三）","content":"上回介绍的凸包算法的时间复杂度是O(n^3)，还远远不能满足我们的需求，现在来改进这个算法。上个算法是遍历边来找到极边，来判断凸包，但是遍历整个边又要浪费许多时间。于是我们就改进成下面的算法:通过下面的5个图来还原整个算法首先通过遍历，找到一个极点。找到X轴最接近下面的一个点，就可以确定这个点是极点（如果最下面存在一条线，有两个点，我们就选最靠近左面的点。）。这样我们通过O(n)的时间复杂度，就找到了一个极点。找到这个点之后，我们根据这个点，再找到另外一个能确定极边的点，通过这样不断的找，直到最后一个点回到原点。通过这种方式我们就完成了整个凸包的判断\n\n在判断一条边是否为极边的时候，我们继续使用第一个算法介绍的toLeft()函数，就这样我们就改进了这个算法。下面是代码：\n12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on Mon Nov 23 22:20:11 2015@author: gavin&quot;&quot;&quot;def Area(p,q,s):    return p[0]*q[1]-p[1]*q[0]+q[0]*s[1]-q[1]*s[0]+s[0]*p[1]-s[1]*p[0]def toLeft(p,q,s):        return Area(p,q,s)&gt;0#找最低的点，找不到就比较最左的点，返回一个极点def LTL(S,n):    lt &#x3D; k &#x3D; 0    for k in range(1,n):        if S[k][1]&lt;S[lt][1] or (S[k][1]&#x3D;&#x3D;S[lt][1] and S[k][0]&lt;S[lt][0]):            lt &#x3D; k    return ltdef markEE(S,n):    newList &#x3D; []    k &#x3D; p &#x3D; q &#x3D; 0    #初始化所有点都是非极点    for k in range(0,n):        S[k][2] &#x3D; 0         lt &#x3D; LTL(S,n)  #先找到一个最低点，这个最低点就是一个极点    k &#x3D; lt    newList.append(S[k])#添加第一个极点到极点列表里面    while 1:           S[k][2] &#x3D; 1        s &#x3D; -1        for t in range(0,n):            #如果要判断的t,k,s不相等，并且为相连的极点            if t !&#x3D; k and t !&#x3D; s and (s &#x3D;&#x3D; -1 or toLeft(S[k],S[s],S[t])):                s &#x3D; t        k &#x3D; s        if k &#x3D;&#x3D; lt:            break        newList.append(S[s])    return newList    #print SlineList &#x3D; []pointList &#x3D; [[4,3,0],[5,1,0],[2,3,0],[2,2,0],[3,2,0],[3,3,0],[1,1,0],[1,3,0],[2,4,0]] #二维数组，前两位是坐标，后一位存储是否为极点，0非极点，1极点lineList &#x3D; markEE(pointList,len(pointList))print lineList \n运行结果：\n\n通过这种算法，我们将算法时间复杂度降到了O(n^2), 并且的到了一个已经排序好的极点列表。","url":"/2016/11/14/201611/计算几何ConvexHull凸包问题三/","link":"","plink":"http://example.com/2016/11/14/201611/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95ConvexHull%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%89/"},{"title":"【计算几何】Convex Hull凸包问题（二）","content":"上次我们使用了一个解决凸包问题的算法，但是，算法的时间复杂度是O(n^4)，这是一个非常恐怖的时间复杂度，这种算法在实际项目中是绝对不会出现的。于是我们改进这个算法。现在我们从极边（也就是凸包上的边）开始考虑，连接任意两个点，如果这条边仅在边的一侧有点，那我们就能确定这个边是极边了\n\n任取两点，做向量pq，如果pq两侧都有值，我们就不认为这是极边，按照这种思路，我们就能写出来算法。而判断一个点是否在向量一侧可以参照上个算法的toLeft()函数,这样我们就改进了这个凸包算法\n附上代码：\n1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on Mon Nov 23 22:20:11 2015@author: gavin&quot;&quot;&quot;def Area(p,q,s):    return p[0]*q[1]-p[1]*q[0]+q[0]*s[1]-q[1]*s[0]+s[0]*p[1]-s[1]*p[0]def toLeft(p,q,s):    return Area(p,q,s)&gt;0def checkEdge(S,n,p,q):    LEmpty &#x3D; REmpty &#x3D; 1    k &#x3D; 0        while k&lt;n and (LEmpty or REmpty):        if (k !&#x3D; p) and (k !&#x3D; q):            if toLeft(S[p],S[q],S[k]):                LEmpty &#x3D; 0            else:                REmpty &#x3D; 0                    k+&#x3D;1        if (LEmpty or REmpty):            S[p][2] &#x3D; S[q][2] &#x3D; 1def markEE(S,n):    k &#x3D; p &#x3D; q &#x3D; 0    #初始化所有点都是非极点    for k in range(0,n):        S[k][2] &#x3D; 0         #遍历两个点    for p in range(0,n):        for q in range(p+1,n):            checkEdge(S,n,p,q)        pointList &#x3D; [[1,1,0],[1,3,0],[2,4,0],[4,3,0],[5,1,0],[2,3,0],[2,2,0],[3,2,0],[3,3,0]] #二维数组，前两位是坐标，后一位存储是否为极点，0非极点，1极点markEE(pointList,len(pointList))print pointList\n可以看到，这个算法的时间复杂度为O(n^3),这个算法和上一个算法相比，有了非常明显的进步。但是O(n^3)算法复杂度相对而言还是非常的高，那么我们还能改进这个算法吗？答案当然是可以！","url":"/2016/11/14/201611/计算几何ConvexHull凸包问题二/","link":"","plink":"http://example.com/2016/11/14/201611/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95ConvexHull%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98%E4%BA%8C/"},{"title":"【计算几何】Convex Hull凸包问题（四）","content":"Graham 栈扫描算法这个算法很简单，只用简单的数据结构–栈算法可以分为两步，第一步是先对所有点排序，然后依次加入新的点得到新的边。如果和上一条边是左转关系就压栈处理，如果是右转关系就弹出栈，直到形成右转关系。\n\n首先是排序，先选择Y最小的那个点，如果Y最小的点有多个，就选最靠左的那个点。选好第一个点，就开始对所有点进行排序，逆时针开始，按照角度的大小进行排序，角度小的在前，角度大的在后面。对所有点进行排序完就得到上面的图。排序完，按照下图规则，开始判断。连接1、2点，并在T栈中取出3，如果23线和12线相比是左转关系，就把3压入栈S中。\n\n下图中34线和23线相比还是左转关系，继续将4压入栈S\n\n按照这种规则，继续下去如果遇到右转，我们就把前一个S栈中的值取出来，再继续判断，直到左转为止。\n\n其代码可使用:\n12345while T !&#x3D; null:    if toLeft(S[1],S[0],T[0]):        S.push(T.pop[])    else:        S.pop()\n该算法时间复杂度是O(nlogn)","url":"/2016/11/14/201611/计算几何ConvexHull凸包问题四/","link":"","plink":"http://example.com/2016/11/14/201611/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95ConvexHull%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98%E5%9B%9B/"},{"title":"Apriori算法","content":"发现关联规则的算法分为两部分1、找到所有的频繁项集2、频繁项集中找到强关联规则\n找到强关联规则如果有了频繁项集L，可以产生所有的非空子集S。对于每一个S，我们试图产生这样的规则：S-&gt;(L-S)\n因为S  U (L-S) = L     因为L是频繁项集，所以L最小支持度大于这个阈值。\nL的可信度：S出现的情况下，L出现的条件概率是多少。\n所以，条件概率可以转换为：\n如果这个值大于最小支持度阈值，，那么一定是强关联规则。\n如何得到频繁项集Apriori算法是频繁项集挖掘的经典算法之一。Apriori性质：\n11.任何频繁项集的子集一定是频繁的。（不包括空集）\nApriori算法分为四步：\n12341.扫描数据库，得到所有的频繁1-项集2.由长度为K的频繁项集，生成长度为k+1的候选项集3.扫描数据库测试候选项集，得到长度为k+1的频繁项集4.第二步和第三步进行迭代，知道没有频繁项集或者是没有候选项集可以生成为止\n\n\n设置最小支持度为2\n找到   A：2   B：3   C：3   D：1   E：3所以D不符合，去掉\n然后得到候选2-项集C2:｛A,B｝,{A,C},{A,E},{B,C},{B,E},{C,E}。  对C2计数，去掉｛A,B｝,{A,E}，得到频繁2-项集L2  然后再得到候选3-项集｛B,C,E｝  算法结束。","url":"/2016/12/15/201612/Apriori算法/","link":"","plink":"http://example.com/2016/12/15/201612/Apriori%E7%AE%97%E6%B3%95/"},{"title":"Redis高级应用--应用场景学习笔记","content":"一. redi在直播中的应用场景一：用户信息管理\n在直播中有很多的信息。在一张用户表中，使用传统关系型数据库存储用户信息，扩展非常麻烦。redis对用户信息管理，采用hashes数据结构。用户id作为Key，每个用户的信息是Hashes中的Field。当需要对用户信息进行扩展时，使用Hset向用户所在的Hashes中新增一个field。\n场景二：关注列表在直播系统中有许多关注链，可以使用sets实现关注链。用户新关注一个人，则用sadd向用户列表里面添加一个value。最后还可以使用交集运算得到两个关注列表的交集部分。实现共同关注功能。场景三：积分排行在直播中，需要实时更新积分排行榜。使用有序集合，定义rank这个Key对应每个用户的积分。使用zadd增加用户的积分值。通过zrangebyscore zrank -inf +inf遍历用户key，得到指定范围的积分，得到排行榜。场景四：最新评论在redis中，通过lists来实现最新评论，当有用户评论时，调用lpush增加用户评论\n\n除上述场景外，Redis还可以用在于：\n PHP session信息 数据库缓存加速 点赞数、评论数目，通过Incr/decr进行数目增加或减少 消息广播，通过Subscribe/publish订阅模式实现 附件的人，redis 3.2中新增了附近的人功能\n学习资料:云栖社区https://yq.aliyun.com/articles/62559?spm=5176.8067841.0.0.Hl2rqJ","url":"/2016/12/03/201612/Redis高级应用应用场景学习笔记/","link":"","plink":"http://example.com/2016/12/03/201612/Redis%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"频繁项集和关联规则","content":"频繁项集和关联规则，通常应用在购物网站的猜你喜欢中。\n12频繁模式：数据集中频繁一起发生的模式关联分析：发现分析项集之间有趣的关联或相关性\n#####频繁项集在啤酒与尿布的经典例子中，超市通过这个规律将啤酒与尿布捆绑销售，达到了非常好的效果每一件商品可以看成一个项，多个商品或者是购物车中的所有物品可以看成一个项集。\n12itemset:A  set of one or more itemsK-itemset：X &#x3D; {X_1，.......X_k}  &#x2F;&#x2F;K-项集表示项集中有K个元素\n频繁模式挖掘就是挖掘经常出现在一个购物篮中的商品使用支持度来衡量那些经常放在一起的商品。支持度有两种：\n12绝对支持度，项集发生的频度（出现的次数，整数）相对支持度，这是百分比（概率），衡量一个项集出现的比例\n设置一个阈值，让支持度大于这个阈值，我们就认为它是频繁的。是一个频繁项集。\n\n\n\n购物篮\n项集\n\n\n\n1\n啤酒，坚果，尿布\n\n\n2\n啤酒，咖啡，尿布\n\n\n3\n啤酒，尿布，鸡蛋\n\n\n4\n坚果，鸡蛋，牛奶\n\n\n5\n坚果，咖啡，尿布，鸡蛋，牛奶\n\n\n以上面的购物篮为例：\n\n\n\n1.给定一个阈值为：50%  (相对支持度)\n\n\n\n2.换算成最小支持度计数: 5 * 50% = 2.5 -&gt; 3\n\n\n\n 其中5是指有5个购物篮。得出结果2.5，取整。等于3。也就是说只要大于或者等于3，那这个就是频繁项集。\n\n3.在购物篮中     啤酒 出现 3次     坚果 出现 3次     尿布 出现 4次     鸡蛋 出现 3次这些都是频繁项集。4. 频繁二项集：两个项一起出现的次数大于等于3的   啤酒 和 尿布 同时出现了3次。#####关联规则关联规则是X -&gt; Y的蕴含式强关联规则：大于最小支持度和最小可信度的关联规则X -&gt; Y的支持度是X和Y同时出现的概率X -&gt; Y的可信度是X发生的情况下，Y发生的条件概率\n\n1.如果：最小支持度是50%只有 啤酒 -&gt; 尿布  和  尿布 -&gt; 啤酒符合最小支持度\n1啤酒 -&gt; 尿布 通过公式计算是100%\n\n1尿布 -&gt; 啤酒 计算3 &#x2F; 4 &#x3D; 75%\n学习资料：学堂在线 1022817X 互联网大规模数据分析技术","url":"/2016/12/09/201612/频繁项集和关联规则/","link":"","plink":"http://example.com/2016/12/09/201612/%E9%A2%91%E7%B9%81%E9%A1%B9%E9%9B%86%E5%92%8C%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/"},{"title":"均摊分析时间复杂度","content":"在数据结构这门课，老师讲到实现动态顺序存储方式。给出了一个最好的办法：将数组扩大一倍，复制过去。　　 具体来说。以数组为例，我们都知道初始化一个数组，需要给数组规定一个大小。因为数组的大小是固定的，一旦元素超过了数组的固定大小，就会产生错误。这时我们需要开辟一个新的空间，假设原来数组大小是X，则新开辟空间的大小是2X。将原来的数据复制到新的空间。原来的空间释放掉。\n　　这里就会出现均摊时间复杂度。我们知道，假设n个数据，此时复制操作的时间复杂度是O(n)。因为是扩大了一倍，此时整个数组的大小是２ｎ，我们还可以再继续存放ｎ个数据。数组插入的时间复杂度是Ｏ(1)，只有剩余的n个空间全部插入数据才会开辟新的空间。　　开辟空间时间复杂度是O(n)，而执行完n次插入数据才会再继续开辟空间，插入数据的时间复杂度是O(1)，这n次插入数据操作平分开辟空间O(n)的时间复杂度，所以每次插入数据的时间复杂度都是O(1)。这就是均摊时间复杂度。　　C++中的vector（向量）就是这种方式实现动态的数组。","url":"/2017/01/17/201701/均摊分析时间复杂度/","link":"","plink":"http://example.com/2017/01/17/201701/%E5%9D%87%E6%91%8A%E5%88%86%E6%9E%90%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"title":"栈的应用（数制转换和人工模拟栈代替系统栈）","content":"##1、数制转换实现十进制N转其他d进制数，简单的算法基于：\n1N &#x3D; (N div d) x d + N mod d   &#x2F;&#x2F;其中div：整除运算，mod：取余运算\n例如：（1348）10    =   （2504）8\n\n\n\nN\nN div 8\nN mod 8\n\n\n\n1348\n168\n4\n\n\n168\n21\n0\n\n\n21\n2\n5\n\n\n2\n0\n2\n\n\n12345678910111213&#x2F;*  输入任意的一个非负的十进制整数，输出其对应的八进制数*&#x2F;void conversion(){    InitStack(S);  &#x2F;&#x2F;初始化一个栈S    scanf(&quot;%d&quot;,N);    while(N){        Push(S, N % 8);        N &#x3D; N &#x2F; 8;    }    while(){        Pop(S,e);        printf(&quot;%d&quot;,e);    }}\n图示：\n\n\n##2、人工模拟栈代替系统栈#####2.1什么是系统栈？说起系统栈，不得不提一下在操作系统中内存的用途，不管什么操作系统，进程调用的内存一般分成四个部分：\n1234代码区：存储被装入执行的二进制机器代码，处理器到这个区域读取指令数据区：存储全局变量堆区： 进程可以在堆区动态申请一部分内存，用完之后归还给堆区。动态分配和回收是堆区的特定。栈区：用于动态的存储函数之间的调用关系。保证调用函数返回时恢复到母函数中继续执行。\n这里的栈区就是指的系统栈。系统栈对于高级编程语言是透明的，它主要实现高级语言中的函数调用。如果你还没明白，不要紧。现在以这个C语言的例子来简单说一下系统栈的作用。\n12345678910# include&lt;stdio.h&gt;int func_a(){    &#x2F;&#x2F;return }int main(){    int var_num &#x3D; 0;    func_a();    return 0;\n　　当CPU执行func_a函数的时候，需要在main函数中的代码区找到跳转到func_a函数的机器指令，取指并执行后，func_a函数执行完毕之后，它是怎么返回到main函数中的呢？　　这些函数之间的跳转都是通过系统栈的配合来完成的，当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并压入系统栈中，当函数返回时系统栈会弹出该函数对应的栈帧。#####2.2 人工模拟栈\n12345678int func(int n){    if (n &lt;&#x3D; 1)    {        return 1;    }    return n * func(n -1);}\n　　这个递归的例子，函数不断的递归，需要不断的调用系统栈。 下面来实现人工模拟系统栈实现这个递归函数的运行过程。\n123456789101112do{    if(! back) {        if(n &lt;&#x3D; 1) {            back &#x3D; ture, ret &#x3D; 1;   &#x2F;&#x2F;判断是不是该返回了            continue;        }        n进栈；  &#x2F;&#x2F;将n的值存到栈中        --n;    }else{        ret *&#x3D; 出栈;   &#x2F;&#x2F;这里是栈返回的时候执行的。    }}while(栈不为空)\n参考资料栈：　　严, 蔚敏, 吴, 伟民. 数据结构(C语言版)[J]. 计算机教育, 2012, No.168(12):62-62.系统栈：　　佚名. 0day安全:软件漏洞分析技术(第2版)[J]. 信息安全与通信保密, 2013(11).","url":"/2017/01/25/201701/栈的应用数制转换和人工模拟栈代替系统栈/","link":"","plink":"http://example.com/2017/01/25/201701/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BA%BA%E5%B7%A5%E6%A8%A1%E6%8B%9F%E6%A0%88%E4%BB%A3%E6%9B%BF%E7%B3%BB%E7%BB%9F%E6%A0%88/"},{"title":"Brute-Force算法和KMP算法笔记","content":"模式匹配是数据结构中字符串的一种基本运算，给定一个子串，要求在某个字符串中找出与该子串相同的子串，这就是模式匹配。\n1、Brute-Force模式匹配算法　　Brute-Force算法的思想是：在主串S=”s1,s2,s3,…,sn”中的第一个字符与模式串T=”t1,t2,t3,…tn”中的第一个字符开始匹配，如果相等，则比较S串第二个字符和T串中的第二个字符。如果T串中的每个字符都与S串中连续的字符匹配成功，则返回S串中第一个下标的位置。如果匹配不想等，则将S中的第二个字符与T中第一个字符匹配，然后一次匹配下去。\n12345678910111213141516171819202122232425262728293031323334# include&lt;stdio.h&gt;&#x2F;*\tS[] 是主串\tT[] 是模式串 \tpos 是指在S中第pos个位置开始匹配，我设置为0\treturn i  如果匹配成功，返回 子串在S中第一个位置的下标。 匹配失败，返回-1 *&#x2F; int index_BF(char S[],char T[], int pos){\tint i &#x3D; pos;&#x2F;&#x2F;i是S中的位置 \tint j &#x3D; 0; &#x2F;&#x2F;j是T中的位置 \twhile(S[i] !&#x3D; &#39;\\0&#39; &amp;&amp; T[j] !&#x3D; &#39;\\0&#39;){\t\tif(S[i+j] &#x3D;&#x3D; T[j]){ &#x2F;&#x2F;两个字符判断成功，则j+1.判断下一个字符 \t\t\tj++;\t\t}else{ &#x2F;&#x2F;判断失败，则将T第一个与S第二个匹配 。于是i+1，S取下一个。j&#x3D;0，T重新开始匹配 \t\t\ti++;\t\t\tj &#x3D; 0;\t\t}\t} \tif(T[j] &#x3D;&#x3D; &#39;\\0&#39;){ &#x2F;&#x2F;T中所有字符与S中连续字符匹配成功。 \t\treturn i; \t}else{\t\treturn -1;\t} }int main(){\tchar S[] &#x3D; &quot;qwertyuiop&quot;;\tchar T[] &#x3D; &quot;io&quot;;\tint pos &#x3D; 0;\tint index &#x3D; index_BF(S,T,pos);\tprintf(&quot;%d&quot;,index);\treturn 0;} \n2、KMP模式匹配算法　　看了一晚上终于明白KMP算法。KMP算法使用一种预先处理的方式。首先将模式串自我匹配。这个图中我们可以看到，刚开始出现的是a,b,c，于是我们就在模式串中找到a,b,c。通过这种自我匹配的方式，找到模式串可能出现的位置。那么模式串是怎样自我匹配的呢。这里有前缀和后缀的概念。这样就能判断字符串前部和后部是不是有重复。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;  #include &lt;string.h&gt;    int next[32] &#x3D; {-999};  &#x2F;*这个函数就是对模式串预处理将预处理的信息保存到next数组中。整个程序只运行一次这个函数 *&#x2F; void get_next(char T[])  {      int k &#x3D; -1;      int j &#x3D; 0;      int tLen &#x3D; strlen(T);    next[j] &#x3D; k;  &#x2F;&#x2F;模式串第一个设置为-1     while (j &lt; tLen - 1)      {  \t\tif ( (k &#x3D;&#x3D; -1) || (T[j] &#x3D;&#x3D; T[k]) )         {              k++;             j++;              next[j] &#x3D; k;          }          else          {              k &#x3D; next[k];           }    }  }  int index_KMP(char S[], char T[], int pos)  {      int i &#x3D; pos;        int j &#x3D; 0;    int sLen &#x3D; strlen(S);    int tLen &#x3D; strlen(T);    while ( i &lt; sLen &amp;&amp; j &lt; tLen )      {          &#x2F;* j &#x3D; -1 表示next[0]*&#x2F;  \t\tif ( (j &#x3D;&#x3D; -1)  || S[i] &#x3D;&#x3D; T[j])          {              i++;              j++;                  }          else          {          \tprintf(&quot;j &#x3D;&#x3D; %d\\t&quot;,j);            j &#x3D; next[j];  &#x2F;&#x2F;next[j]里面存的是开始匹配的位置。                     }      }        if (tLen &#x3D;&#x3D; j)  &#x2F;&#x2F;表示整个T都对比完了，匹配成功了     {          return i - tLen ;      }      else      {          return -1;      }  }    int main(void)  {      char s[] &#x3D; &quot;qwertyuiop&quot;;      char t[] &#x3D; &quot;io&quot;;      int i;    int pos &#x3D; 0;      int index;      &#x2F;&#x2F; 预处理next数组     get_next(t);      index &#x3D; index_KMP(s, t, pos);      printf(&quot;%d\\n&quot;, index); \treturn 0; }","url":"/2017/02/27/201702/BruteForce算法和KMP算法笔记/","link":"","plink":"http://example.com/2017/02/27/201702/BruteForce%E7%AE%97%E6%B3%95%E5%92%8CKMP%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"title":"排序算法总结与实现笔记","content":"冒泡排序　　冒泡排序是最基础的排序算法，冒泡排序不断对比两个相邻的元素大小，将顺序错误的值交换。将大的值交换到数组的底部，过程像冒泡一样。排序算法时间复杂度是O(n^2)\n1234比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n12345678910111213141516171819202122232425262728# include&lt;stdio.h&gt;&#x2F;*冒泡排序*&#x2F;void bubble_sort(int *list){\tint length&#x3D; 10;  &#x2F;&#x2F;数组长度 \tint tempNum;      \tfor(int index &#x3D; 0;index &lt; length;index++)\t{\t\tfor(int i &#x3D; 1;i &lt; length- index;i++)\t\t{\t\t\tif(list[i-1] &gt; list[i]){\t\t\t\ttempNum &#x3D; list[i-1];\t\t\t\tlist[i-1] &#x3D; list[i];\t\t\t\tlist[i] &#x3D; tempNum;\t\t\t}\t\t}\t}}int main(){\tint list[10] &#x3D; {12,43,56,54,23,10,3,65,84,2};\tbubble_sort(list);\tfor(int i &#x3D; 0;i &lt; 10;i++)\t{\t\tprintf(&quot;%d\\t&quot;,list[i]);\t}\treturn 0;} \n\n选择排序　　选择排序是一种不稳定的排序。选择排序是将数组中最小（或最大）的值找出来，放到第一个位置上，然后在剩余的元素中找到最小（或最大）的值，放到第二个位置上。选择排序时间复杂度是O(n^2)，最好时间复杂度也是O(n^2)。　　假如有数组[5,5,3]，使用选择排序进行排序，最小值3会和第一个5互换位置，这就导致第一个5挪到第二5后面，所以选择排序是不稳定的排序。\n12345678910111213141516171819202122232425262728# include&lt;stdio.h&gt;&#x2F;*选择排序*&#x2F;void selection_sort(int *list){\tint length&#x3D; 10;  &#x2F;&#x2F;数组长度 \tint tempNum;      \tfor(int index &#x3D; 0;index &lt; length;index++)\t{\t\tfor(int i &#x3D; index;i &lt; length;i++)\t\t{\t\t\tif(list[index] &gt; list[i]){\t\t\t\ttempNum &#x3D; list[index];\t\t\t\tlist[index] &#x3D; list[i];\t\t\t\tlist[i] &#x3D; tempNum;\t\t\t}\t\t}\t}}int main(){\tint list[10] &#x3D; {12,43,56,54,23,10,3,65,84,2};\tselection_sort(list);\tfor(int i &#x3D; 0;i &lt; 10;i++)\t{\t\tprintf(&quot;%d\\t&quot;,list[i]);\t}\treturn 0;} \n\n直接插入排序 　　直接插入排序是将待排序的值，插入到前面已经排序好的值中，直到所有的值插入完。数组中的第一个值默认已经排序。直接插入排序的时间复杂度是Ｏ(n^2 )\n123456从第一个元素开始，该元素可以认为已经被排序取出下一个元素，在已经排序的元素序列中从后向前扫描如果该元素（已排序）大于新元素，将该元素移到下一位置重复步骤3，直到找到已排序的元素小于或者等于新元素的位置将新元素插入到该位置后重复步骤2~5\n12345678910111213141516171819202122232425262728# include&lt;stdio.h&gt;&#x2F;*插入排序*&#x2F;void insert_sort(int *list){\tint length&#x3D; 10;  &#x2F;&#x2F;数组长度 \tint key;   &#x2F;&#x2F;存放要插入的值     \tfor(int index &#x3D; 1;index &lt; length;index++) &#x2F;&#x2F;这里是从1开始遍历，因为默认0是已经排序完的 \t{\t\tkey &#x3D; list[index];\t\tfor(int i &#x3D; index-1;i &gt;&#x3D; 0;i--)\t\t{\t\t\tif(list[i] &gt; key){\t\t\t\tlist[i+1] &#x3D; list[i];\t\t\t\tlist[i] &#x3D; key;\t\t\t}\t\t}\t}}int main(){\tint list[10] &#x3D; {12,43,56,54,23,10,3,65,84,2};\tinsert_sort(list);\tfor(int i &#x3D; 0;i &lt; 10;i++)\t{\t\tprintf(&quot;%d\\t&quot;,list[i]);\t}\treturn 0;} \n\n折半插入排序（二分插入排序）　　折半插入是对直接插入的优化。由于直接插入算法中，需要将排序的元素依次插入前面排好序的元素中。折半查找减少了比较的次数，但是没有减少移动次数，所以算法时间复杂度还是Ｏ(n^2 )\n12345678910111213141516171819202122232425262728293031323334353637383940# include&lt;stdio.h&gt;&#x2F;*插入排序*&#x2F;void binary_insertion_sort(int *list){\tint length&#x3D; 10;  &#x2F;&#x2F;数组长度 \tint key;   &#x2F;&#x2F;存放要插入的值     \tfor(int i &#x3D; 1;i &lt; length;i++) &#x2F;&#x2F;这里是从1开始遍历，因为默认0是已经排序完的 \t{\t\tkey &#x3D; list[i];\t\tint left &#x3D; 0;\t\tint right &#x3D; i - 1;\t\twhile(left &lt;&#x3D; right)\t\t{\t\t\tint mid &#x3D; left + (right - left) &#x2F; 2;\t\t\tif(key &lt; list[mid]){\t\t\t\tright &#x3D; mid - 1;\t\t\t}else{\t\t\t\tleft &#x3D; mid + 1;\t\t\t}\t\t}\t\t&#x2F;*因为要排序的元素前面的元素是有序的，所以必须将left后面的元素向后移动位置\t\t这样才能空出来位置将要排序的元素插入进去。 \t\t*&#x2F;\t\tfor(int j &#x3D; i-1;j  &gt;&#x3D; left;j--)\t\t{\t\t\tlist[j+1] &#x3D; list[j]; \t\t}\t\tlist[left] &#x3D; key;\t}}int main(){\tint list[10] &#x3D; {12,43,56,54,23,10,3,65,84,2};\tbinary_insertion_sort(list);\tfor(int i &#x3D; 0;i &lt; 10;i++)\t{\t\tprintf(&quot;%d\\t&quot;,list[i]);\t}\treturn 0;} \n希尔排序希尔排序也是插入排序的一种，也称为缩小增量排序，是一种不稳定排序。以下面的数据为例 {12,43,56,54,23,10,3,65,84,2}，整个数据数量为10，，设置步长为5。则数据可以排列为:12　43　56　54　2310　3　65　84　2然后对每一列排序，变为：10　3　56　54　212　43　65　84　23然后将步长改变为２，将上面的数据重新排列为:10　356　542　1243　6584　23然后对上面的数据按列排序，最后，将步长改为１，再按照列排序。即完成排序过程。\n12345678910111213141516171819202122232425262728293031323334# include&lt;stdio.h&gt;&#x2F;*希尔排序*&#x2F;void binary_insertion_sort(int *list){\tint length &#x3D; 10;\tint dist &#x3D; length &#x2F; 2;  &#x2F;&#x2F;步长\tint key;\tint j;\twhile(dist &gt;  0)\t{\t\tfor(int i&#x3D;dist;i &lt; length;i++)&#x2F;&#x2F;从第二排，第一个元素开始遍历，知道最后一个 \t\t{\t\t\tkey &#x3D; list[i];\t\t\tj &#x3D; i;\t\t&#x2F;&#x2F;i是该元素原来的位置，j是对比过后，改变的地址 \t\t\twhile(j &gt;&#x3D; dist &amp;&amp; key &lt; list[j-dist])&#x2F;&#x2F;找到前面的同列中是不是有小的，遍历一遍 \t\t\t{\t\t\t\tlist[j] &#x3D; list[j-dist];\t\t\t\tj -&#x3D; dist;\t\t\t}\t\t\tlist[j] &#x3D; key;\t\t}\t\tdist &#x2F;&#x3D; 2;\t\t&#x2F;&#x2F;增量减半\t} }int main(){\tint list[10] &#x3D; {12,43,56,54,23,10,3,65,84,2};\tbinary_insertion_sort(list);\tfor(int i &#x3D; 0;i &lt; 10;i++)\t{\t\tprintf(&quot;%d\\t&quot;,list[i]);\t}\treturn 0;} \n\n归并排序　　归并排序是将两个已经排序好的数组合并，使用分治思想。我这里只实现了对数组的合并，可以使用递归对数组排序，使用2路归并算法。算法时间内复杂度为O(nlgn)。\n123456789101112131415161718192021222324252627282930313233343536373839# include&lt;stdio.h&gt;&#x2F;*归并排序*&#x2F;void merge_sort(int *list,int *list1,int *list2){\tint length_list1 &#x3D; 5;\tint length_list2 &#x3D; 5;\tint j &#x3D; 0;\tint key &#x3D; 0;\tfor(int i&#x3D;0;i&lt;length_list1;i++)\t{\t\twhile(list2[j] &lt; list1[i] &amp;&amp; j &lt; length_list2)\t\t{\t\t\tlist[key] &#x3D; list2[j];\t\t\tkey++;\t\t\tj++;\t\t}\t\tlist[key] &#x3D; list1[i];\t\tkey++;\t}\tif(j &lt; (length_list2-1))\t{\t\tfor(int k&#x3D;j+1;k&lt;length_list2;k++)\t\t{\t\t\tlist[k] &#x3D; list2[k];\t\t}\t}}int main(){\tint list1[5] &#x3D; {2,15,18,34,87};\tint list2[5] &#x3D; {4,21,43,54,65};\tint list[10];\tmerge_sort(list,list1,list2);\tfor(int i &#x3D; 0;i &lt; 10;i++)\t{\t\tprintf(&quot;%d\\t&quot;,list[i]);\t}\treturn 0;} \n\n快速排序 　　快速排序是随意选择一个元素作为基准数字，比基准数字大的在右边，比基准数字小的在左边。这样来快速排序。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# include&lt;stdio.h&gt;&#x2F;*快速排序*&#x2F;&#x2F;* 这里是排序 *&#x2F;int quick_sort(int *list,int i,int j){\tint base &#x3D; list[i];\twhile(i &lt; j)\t{\t\twhile(i &lt; j &amp;&amp; list[j] &gt;&#x3D; base)\t\t{\t\t\tj -&#x3D; 1;\t\t}\t\twhile(i &lt; j &amp;&amp; list[j] &lt; base)\t\t{\t\t\tlist[i] &#x3D; list[j];\t\t\ti +&#x3D; 1;\t\t\tlist[j] &#x3D; list[i];\t\t}\t\tlist[i] &#x3D; base;\t\t&#x2F;*   测试输出每一次的变化 \t\tfor(int k &#x3D; 0;k &lt; 10;k++)\t\t{\t\t\tprintf(&quot;%d\\t&quot;,list[k]);\t\t}\t\tprintf(&quot;\\n&quot;);\t\t*&#x2F;\t}\treturn i;}&#x2F;* 这里是一个递归*&#x2F;void recursion(int *list,int i,int j){\tint base &#x3D; 0;\tif(i &lt; j)\t{\t\tbase &#x3D; quick_sort(list,i,j);\t\trecursion(list,i,base);\t\trecursion(list,base+1,j);\t}}int main(){\tint list[10] &#x3D; {2,15,18,34,87,4,21,43,54,65};\tint i &#x3D; 0;\tint length &#x3D; 10; \trecursion(list,i,length-1);\tfor(int i &#x3D; 0;i &lt; 10;i++)\t{\t\tprintf(&quot;%d\\t&quot;,list[i]);\t}\treturn 0;} \n\n\n还有。。。","url":"/2017/02/24/201702/排序算法总结与实现笔记/","link":"","plink":"http://example.com/2017/02/24/201702/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"},{"title":"ApacheBench（ab）测试","content":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758E:\\xampp\\apache\\bin&gt;ab -n 1000 -c 10 http:&#x2F;&#x2F;localhost&#x2F;index.php&#x2F;&#x2F;-n 1000 表示发起1000个请求   -c 10 表示并发用户数为10     最后是请求的url，我测的本地This is ApacheBench, Version 2.3 &lt;$Revision: 1706008 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http:&#x2F;&#x2F;www.zeustech.net&#x2F;Licensed to The Apache Software Foundation, http:&#x2F;&#x2F;www.apache.org&#x2F;Benchmarking localhost (be patient)Completed 100 requestsCompleted 200 requestsCompleted 300 requestsCompleted 400 requestsCompleted 500 requestsCompleted 600 requestsCompleted 700 requestsCompleted 800 requestsCompleted 900 requestsCompleted 1000 requestsFinished 1000 requestsServer Software:        Apache&#x2F;2.4.17    &#x2F;&#x2F;被测试web服务器软件的名称。我用的apacheServer Hostname:        localhost         &#x2F;&#x2F;被测url的 主机名称Server Port:            80                 &#x2F;&#x2F;被测web服务器监听的端口Document Path:          &#x2F;index.php       &#x2F;&#x2F;被测请求的绝对地址Document Length:        0 bytes          &#x2F;&#x2F;http响应数据的正文长度Concurrency Level:      10              &#x2F;&#x2F;表示并发数Time taken for tests:   0.585 seconds   &#x2F;&#x2F;表示所有请求处理完成花费的总时间Complete requests:      1000             &#x2F;&#x2F;表示请求数Failed requests:        0               &#x2F;&#x2F;表示失败的请求数Non-2xx responses:      1000         &#x2F;&#x2F;如果接收到的HTTP响应数据的头信息中含有2XX以外的状态码，则会在测试结果中显示另一个名为“Non-2xx responses”的统计项，用于统计这部分请求数，这些请求并不算在失败的请求中。Total transferred:      259000 bytes     &#x2F;&#x2F;表示请求响应数据长度总和，包括http响应数据头文件和正文数据。HTML transferred:       0 bytes          &#x2F;&#x2F;表示请求中响应数据中正文数据总和Requests per second:    1709.31 [#&#x2F;sec] (mean)    &#x2F;&#x2F;吞吐率Time per request:       5.850 [ms] (mean)                &#x2F;&#x2F;用户平均 请求等待时间Time per request:       0.585 [ms] (mean, across all concurrent requests) &#x2F;&#x2F;服务器平均请求处理时间，等于吞吐率的倒数Transfer rate:          432.33 [Kbytes&#x2F;sec] received   &#x2F;&#x2F;表示请求单位时间内从服务器获取数据长度Connection Times (ms)              min  mean[+&#x2F;-sd] median   maxConnect:        0    0   0.4      0       2Processing:     2    5   5.6      5     100Waiting:        1    5   5.7      4      99Total:          2    6   5.6      5     100Percentage of the requests served within a certain time (ms)  &#x2F;&#x2F;描述每个请求处理时间的分布情况。表示99%的用户不超过20ms，90%的用户不超过7ms  50%      5  66%      5  75%      5  80%      6  90%      7  95%      9  98%     11  99%     20 100%    100 (longest request)","url":"/2017/03/11/201703/ApacheBenchab测试/","link":"","plink":"http://example.com/2017/03/11/201703/ApacheBenchab%E6%B5%8B%E8%AF%95/"},{"title":"设计模式-享元模式","content":"享元模式采用一个共享来避免大量拥有相同内容对象的开销。接口\n123456package Flyweight;public interface Flyweight {\tpublic void operation(String state);}\n享元角色类\n123456789101112131415161718package Flyweight;public class ConcreteFlyweight implements Flyweight{\tprivate Character intrinsicState &#x3D; null;\t\t\tpublic  ConcreteFlyweight(Character state) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tthis.intrinsicState &#x3D; state;\t}\t@Override\tpublic void operation(String state) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;Intrinsic State &#x3D;&quot;+this.intrinsicState);\t\tSystem.out.println(&quot;Extrinsic State &#x3D; &quot; +state);\t}\t}\n工厂角色类\n123456789101112131415161718192021package Flyweight;import java.util.HashMap;import java.util.Map;public class FlyweightFactory {\tprivate Map&lt;Character,Flyweight&gt; files &#x3D; new HashMap&lt;Character,Flyweight&gt;();\t\tpublic Flyweight factory(Character state){\t\t&#x2F;&#x2F;先在缓存中查找\t\tFlyweight fly &#x3D; files.get(state);\t\tif(fly &#x3D;&#x3D; null){\t\t\t&#x2F;&#x2F;对象不存在就创建一个新的\t\t\tfly &#x3D; new ConcreteFlyweight(state);\t\t\t&#x2F;&#x2F;将新的对象放到缓存中\t\t\tfiles.put(state,fly);\t\t}\t\treturn fly;\t}}\n客户端\n12345678910111213141516171819package Flyweight;public class learning4_26 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tFlyweightFactory factory &#x3D; new FlyweightFactory();\t\tFlyweight fly &#x3D; factory.factory(new Character(&#39;a&#39;));\t\tfly.operation(&quot;first call&quot;);\t\t\t\tfly &#x3D; factory.factory(new Character(&#39;b&#39;));\t\tfly.operation(&quot;second call&quot;);\t\t\t\tfly &#x3D; factory.factory(new Character(&#39;a&#39;));\t\tfly.operation(&quot;third call&quot;);\t\t\t}}\n输出结果\n123456Intrinsic State &#x3D;aExtrinsic State &#x3D; first callIntrinsic State &#x3D;bExtrinsic State &#x3D; second callIntrinsic State &#x3D;aExtrinsic State &#x3D; third call\n虽然创建了三个对象，但是实际只有两个对象。\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.[3] 《JAVA与模式》之享元模式","url":"/2017/04/27/201704/设计模式享元模式/","link":"","plink":"http://example.com/2017/04/27/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-代理模式","content":"静态代理模式代理模式就是为其他对象提供一种代理，用来控制对这个对象的访问。其中，RealSubject和Proxy同时实现Subject接口，并且Proxy对象包含RealSubject对象。\n\n引用代理对象的方式间接访问 目标对象，防止直接访问对象给系统带来的不必要复杂性\n通过代理对象对原有的业务增强共用接口123public interface Subject {    void request();}\n真实实体123456public class RealSubject implements Subject {    @Override    public void request() {        System.out.println(&quot;真实的请求&quot;);    }}\n代理1234567891011121314151617181920212223242526public class Proxy implements Subject {    &#x2F;&#x2F;被包含的真是对象    public Subject subject;    public Proxy(Subject subject) {        super();        this.subject &#x3D; subject;    }    @Override    public void request() {        dosomeThingBefore();&#x2F;&#x2F;前置增强        subject.request();        dosomeThingEnd();&#x2F;&#x2F;后置增强    }    private void dosomeThingBefore() {        System.out.println(&quot;请求开始了！&quot;);    }    private void dosomeThingEnd() {        System.out.println(&quot;请求结束了！&quot;);    }}\n客户端1234567public class Client {    public static void main(String[] args) {        Subject subject &#x3D; new RealSubject();        Proxy proxy &#x3D; new Proxy(subject);        proxy.request();    }}\n静态代理中的问题设计模式原则\n单一职责原则：一个类或者一个接口只负责唯一项职责，尽量设计出功能单一的接口。\n依赖倒转原则：高层模块不应该依赖底层模块具体实现，解耦高层和底层，即面对接口编程，当实现发生变化时，只需要提供新的实现类，不需要修改高层模块代码\n开闭-原则：程序对外扩展开放，对修改关闭；当需求发生变化时，可以通过新增模块来满足实现，而不是通过修改原来的实现代码来满足新需求。\n\n当新增真实实体时，需要修改Proxy类，因此静态代理模式违反了开闭原则\nJDK动态代理下面用一个例子来演示动态代理的优点，假设国外有两款产品，分别是A产品和B产品：\n1234567public interface AProduct {    void buy();}public interface BProduct {    void buy();}\n有A和B两个人想分别购买AB两款产品：\n123456789101112public class ABuyProduct implements AProduct {    @Override    public void buy() {        System.out.println(&quot;小A买了A产品！&quot;);    }}public class BBuyProduct implements BProduct {    @Override    public void buy() {        System.out.println(&quot;小B买了B产品！&quot;);    }}\n开一家代理公司帮助客户代购产品\n1234567891011121314151617181920212223242526272829303132333435public class ProxyCompany implements InvocationHandler {    &#x2F;&#x2F;被代理的对象    public Object object;    public Object getObject() {        return object;    }    public void setObject(Object object) {        this.object &#x3D; object;    }    &#x2F;&#x2F;初始化代理对象    public Object getProxyInstance() {        return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), this);    }    @Override    &#x2F;&#x2F;动态代理对方法进行增强    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        dosomeThingBefore();        Object ret &#x3D; method.invoke(object,args);        dosomeThingEnd();        return ret;    }    private void dosomeThingBefore() {        System.out.println(&quot;请求开始了！&quot;);    }        private void dosomeThingEnd() {        System.out.println(&quot;请求结束了！&quot;);    }}\n就这样完成了动态代理,不管出现C产品、D产品或者是其他客户，都不需要修改代理类，只需要新增对应的客户类或产品类：\n1234567891011121314151617public class Client {    public static void main(String[] args) {        &#x2F;&#x2F;国外有两个特别火的产品，分别是A产品和B产品        AProduct aProduct &#x3D; new ABuyProduct();        BProduct bProduct &#x3D; new BBuyProduct();        &#x2F;&#x2F;成立一个代理公司，帮助他们买国外的产品        ProxyCompany proxyCompany &#x3D; new ProxyCompany();        &#x2F;&#x2F;小A想买国外的A产品        proxyCompany.setObject(aProduct);        AProduct aProxyProduct &#x3D; (AProduct)proxyCompany.getProxyInstance();        aProxyProduct.buy();        &#x2F;&#x2F;小B想买B产品        proxyCompany.setObject(bProduct);        BProduct bProxyProduct &#x3D; (BProduct)proxyCompany.getProxyInstance();        bProxyProduct.buy();    }}\n动态代理原理\nJava对象的生命周期，从Java源文件编译为Java字节码，并通过类加载称为Class对象（保存在元空间/方法区中），然后实例化为Java对象。动态代理没有Java源文件，是在内存中生成Java字节码，从内存中热加载Java字节码。\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/26/201704/设计模式代理模式/","link":"","plink":"http://example.com/2017/04/26/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-创建者模式","content":"工厂模式是创建单个类。而创建者模式是将各种产品集中管理，创建复合对象，使用同样的构建过程，而创建不同的表示。接口\n123456package Builder;public interface Sender { &#x2F;&#x2F;接口\tpublic void Send();}\n两个实例：\n1234567891011package Builder;public class MailSender implements Sender{\t@Override\tpublic void Send() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;这个是 Mail&quot;);\t}\t}\n123456789101112package Builder;public class SmsSender implements Sender {\t@Override\tpublic void Send() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;这是 sms&quot;);\t}}\n创建者模式\n1234567891011121314151617181920212223package Builder;import java.util.ArrayList;import java.util.List;public class Builder {\tprivate List&lt;Sender&gt;list &#x3D; new ArrayList&lt;Sender&gt;();\tpublic List&lt;Sender&gt; produceMailSender(int count){\t\tfor(int i&#x3D;0;i&lt;count;i++){  &#x2F;&#x2F;这里可以是多个实例，现在循环创建一个\t\t\tlist.add(new MailSender());\t\t}\t\treturn list;\t}\tpublic List&lt;Sender&gt; produceSmsSender(int count){\t\tfor(int i&#x3D;0;i&lt;count;i++){\t\t\tlist.add(new SmsSender());\t\t}\t\treturn list;\t}}\n客户端\n123456789101112131415package Builder;import java.util.List;public class learning_4_24 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tBuilder builder &#x3D; new Builder();\t\tList&lt;Sender&gt;list &#x3D; builder.produceMailSender(10);\t\tSystem.out.println(list);\t}}\n工厂模式关注的是创建单个类，而创建者模式是创建符合对象，是一个集合。\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/25/201704/设计模式创建者模式/","link":"","plink":"http://example.com/2017/04/25/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-单例模式","content":"单例模式是一次只创建一个实例，不允许多个存在。所以让类自身保存它的唯一实例。这个类保证没有其他实例可以被创建，并提供一个其他类访问的方法。\n12345678910111213141516package Singleton;public class Singleton {\tprivate static Singleton instance;\tprivate Singleton()\t{\t\t&#x2F;&#x2F;私有构造方法，防止外界new创建这个类。\t}\tpublic static Singleton GetInstance(){\t\tif(instance &#x3D;&#x3D; null){  &#x2F;&#x2F;实例不存在，创建一个\t\t\tinstance &#x3D; new Singleton();\t\t}\t\treturn instance; &#x2F;&#x2F;如果存在直接返回\t}}\n客户端：\n123456789101112131415package Singleton;public class learning4_24 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSingleton s1 &#x3D; Singleton.GetInstance();\t\tSingleton s2 &#x3D; Singleton.GetInstance();\t\tif(s1 &#x3D;&#x3D; s2){\t\t\tSystem.out.println(&quot;两个对象相同。&quot;);\t\t}\t}}\n当多个线程同时创建这个类，有可能会造成创建多个实例。在我看的这本大话设计模式中有说明。我原来是写PHP，Python的，现在是大话设计模式和Java核心技术卷1两本书一起学，涉及到多线程，这里先留个坑，等我学完Java再做记录。\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/25/201704/设计模式单例模式/","link":"","plink":"http://example.com/2017/04/25/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-外观模式","content":"外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层的接口，这个接口使子系统更加容易使用。定义3个类\n123456789101112131415161718192021222324252627282930package Facade;public class CPU {\tpublic void startup(){\t\tSystem.out.println(&quot;cpu 启动&quot;);\t}\tpublic void shutdown(){\t\tSystem.out.println(&quot;cpu 关闭&quot;);\t}}package Facade;public class Memory {\tpublic void startup(){\t\tSystem.out.println(&quot;Memory 启动&quot;);\t}\tpublic void shutdown(){\t\tSystem.out.println(&quot;Memory 关闭&quot;);\t}}package Facade;public class Disk {\tpublic void startup(){\t\tSystem.out.println(&quot;Disk 启动&quot;);\t}\tpublic void shutdown(){\t\tSystem.out.println(&quot;Disk 关闭&quot;);\t}}\n外观类\n1234567891011121314151617181920212223242526package Facade;public class Computer {\tprivate CPU cpu;\tprivate Memory memory;\tprivate Disk disk;\tpublic Computer(){\t\tcpu &#x3D; new CPU();\t\tmemory &#x3D; new Memory();\t\tdisk &#x3D; new Disk();\t}\tpublic void startup(){\t\tSystem.out.println(&quot;开启计算机&quot;);\t\tcpu.startup();\t\tmemory.startup();\t\tdisk.startup();\t\tSystem.out.println(&quot;计算机开启完成&quot;);\t}\tpublic void shutdown(){\t\tSystem.out.println(&quot;关闭计算机&quot;);\t\tcpu.shutdown();\t\tmemory.shutdown();\t\tdisk.shutdown();\t\tSystem.out.println(&quot;计算机关闭完成&quot;);\t}}\n客户端\n123456789101112package Facade;public class learning4_25 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tComputer computer &#x3D; new Computer();\t\tcomputer.startup();\t\tcomputer.shutdown();\t}}\n输出结果\n12345678910开启计算机cpu 启动Memory 启动Disk 启动计算机开启完成关闭计算机cpu 关闭Memory 关闭Disk 关闭计算机关闭完成\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/26/201704/设计模式外观模式/","link":"","plink":"http://example.com/2017/04/26/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-工厂方法模式","content":"工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。\n抽象产品\n1234&#x2F;&#x2F;抽象产品interface Logger {\tvoid writeLog();}\n产品实现\n12345678910public class DatabaseLogger implements Logger{\t@Override\tpublic void writeLog() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;数据库记录日志&quot;);\t}\t}\n12345678910public class FileLogger implements Logger{\t@Override\tpublic void writeLog() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;文件记录日志&quot;);\t}\t}\n抽象工厂\n12345&#x2F;&#x2F;抽象工厂类interface LoggerFactory {\tpublic Logger createLogger();}\n具体工厂\n1234567891011121314public class DatabaseLoggerFactory implements LoggerFactory{\t@Override\tpublic Logger createLogger() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub&#x2F;&#x2F;\t\t连接数据库&#x2F;&#x2F;\t\t创建数据库记录对象\t\tLogger logger &#x3D; new DatabaseLogger();\t\treturn logger;\t}}\n123456789101112public class FileLoggerFactory implements LoggerFactory{\t@Override\tpublic Logger createLogger() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub&#x2F;&#x2F;\t\t创建文件日志记录对象\t\tLogger logger &#x3D; new FileLogger();\t\treturn logger;\t}\t}\n客户端\n12345678910111213public class Client {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tLogger logger;\t\tLoggerFactory factory;\t\tfactory &#x3D; new FileLoggerFactory();\t\tlogger &#x3D; factory.createLogger();\t\tlogger.writeLog();\t}}\n优点1.在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。2.在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。缺点1.每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。\n[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] 设计模式目录.","url":"/2017/04/24/201704/设计模式工厂方法模式/","link":"","plink":"http://example.com/2017/04/24/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-抽象工厂模式","content":"抽象工厂模式（Abstract Factory）：为创建一组相关或者互相依赖的对象提供一个接口，而无需指定它们对应的具体类。\n产品1\n12345package AbstractFactory;&#x2F;&#x2F;产品抽象类1interface IProduct1 {\tpublic void show();}\n产品2\n123456package AbstractFactory;&#x2F;&#x2F;抽线产品2interface IProduct2 {\tpublic void show();}\n实现产品1\n123456789101112package AbstractFactory;&#x2F;&#x2F;实现产品1public class Product1 implements IProduct1{\t@Override\tpublic void show() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;这是产品1&quot;);\t}\t}\n实现产品2\n12345678910111213package AbstractFactory;&#x2F;&#x2F;实现产品2public class Product2 implements IProduct2{\t@Override\tpublic void show() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;这是产品2&quot;);\t}\t}\n抽象工厂 \n1234567package AbstractFactory;&#x2F;&#x2F;抽象工厂interface IFactory {\tpublic IProduct1 createProduct1();\tpublic IProduct2 createProduct2();}\n工厂实现\n12345678910111213141516171819package AbstractFactory;public class Factory implements IFactory{\t@Override\tpublic IProduct1 createProduct1() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\treturn new Product1();\t}\t@Override\tpublic IProduct2 createProduct2() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\treturn new Product2();\t}\t}\n客户端\n1234567891011121314151617package AbstractFactory;public class Client {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tIFactory factory &#x3D; new Factory();\t\tfactory.createProduct1().show();\t\tfactory.createProduct2().show();\t\t\t\t\t\t\t};\t}\n 优点：       (1) 更换具体工厂类更加方便       (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。       (3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。缺点：       增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] 设计模式目录.[3] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/24/201704/设计模式抽象工厂模式/","link":"","plink":"http://example.com/2017/04/24/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-桥接模式","content":"桥接模式（Bridge），将抽象部分与它的实现部分分离，使它们都能独立变化。手机软件类\n12345package Bridge;&#x2F;&#x2F;手机软件类public abstract class HandsetSoft {\tpublic abstract void run();}\n手机游戏类和手机通讯录类\n1234567891011121314151617181920212223package Bridge;&#x2F;&#x2F;手机游戏类public class HandsetGame extends HandsetSoft{\t@Override\tpublic void run() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;运行手机游戏&quot;);\t}\t}package Bridge;&#x2F;&#x2F;手机通讯录类public class HandsetAddressList extends HandsetSoft{\t@Override\tpublic void run() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;运行手机通讯录&quot;);\t}}\n手机品牌类\n1234567891011package Bridge;&#x2F;&#x2F;手机品牌类public abstract class HandsetBrand {\tprotected HandsetSoft soft;\t&#x2F;&#x2F;设置手机软件\t\tpublic void SetHandsetSoft(HandsetSoft soft){\t\tthis.soft &#x3D; soft;\t}\t&#x2F;&#x2F;运行\tpublic  abstract void run();}\n两种手机品牌\n12345678910111213141516171819202122package Bridge;public class HandsetBrandN extends HandsetBrand{\t@Override\tpublic void run() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tsoft.run();\t}}package Bridge;public class HandsetBrandM extends HandsetBrand{\t@Override\tpublic void run() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tsoft.run();\t}}\n客户端\n123456789101112131415161718192021222324252627package Bridge;public class learning4_26 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tHandsetBrand ab;\t\t&#x2F;&#x2F;使用手机N的功能\t\tab &#x3D; new HandsetBrandN();\t\t\t\tab.SetHandsetSoft(new HandsetGame());\t\tab.run();\t\t\t\tab.SetHandsetSoft(new HandsetAddressList());\t\tab.run();\t\t&#x2F;&#x2F;使用手机M的功能\t\tab &#x3D; new HandsetBrandM();\t\t\t\tab.SetHandsetSoft(new HandsetGame());\t\tab.run();\t\t\t\tab.SetHandsetSoft(new HandsetAddressList());\t\tab.run();\t\t\t}}\n输出：\n1234运行手机游戏运行手机通讯录运行手机游戏运行手机通讯录\n如果要增加一个功能，只需要增加一个类。不会对其他的类有影响。\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/26/201704/设计模式桥接模式/","link":"","plink":"http://example.com/2017/04/26/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-模板方法模式","content":"模版方法模式，定义一个操作中的算法框架，将一些步骤延续到子类中实现。模板方法似的子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。算法框架\n1234567891011121314package Template;public abstract class AbstractPerson {\t&#x2F;&#x2F;定义整个流程\tpublic void prepareGotoSchool(){\t\tdressUp();\t\teatBreakfast();\t\ttakeThings();\t}\t&#x2F;&#x2F;不同的完成步骤\tprotected abstract void dressUp();\tprotected abstract void eatBreakfast();\tprotected abstract void takeThings();}\n具体类\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546package Template;public class Student extends AbstractPerson{\t@Override\tprotected void dressUp() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;穿校服&quot;);\t}\t@Override\tprotected void eatBreakfast() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;吃早饭&quot;);\t}\t@Override\tprotected void takeThings() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;背书包&quot;);\t}}package Template;public class Teacher extends AbstractPerson{\t@Override\tprotected void dressUp() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;穿正装&quot;);\t}\t@Override\tprotected void eatBreakfast() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;做早饭，吃早饭&quot;);\t}\t@Override\tprotected void takeThings() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;带着教案&quot;);\t}}\n客户端\n1234567891011121314package Template;public class learning4_26 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tStudent student &#x3D; new Student();\t\tstudent.prepareGotoSchool();\t\t\t\tTeacher teacher &#x3D; new Teacher();\t\tteacher.prepareGotoSchool();\t}}\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java设计模式之模板方法模式（Template Method）","url":"/2017/04/27/201704/设计模式模板方法模式/","link":"","plink":"http://example.com/2017/04/27/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-策略模式","content":"策略模式（Strategy），定义了算法家族，分别封装起来，让这些算法之间可以互相替换，在这种模式下，替换算法，不会影响使用算法的客户统一接口\n12345package Strategy;public interface Icalculator {\tpublic int calculate(String exp);}\n辅助类\n1234567891011package Strategy;public abstract class AbstractCalculator {\tpublic int[] split(String exp,String opt){\t\tString array[] &#x3D; exp.split(opt);\t\tint arrayInt[] &#x3D; new int[2];\t\tarrayInt[0] &#x3D; Integer.parseInt(array[0]);\t\tarrayInt[1] &#x3D; Integer.parseInt(array[1]);\t\treturn arrayInt;\t}}\t\n三种算法\n12345678910111213141516171819202122232425262728293031323334353637package Strategy;public class Plus extends AbstractCalculator implements Icalculator{\t@Override\tpublic int calculate(String exp) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tint arrayInt[] &#x3D; split(exp,&quot;\\\\+&quot;);\t\treturn arrayInt[0] + arrayInt[1];\t\t}}package Strategy;public class Minus extends AbstractCalculator implements Icalculator{\t@Override\tpublic int calculate(String exp) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tint arrayInt[] &#x3D; split(exp,&quot;-&quot;);\t\treturn arrayInt[0] - arrayInt[1];\t}}package Strategy;public class Multiply extends AbstractCalculator implements Icalculator{\t@Override\tpublic int calculate(String exp) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tint arrayInt[] &#x3D; split(exp,&quot;\\\\*&quot;);\t\treturn arrayInt[0] + arrayInt[1];\t}\t}\n客户端\n123456789101112package Strategy;public class learning4_26 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tString exp &#x3D; &quot;2+8&quot;;\t\tIcalculator cal &#x3D; new Plus();\t\tint result &#x3D; cal.calculate(exp);\t\tSystem.out.println(result);\t}}\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/27/201704/设计模式策略模式/","link":"","plink":"http://example.com/2017/04/27/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-简单工厂模式","content":"简单工厂模式是创建型模式，又叫静态工厂方法模式。简单工厂模式是由一个工厂对象决定创建哪一种类。被创建的实例通常具有共同的父类。 　　简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。共同的父类\n12345package factoryMethod;public interface Sender{\tpublic void Send();}\n被创建的实例\n123456789101112package factoryMethod;public class MailSender implements Sender{\t@Override\tpublic void Send() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;这是 电子邮件&quot;);\t}}\n123456789101112package factoryMethod;public class SmsSender implements Sender{\t@Override\tpublic void Send() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;这是 Sms&quot;);\t}\t}\n工厂方法\n1234567891011121314package factoryMethod;public class SendFactory {\tpublic Sender produce(String type){\t\tif (&quot;mail&quot;.equals(type)){\t\t\treturn new MailSender();\t\t}else if (&quot;sms&quot;.equals(type)){\t\t\treturn new SmsSender();\t\t}else{\t\t\tSystem.out.println(&quot;请输入正确的类型！&quot;);\t\t}\t\treturn null;\t}}\n客户端\n123456789101112package factoryMethod;public class learning_4_17 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSendFactory factory &#x3D; new SendFactory();\t\tSender sender &#x3D; factory.produce(&quot;mail&quot;);&#x2F;&#x2F;后面就是一个类\t\tsender.Send();\t}}  \n模式的核心是工厂类，这个类负责产品的创建，而客户端可以免去产品创建的责任，这实现了责任的分割。但由于工厂类集中了所有产品创建逻辑的，如果不能正常工作的话会对系统造成很大的影响。如果增加新产品必须修改工厂角色的源码。对于客户端来说，违反了开闭原则，可以将参数存放在xml或其他配置文件中，，这样如果需要更换参数，只需要更改配置文件即可，符合开闭原则。参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/23/201704/设计模式简单工厂模式/","link":"","plink":"http://example.com/2017/04/23/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-组合模式","content":"组合模式（Composite）,将对象组合成树形结构表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n123456789101112131415161718192021222324252627282930313233343536373839package Composite;import java.util.Enumeration;import java.util.Vector;public class TreeNode {\tprivate String name;\tprivate TreeNode parent;\tprivate Vector&lt;TreeNode&gt; children &#x3D; new Vector&lt;TreeNode&gt;();\t\tpublic TreeNode(String name){\t\tthis.name &#x3D; name;\t}\tpublic  String getName(){\t\treturn name;\t}\tpublic void setName (String name){\t\tthis.name &#x3D; name;\t}\tpublic TreeNode getParent(){\t\treturn parent;\t}\tpublic void setParent(TreeNode parent){\t\tthis.parent &#x3D; parent;\t}\t&#x2F;&#x2F;添加孩子节点\tpublic void add(TreeNode node){\t\tchildren.add(node);\t}\t\t&#x2F;&#x2F;\t删除孩子节点\tpublic void remove(TreeNode node){\t\tchildren.remove(node);\t}\t&#x2F;&#x2F;得到孩子节点\tpublic Enumeration&lt;TreeNode&gt; getChildren(){\t\treturn children.elements();\t}}\n客户端\n123456789101112131415161718package Composite;public class Tree {\tTreeNode root &#x3D; null;\tpublic Tree(String name){\t\troot &#x3D; new TreeNode(name);\t}\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tTree tree &#x3D; new Tree(&quot;A&quot;);\t\tTreeNode nodeB &#x3D; new TreeNode(&quot;B&quot;);\t\tTreeNode nodeC &#x3D; new TreeNode(&quot;C&quot;);\t\t\t\tnodeB.add(nodeC);\t\ttree.root.add(nodeB);\t\tSystem.out.println(&quot;树建立完成&quot;);\t}}\n\n\n\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/27/201704/设计模式组合模式/","link":"","plink":"http://example.com/2017/04/27/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-装饰模式","content":"装饰模式（Decorator）是动态的给一个对象添加一些额外的职责。要求装饰对象和被装饰对象实现同一个接口。共同继承\n12345package Decorator;public interface Sourceable {\tpublic void method();}\n被装饰类\n1234567891011package Decorator;public class Source implements Sourceable{\t@Override\tpublic void method() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;这是原来的方法&quot;);\t}\t}\n装饰类\n123456789101112131415161718package Decorator;public class Decorator implements Sourceable{\tprivate Sourceable source;\tpublic Decorator(Sourceable source){\t\tsuper();\t\tthis.source &#x3D; source;\t}\t\t@Override\tpublic void method() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;装饰之前&quot;);\t\tsource.method();\t\tSystem.out.println(&quot;装饰之后&quot;);\t}\t}\n客户端\n123456789101112package Decorator;public class learning4_25 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSourceable source &#x3D; new Source();\t\tSourceable obj &#x3D; new Decorator(source);\t\tobj.method();\t}}\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/26/201704/设计模式装饰模式/","link":"","plink":"http://example.com/2017/04/26/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-观察者模式","content":"观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。使这个主体对象的发生变化时，会通知所有的观察者对象，使它们自动的更新自己。\n观察者\n123456package Observer;&#x2F;&#x2F;观察者角色public interface Watcher {\tpublic void update(String str);}\n被观察者\n1234567package Observer;&#x2F;&#x2F;被观察者public interface Watched {\tpublic void addWatcher(Watcher watcher);\tpublic void removeWatcher(Watcher watcher);\tpublic void notifyWatcher(String str);}\n观察者\n1234567891011package Observer;&#x2F;&#x2F;具体观察者public class ConcreteWatcher implements Watcher{\t@Override\tpublic void update(String str) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(str);\t}\t}\n被观察者\n123456789101112131415161718192021222324252627282930package Observer;import java.util.ArrayList;import java.util.List;public class ConcreteWatched implements Watched{\t&#x2F;&#x2F;存放观察者\tprivate List&lt;Watcher&gt; list &#x3D; new ArrayList&lt;Watcher&gt;();\t@Override\tpublic void addWatcher(Watcher watcher) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tlist.add(watcher);\t}\t@Override\tpublic void removeWatcher(Watcher watcher) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tlist.remove(watcher);\t}\t@Override\tpublic void notifyWatcher(String str) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tfor(Watcher watcher : list){\t\t\twatcher.update(str);\t\t}\t}\t}\n客户端\n123456789101112131415161718192021package Observer;public class learning4_28 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\t&#x2F;&#x2F;被观察者\t\tWatched girl &#x3D; new ConcreteWatched();\t\t&#x2F;&#x2F;观察者\t\tWatcher watcher1 &#x3D; new ConcreteWatcher();\t\tWatcher watcher2 &#x3D; new ConcreteWatcher();\t\tWatcher watcher3 &#x3D; new ConcreteWatcher();\t\t&#x2F;&#x2F;添加进去观察者\t\tgirl.addWatcher(watcher1);\t\tgirl.addWatcher(watcher2);\t\tgirl.addWatcher(watcher3);\t\t\t\tgirl.notifyWatcher(&quot;广播&quot;);\t}}\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] 观察者模式.","url":"/2017/04/28/201704/设计模式观察者模式/","link":"","plink":"http://example.com/2017/04/28/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-适配器模式","content":"适配器模式（Adapter），是将一个类的接口转换成客户希望的另外一个接口。适配器模式是原来由于接口不兼容而不能在一起工作的那些类可以在一起工作。\n类适配器原来的方法\n1234567package adapter;public class Source {\tpublic void method1(){\t\tSystem.out.println(&quot;这是原来的方法&quot;);\t}}\n目标接口\n12345678package adapter;public interface Targetable {&#x2F;&#x2F;\t原来类的方法\tpublic void method1();&#x2F;&#x2F;\t新类的方法\tpublic void method2();}\n适配器(JAVA不支持多继承，所以继承一个类和一个接口)\n1234567891011package adapter;public class Adapter extends Source implements Targetable{\t@Override\tpublic void method2() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;这是新的方法&quot;);\t}\t}\n客户端\n12345678910111213package adapter;public class learning4_25 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tTargetable target &#x3D; new Adapter();\t\ttarget.method1();\t\ttarget.method2();\t}}\n输出结果：\n12这是原来的方法这是新的方法\n属性适配器原来的方法\n1234567package adapter;public class Source {\tpublic void method1(){\t\tSystem.out.println(&quot;这是原来的方法&quot;);\t}}\n适配器\n1234567891011121314151617181920212223package adapter;public class Wrapper implements Targetable{\tprivate Source source;\tpublic Wrapper (Source source){\t\tsuper();\t\tthis.source &#x3D; source;\t}\t\t@Override\tpublic void method1() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;这是新的方法&quot;);\t}\t@Override\tpublic void method2() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tsource.method1();\t}\t}\n客户端\n1234567891011121314package adapter;public class learning4_25 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSource source &#x3D; new Source();\t\tTargetable target &#x3D; new Wrapper(source);\t\ttarget.method1();\t\ttarget.method2();\t}}\n输出结果是\n123这是新的方法这是原来的方法\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/04/26/201704/设计模式适配器模式/","link":"","plink":"http://example.com/2017/04/26/201704/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"Nginx 初识","content":"nginx下载在http://nginx.org/ 网站，直接选择nginx-1.12.0稳定版本\n1wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.12.0.tar.gz   &#x2F;&#x2F;下载nginx\n\nnginx安装123tar zxvf nginx-1.12.0.tar.gz   &#x2F;&#x2F;直接解压cd nginx-1.12.0  &#x2F;&#x2F;进入解压后的文件夹.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;webServer   &#x2F;&#x2F;后面的&#x2F;usr&#x2F;webServer 表示你将服务器安装在这个路径里面\n使用./configure命令，遇到报错\n1234.&#x2F;configure: error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using --without-http_rewrite_moduleoption, or install the PCRE library into the system, or build the PCRE librarystatically from the source with nginx by using --with-pcre&#x3D;&lt;path&gt; option.\n查询资料说是没有安装PCRE，缺少依赖，在网上搜到nginx安装的需要的依赖，都安装上。\n123sudo apt-get install openssl libssl-dev    &#x2F;&#x2F;openssl安装sudo apt-get install libpcre3 libpcre3-dev   &#x2F;&#x2F;依赖包pcre安装sudo apt-get install zlib1g-dev   &#x2F;&#x2F;依赖包zlib安装\n继续使用./configure –prefix=/usr/webServer 命令，没有再报错，成功。\n1make &amp;&amp; make install   &#x2F;&#x2F;安装，注意安装需要权限\nnginx启动在安装完成的webServer文件夹中，有四个文件夹\n1234conf   --配置文件html   --网页文件，也就是网站代码放里面logs   --日志文件sbin   --二进制文件\n直接启动，监听80端口。\n1.&#x2F;sbin&#x2F;nginx\n控制nginx（信号量）123456TERM, INT\tfast shutdown   &#x2F;&#x2F;立即停止nginxQUIT\tgraceful shutdown   &#x2F;&#x2F;等待请求结束后再关闭nginxHUP\tchanging configuration, keeping up with a changed time zone (only for FreeBSD and Linux),starting new worker processes with a new configuration, graceful shutdown of old worker processes &#x2F;&#x2F;不关闭nginx，但是可以使配置文件马上生效USR1\tre-opening log files   &#x2F;&#x2F;重读日志文件。因为nginx进程一直打开日志文件，当移动或者备份日志文件时，需要使用这个命令，让nginx重新打开日志文件。USR2\tupgrading an executable file   &#x2F;&#x2F;nginx系统升级，直接替换掉二进制文件sbin&#x2F;nginx，然后使用这个命令平滑的升级。WINCH\tgraceful shutdown of worker processes\n命令\n12ps aux|grep nginx  &#x2F;&#x2F;查看nginx进程kill -命令  ngxin的主进程\n\n每次都需要查询一次nginx的主进程，很麻烦，可以直接使用：\n12cat logs&#x2F;nginx.pid  &#x2F;&#x2F;查看主进程pid，因为nginx将主进程pid保存在这个文件里kill -HUP &#96;cat logs&#x2F;nginx.pid&#96;  &#x2F;&#x2F;直接使用nginx.pid代替查询pid。注意：这里不是单引号，单引号报错","url":"/2017/05/23/201705/Nginx初识/","link":"","plink":"http://example.com/2017/05/23/201705/Nginx%E5%88%9D%E8%AF%86/"},{"title":"《大话设计模式》总结","content":"《大话设计模式》 是我3月份买的，当时正在准备考试，没怎么看。4月初又在找工作，租房子，直到4月下旬才开始看。JAVA我以前只是粗略的学完，代码量不很多，不过其他语言学的还是比较好，还能看懂Java代码和课本中的C#代码。\n 课本中的23中设计模式，刚开始读的还是比较费劲的，最好的学习方法是敲一遍，然后自己体会。于是我在网上找了个JAVA的设计模式教程，理解着课本，然后敲一遍。设计模式对我的感触很大，现在我也只是能理解，以后做项目要试着将设计模式融入进去，将这些设计模式熟练掌握。\n3月份在准备考试的时候，我就决定每个月读一本技术类的书。已经读完了一本《构建高性能WEB站点》，对我是醍醐灌顶，越发的觉得读书的好处。上个月读书节，网站做活动，一口气买了8本技术书，准备在接下来的一段时间里消化完。\n2017年5月5日   青岛","url":"/2017/05/06/201705/大话设计模式总结/","link":"","plink":"http://example.com/2017/05/06/201705/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"算法导论学习笔记--中位数和顺序统计量","content":"在一个由n个元素组成的集合中，第i个顺序统计量(order statistic)是该集合中第i小的元素。中位数是指所属集合的“中点元素”。当n为奇数时，中位数唯一；当n为偶数时，有两个中位数，这里只讨论出现在i = [(n+1)/2]处的（下中位数）。我们讨论从一个由n个互异的元素构成的集合中选择第i个顺序统计量的问题。将这一问题形式化定义为如下问题：\n12输入：一个包含 n个互异的数的集合A和一个整数i，1&lt;&#x3D;i&lt;&#x3D;n;输出：元素x属于A，且A中恰好有i-1个其他元素小于它。\n最小值和最大值确定最小值\n123456789MINIMUM(A){    min &#x3D; A[1];    for(i&#x3D;2;i&lt;&#x3D;A.length;i++){        if(min &gt; A[i]){            min &#x3D; A[i];        }    }    return min;}\n期望为线性时间的选择算法一般选择问题看起来要比找最小值的简单选择问题更难，但两种问题的渐近运行时间却是相同的：都是 O ( n )。这里介绍一种解决选择问题的分治算法，即 RANDOMIZED-SELECT算法。该算法利用了之前介绍的RANDOMIZED-PARTITION过程,它返回数组A[p..r]中第i小的元素。\n1234567891011121314RANDOMIZED-SELECT(A,p,r,i){    if(p &#x3D;&#x3D; r){        return A[p];    }    q &#x3D; RANDOMIZED-PARTITION(A,p,r);    k &#x3D; q - p + 1;    if(i &#x3D;&#x3D; k){        return A[q];    }else if(i &lt; k){        return RANDOMIZED-SELECT(A,p,q-1,i)    }else{        return RANDOMIZED-SELECT(A,q+1,r,i-k)    }}\n12345RANDOMIZED-PARTITION(A,p,r){\ti &#x3D; RANDOM(p,r);\tswap(A[r],A[i]);\treturn PARTITION(A,p,r);}\n123456789101112PARTITION(A,p,r){\tx &#x3D; A[r];\ti &#x3D; p - 1;\tfor(j &#x3D; p;j &lt;&#x3D; r-1;j++){\t\tif(A[j] &lt;&#x3D; x){\t\t\ti &#x3D; i + 1;\t\t\tswap(A[i],A[j]);\t\t}\t}\tswap(A[i+1],A[r]);\treturn i+1;}","url":"/2017/05/12/201705/算法导论学习笔记中位数和顺序统计量/","link":"","plink":"http://example.com/2017/05/12/201705/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/"},{"title":"算法导论学习笔记--优先队列","content":"优先队列和是一种用来维护由一组元素构成的集合S的数据结构，其中的每一个元素都有一个相关的值，称为关键字。和堆一样，优先队列也有两种形式，最大优先队列和最小优先队列。以最大优先队列为例：\n1234INSERT(S,X): 把元素x插入集合S中。MAXIMUM(S): 返回S中具有最大键字的元素。EXTRACT-MAX(S): 去掉并返回S中的具有最大键字的元素。INCREASE-KEY(S,x,k):将元素x的关键字值增加到k，这里假设k的值不小于x的原关键字值。\nEXTRACT-MAX(S)操作（取出并删除最大堆操作）\n12345678910HEAP-EXTRACT-MAX(A){    if(A.heap-size &lt; 1 ){        error;    }    max &#x3D; A[1];    A[1] &#x3D; A[A.heap-size];   &#x2F;&#x2F;取出来最大的一个，所以将最后一个值放到最前面。并将A.heap-size - 1    A.heap-size &#x3D; A.heap-size - 1;    MAX-HEAPIFY(A,1);&#x2F;&#x2F;因为最后一个值放在了最前面，违背了最大堆性质，这里维护一下最大堆性质    return max;}\n算法导论学习笔记–堆排序中的：\n1234567891011121314151617MAX-HEAPIFY(A,i){    l &#x3D; LEFT(i);    r &#x3D; RIGHT(i);    if(l &lt;&#x3D; A.heap-size and A[l] &gt; A[i]){    &#x2F;&#x2F;先判断A[i]  和  A[l] 哪个大        largest &#x3D; l;             &#x2F;&#x2F;选出最大的值，将下标存放在 largest中    }else{        largest &#x3D; i;    }    if(r &lt;&#x3D; A.heap-size and A[r] &gt; A[largest]){  &#x2F;&#x2F; 再判断A[r] 和刚刚判断出来的最大值 比较哪个大        largest &#x3D; r    }    if(largest !&#x3D; i){&#x2F;&#x2F;如果相等，则表示已经符合最大堆的性质，不相等就交换，然后递归。        swap(A[i],A[largest]);    &#x2F;&#x2F;交换位置        i &#x3D; largest;        largest &#x3D; -1;    }}\nHEAP-EXTRACT-MAX时间复杂度是O(lgn)，因为除了 MAX-HEAPIFY之外，其他都是常数阶。\nINCREASE-KEY操作（增加优先级）\n12345678910HEAP-INCREASE-KEY(A,i,key){    if(key &lt; A[i]){        error &quot;增加的key不能小于原来的值&quot;    }    A[i] &#x3D; key;    while(i &gt; 1 and A[PARENT(i)] &lt; [i]){     &#x2F;&#x2F; 如果增加后的大小大于父结点，则当前和父结点交换。          swap(A[i],A[PARENT(i)]);          i &#x3D; A[PARENT(i)];    }}\nHEAP-INCREASE-KEY的时间复杂度是O(lgn)。\nINSERT操作（将key插入）\n12345MAX-HEAP-INSERT(S,key){    A.heap-size &#x3D; A.heap-size +1;    A[A.heap-size] &#x3D; -10000;    HEAP-INCREASE-KEY(A,A.heap-size,key);}\nMAX-HEAP-INSERT的时间复杂度是O(lgn)。总之，在一个包含n个元素的堆中，所有优先队列 的操作都可以在O(lgn)时间内完成。","url":"/2017/05/10/201705/算法导论学习笔记优先队列/","link":"","plink":"http://example.com/2017/05/10/201705/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"title":"算法导论学习笔记--堆排序","content":"堆什么是堆？（二叉）堆是一个数组，可以被看成是完全二叉树，树上的每一个结点对应数组中的元素。除了底层，该树是完全充满的，并且是从左到右填充。表示堆的数组A包括两个属性：A.length通常表示数组元素的个数，A.heap-size表示有多少个堆元素存储在该数组中。0&lt;= A.heap-size&lt;=A.length。\n123假设根节点是A[1]PARENT(i)     &#x2F;&#x2F;父结点    return [i&#x2F;2]\n12LEFT(i)       &#x2F;&#x2F;左孩子结点    return[2i]\n12RIGHT(i)    &#x2F;&#x2F;右孩子结点    return[2i+1]\n\n堆的分类二叉堆分为两种形式：最大堆和最小堆。最大堆是指除了根之外的所有结点i都满足：\n1A[PARENT(i)]  &gt;&#x3D; A[i]\n最小堆是指除了根之外的所有结点i都满足:\n1A[PARENT(i)]  &lt;&#x3D; A[i]\n在堆排序 算法中，使用最大堆。最小堆通常用于构造优先队列。\n维护堆的性质MAX-HEAPIFY是用于维护最大堆性质的重要过程。这个函数输入一个数组A和一个下标i。我们假设根结点LEFT(i)和RIGHT(i)的二叉树都是最大堆，这是A[i]可能小于其他孩子，违背最大堆性质。所以需要让A[i]的值在最大堆中“逐级下降”。\n1234567891011121314151617MAX-HEAPIFY(A,i){    l &#x3D; LEFT(i);    r &#x3D; RIGHT(i);    if(l &lt;&#x3D; A.heap-size and A[l] &gt; A[i]){    &#x2F;&#x2F;先判断A[i]  和  A[l] 哪个大        largest &#x3D; l;             &#x2F;&#x2F;选出最大的值，将下标存放在 largest中    }else{        largest &#x3D; i;    }    if(r &lt;&#x3D; A.heap-size and A[r] &gt; A[largest]){  &#x2F;&#x2F; 再判断A[r] 和刚刚判断出来的最大值 比较哪个大        largest &#x3D; r    }    if(largest !&#x3D; i){&#x2F;&#x2F;如果相等，则表示已经符合最大堆的性质，不相等就交换，然后递归。        swap(A[i],A[largest]);    &#x2F;&#x2F;交换位置        i &#x3D; largest;        largest &#x3D; -1;    }}\n\n对于一棵以i为根结点，大小为n的子树，MAX-HEAPIFY的时间代价包括：调整A[i],A[RIGHT(i)],A[LEFT(i)]的关系的时间代价O(1),加上一棵以i的一个孩子为根结点的子树上运行MAX-HEAPIFY的时间代价（假设递归调用）。因为每个孩子的子树大小至多为2n/3(最坏情况发生在树的最底层恰好半满的时候)。所以递归式运行时间为：T(n) &lt;= T(2n/3) + O(1). 递归式可以解为：T(n) = O(lgn).也就是说，对于一个树高为h的结点来说，MAX-HEAPIFY的时间复杂度是O(h)。\n1234567891011121314151617181920迭代版MAX-HEAPIFY(A，i){    largest &#x3D; -1;    while(largest !&#x3D; i){        l &#x3D; LEFT(i);        r &#x3D; RIGHT(i);        if(l &lt;&#x3D; A.heap-size and A[l] &gt; A[i]){    &#x2F;&#x2F;先判断A[i]  和  A[l] 哪个大            largest &#x3D; l;             &#x2F;&#x2F;选出最大的值，将下标存放在 largest中        }else{            largest &#x3D; i;        }        if(r &lt;&#x3D; A.heap-size and A[r] &gt; A[largest])    {  &#x2F;&#x2F; 再判断A[r] 和刚刚判断出来的最大值 比较哪个大            largest &#x3D; r        }        if(largest !&#x3D; i){&#x2F;&#x2F;如果相等，则表示已经符合最大堆的性质，不相等就交换，然后递归。            swap(A[i],A[largest]);    &#x2F;&#x2F;交换位置            MAX-HEAPOFY(A,largest);   &#x2F;&#x2F;进行递归        }    }}\n建堆我们可以用自底向上的方法利用过程MAX-HEAPIFY把一个大小为n=A.length的数组A[1..n]转换为最大堆。\n123456BUILD-MAX-HEAP(A){    A.heap-size &#x3D; A.length;    fot(i &#x3D; A.length&#x2F;2 ; i&gt;0; i--){   &#x2F;&#x2F;结点1就是最大的堆的根结点        MAX-HEAPIFY(A,i);     }}\n　　可以使用简单的算法估算出BUILD-MAX-HEAP运行时间上界。每次调用MAX-HEAPIFY的 时间复杂度是O(lgn)，BUILD-MAX-HEAP需要O(n)次调用。因此总的时间复杂度是O(nlgn)。这个上界虽然正确，但不是渐进紧确的。　　我们还可以得到一个更紧确的界。可以观察到，不同结点运行MAX-HEAPIFY的时间与该结点的树高度有关系，而且大部分结点高度比较小。因此：包含n个元素的堆的高度为[lgn],高度为h的堆最多包含[n/2^(h+1)]个结点。　　在一个高度为h的结点上运行MAX-HEAPIFY的代价是O(h)，我们可以减BUILD-MAX-HEAP的总代价表示为：\n　　最终可以得出BUILD-MAX-HEAP的时间复杂度：\n\n因此，在线性时间内，可以把一个无序数组构造成一个最大堆。\n\n堆排序算法　　堆排序算法利用 BUILD-MAX-HEAP将输入数组A[1..n]建成最大堆，其中n=A.length。因为数组中最大元素总在根结点A[1]中，通过把它与A[n]进行交换，可以将该元素放到正确的位置。如果我们去掉结点n，剩余的结点中，原来根的孩子结点仍然是最大堆，而新的结点有可能会违背最大堆原则，所以调用MAX-HEAPIFY,从而构造出一个新的最大堆。\n123456789HEAPSORT(A){    BUILD-MAX-HEAP(A){        for(i&#x3D;A.length;i&gt;1;i--){            swap(A[1],A[i]);            A.heap-size &#x3D; A.heap-size - 1;            MAX-HEAPIFY(A,1);        }    }}\nHEAPSORT过程的时间复杂度是O(nlgn)，因为每次调用BUILD-MAX-HEAP的时间复杂度是O(n)，而n-1次调用MAX-HEAPIFY，每次的时间是O(lgn)；\n最小堆性质最小堆\n12345678910111213141516MIN-HEAP(A,i){    l &#x3D; LEFT(i);    r &#x3D; RIGHT(i);    if(l &lt;&#x3D; A.heap-size and A[l] &lt; A[i]){    &#x2F;&#x2F;先判断A[i]  和  A[l] 哪个小        largest &#x3D; l;             &#x2F;&#x2F;选出最大的值，将下标存放在 largest中    }else{        largest &#x3D; i;    }    if(r &lt;&#x3D; A.heap-size and A[r] &lt; A[largest]){  &#x2F;&#x2F; 再判断A[r] 和刚刚判断出来的最大值 比较哪个大        largest &#x3D; r    }    if(largest !&#x3D; i){&#x2F;&#x2F;如果相等，则表示已经符合最大堆的性质，不相等就交换，然后递归。        swap(A[i],A[largest]);    &#x2F;&#x2F;交换位置        MIN-HEAPOFY(A,largest);   &#x2F;&#x2F;进行递归    }}","url":"/2017/05/08/201705/算法导论学习笔记堆排序/","link":"","plink":"http://example.com/2017/05/08/201705/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"算法导论学习笔记--堆里面的两个性质","content":"每个孩子的子树的大小至多为2n/3(最坏情况发生在树的最底层恰好为半满的时候)规定总大小为n。当左子树为最大时，最底层恰好为半满。也就是最底层只有左子树有结点，右子树没有结点。设底层半满时节点数为y，则再加y个节点，就是满树，并且根据满二叉树的特–若底层元素个数为x,则元素总数为2x-1.所以n+y = 2y -1 +2y = 满树，所以n = 3y - 1即左子树结点数= （满树-1）/2 = (4y-2)/2=2y-1= 2n / 3\n对于任意包含n个元素的堆中，至多有[n/2^(k+1)]个高度为h的结点最底层的元素个数为n/2个，这层高度为0；倒数第二层元素个数为n/4个，高度为1；倒数第三层元素个数为n/8个，高度为2；如此类推，高度为h的，在倒数第h + 1层，元素个数为n / 2^(h + 1)。","url":"/2017/05/09/201705/算法导论学习笔记堆里面的两个性质/","link":"","plink":"http://example.com/2017/05/09/201705/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A0%86%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%80%A7%E8%B4%A8/"},{"title":"算法导论学习笔记--快速排序","content":"对于n个数的输入数组，快速排序最坏时间复杂度是O（n^2）,虽然最坏情况下的时间复杂度很差，但是快速排序通常是实际排序应用中最好的选择，因为它平均性能最好，期望时间复杂度是O（nlgn）。\n快速排序的描述快速排序分成三步：\n分解数组A[p..r],被划分为两个子数组A[p..q-1]和A[q+1..r],使得A[p..q-1]中的每一个元素都小于或等于A[q],而A[q]也小于A[q+1..r]中的每个元素。\n解决通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序。\n合并因为子数组都是原址排序，所以不需要合并操作：数组A[p..r]已经有序。\n快速排序实现\n1234567QUICKSORT(A,p,r){\tif(p &lt; r){\t\tq &#x3D; PARTITION(A,p,r);\t\tQUICKSORT(A,p,q-1)\t\tQUICKSORT(A,q+1,r)\t}}\n数组的划分\n123456789101112PARTITION(A,p,r){\tx &#x3D; A[r];\ti &#x3D; p - 1;\tfor(j &#x3D; p;j &lt;&#x3D; r-1;j++){\t\tif(A[j] &lt;&#x3D; x){\t\t\ti &#x3D; i + 1;\t\t\tswap(A[i],A[j]);\t\t}\t}\tswap(A[i+1],A[r]);\treturn i+1;}\n快速排序的随机化版本随机划分使用 随机取样（random sampling）的随机化技术，从子数组A[p..r]中随机选择一个元素并与A[r]互换，因为主元是随机选择的，我们期望在平均情况下，对输入数组的划分能够比较对称。\n12345RANDOMIZED-PARTITION(A,p,r){\ti &#x3D; RANDOM(p,r);\tswap(A[r],A[i]);\treturn PARTITION(A,p,r);}\n1234567RANDOMIZED-QUICKSORT(A,p,r){\tif(p &lt; r){\t\tq &#x3D; RANDOMIZED-PARTITION(A,p,r);\t\tRANDOMIZED-QUICKSORT(A,p,q-1)\t\tRANDOMIZED-QUICKSORT(A,q+1,r)\t}}","url":"/2017/05/10/201705/算法导论学习笔记快速排序/","link":"","plink":"http://example.com/2017/05/10/201705/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"算法导论学习笔记--基本数据结构","content":"栈的几种操作:S.top=0时，表示栈中不包含任何元素，即栈是空的。\n12345678&#x2F;&#x2F;判断栈是不是空的STACK-EMPTY(S){\tif(S.top &#x3D;&#x3D; 0){\t\treturn TRUE;\t}else{\t\treturn FALSE;\t}}\n压入栈操作：\n12345PUSH(S,x){\t&#x2F;&#x2F;要考虑栈是不是满的\tS.top &#x3D; S.top + 1;\tS[S.top] &#x3D; x;}\n弹出数据操作：\n12345678POP(S){\tif(STACK-EMPTY(S)){\t\terror(空的);\t}else{\t\tS.top &#x3D; S.top -1\t}\treturn S[S.top + 1]}\n队列的几种操作Q.head 指向队头元素Q.tail 指向下一个新元素将要插入的位置入队操作\n123456789&#x2F;&#x2F;这个是循环队列，暂时没考虑队溢出ENQUEUE(Q,x){\tQ[Q.tail] &#x3D; x\tif(Q.tail &#x3D;&#x3D; Q.length){\t\tQ.tail &#x3D; 1\t}else{\t\tQ.tail &#x3D; Q.tail + 1\t}}\n出队操作\n123456789DEQUEUE(Q){\tx &#x3D; Q[Q.head]\tif(Q.head &#x3D;&#x3D;  Q.legth){\t\tQ.head &#x3D; 1\t}else{\t\tQ.head &#x3D; Q.head + 1\t}\treturn x}\n链表\n链表的搜索查找链表L中第一个关键字为k的元素\n1234567LIST-SEARCH(L,k){\tx &#x3D; L.head\twhile(x !&#x3D; NULL and x.key !&#x3D; k){\t\tx &#x3D; x.next\t}\treturn x}\n链表的插入这里是循环链表\n12345678LIST-INSERT(L,x){\tx.next &#x3D; L.head\tif(L.head !&#x3D; NULL){ &#x2F;&#x2F;先判断整个链表中有没有值\t\tL.head.prev &#x3D; x\t}\tL.head &#x3D; x\tx.prev &#x3D; NULL}\n链表删除将元素x在链表L中删除\n12345678910LIST-DELETE(L,x){\tif(x.prev !&#x3D; NULL){\t\tx.prev.next &#x3D; x.next;\t}else{\t\tL.head &#x3D; x.next;\t}\tif(x.next !&#x3D; NULL){\t\tx.next.prev &#x3D; x.prev;\t}}","url":"/2017/05/18/201705/算法导论学习笔记基本数据结构/","link":"","plink":"http://example.com/2017/05/18/201705/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"设计模式-中介者模式","content":"中介者模式是利用一个中介对象来封装一系列对象交互。中介者使各对象不需要显式的相互作用，从而使其耦合松散，而且可以独立的改变他们之间的交互。\n中介\n123456package Mediator;public interface Mediator {      public void createMediator();      public void workAll();  }  \n123456789101112131415161718192021222324252627package Mediator;public class MyMediator implements Mediator {  \t      private User user1;      private User user2;            public User getUser1() {          return user1;      }        public User getUser2() {          return user2;      }        @Override      public void createMediator() {          user1 &#x3D; new User1(this);          user2 &#x3D; new User2(this);      }        @Override      public void workAll() {          user1.work();          user2.work();      }  }  \n两个实例\n12345678910111213141516package Mediator;public abstract class User {          private Mediator mediator;            public Mediator getMediator(){          return mediator;      }            public User(Mediator mediator) {          this.mediator &#x3D; mediator;      }        public abstract void work();  }  \n12345678910111213package Mediator;public class User1 extends User {  \t      public User1(Mediator mediator){          super(mediator);      }            @Override      public void work() {          System.out.println(&quot;user1 exe!&quot;);      }  }  \n12345678910111213package Mediator;public class User2 extends User {  \t      public User2(Mediator mediator){          super(mediator);      }            @Override      public void work() {          System.out.println(&quot;user2 exe!&quot;);      }  }  \n客户端\n123456789package Mediator;public class learning5_5 {\tpublic static void main(String[] args) {          Mediator mediator &#x3D; new MyMediator();          mediator.createMediator();          mediator.workAll();      }  }\n输出结果\n12user1 exe!user2 exe!\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/05/06/201705/设计模式中介者模式/","link":"","plink":"http://example.com/2017/05/06/201705/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-命令模式","content":"命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n12345package Command;&#x2F;&#x2F;接口public interface Command {\tpublic void exe();}\n命令\n12345678910111213141516package Command;&#x2F;&#x2F;命令public class MyCommand implements Command{\t\tprivate Receiver receiver;\t\tpublic MyCommand(Receiver receiver){\t\tthis.receiver &#x3D; receiver;\t}\t@Override\tpublic void exe() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\treceiver.action();\t}\t}\n被调用者\n1234567package Command;&#x2F;&#x2F;被调用者public class Receiver {\tpublic void action(){\t\tSystem.out.println(&quot;收到命令&quot;);\t}}\n调用者\n123456789101112package Command;&#x2F;&#x2F;调用者public class Invoker {\tprivate Command command;\tpublic Invoker(Command command){\t\tthis.command &#x3D; command;\t}\t\tpublic void action(){\t\tcommand.exe();\t}}\n客户端\n123456789101112131415package Command;import Iterator.MyCollection;public class learning_5_4 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tReceiver receiver &#x3D; new Receiver();\t\tCommand cmd &#x3D; new MyCommand(receiver);\t\tInvoker invoker &#x3D; new Invoker(cmd);\t\tinvoker.action();\t}}\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/05/05/201705/设计模式命令模式/","link":"","plink":"http://example.com/2017/05/05/201705/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-备忘录模式","content":"备忘录模式是保存一个对象的状态，在以后可以将这个对象恢复到原来保存的状态。\n12345678910111213141516171819202122232425package Memento;&#x2F;&#x2F;原始类public class Original {\tprivate String value;\t\tpublic String getValue(){\t\treturn value;\t}\t\tpublic void setValue(String value){\t\tthis.value &#x3D; value;\t}\t\tpublic Original(String value){\t\tthis.value &#x3D; value;\t}\t\tpublic Memento createMemento(){\t\treturn new Memento(value);\t}\t\tpublic void restoreMemento(Memento memento){\t\tthis.value &#x3D; memento.getValue();\t} }\n123456789101112131415161718package Memento;&#x2F;&#x2F;备忘录类public class Memento {\tprivate String value;\t\tpublic Memento(String value){\t\tthis.value &#x3D; value;\t}\tpublic String getValue(){\t\treturn value;\t}\t\tpublic void setValue(String value){\t\tthis.value &#x3D; value;\t}\t\t}\n1234567891011121314151617package Memento;&#x2F;&#x2F;存储备忘录public class Storage {\tprivate Memento memento;\t\tpublic Storage(Memento memento){\t\tthis.memento &#x3D; memento;\t}\t\tpublic Memento getMemento(){\t\treturn memento;\t}\t\tpublic void setMemento(Memento memento){\t\tthis.memento &#x3D; memento;\t}}\n客户端\n123456789101112131415161718192021222324package Memento;public class learning5_5 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\t\t\t&#x2F;&#x2F;创建原始类\t\tOriginal origi &#x3D; new Original(&quot;egg&quot;);\t\t\t\t&#x2F;&#x2F;创建备忘录\t\tStorage storage &#x3D; new Storage(origi.createMemento());\t\t\t\t&#x2F;&#x2F;修改原始类的状态\t\tSystem.out.println(&quot;初始化状态为：&quot;+origi.getValue());\t\torigi.setValue(&quot;niu&quot;);\t\tSystem.out.println(&quot;修改后的状态为：&quot;+origi.getValue());\t\t\t\t&#x2F;&#x2F;回复原始类的状态\t\torigi.restoreMemento(storage.getMemento());\t\tSystem.out.println(&quot;恢复后的状态为：&quot;+origi.getValue());\t}}\n输出\n123初始化状态为：egg修改后的状态为：niu恢复后的状态为：egg\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/05/06/201705/设计模式备忘录模式/","link":"","plink":"http://example.com/2017/05/06/201705/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-状态模式","content":"当对象的状态发生改变时，同时改变它的行为。\n状态类\n12345678910111213141516171819202122package state;public class State {          private String value;            public String getValue() {          return value;      }        public void setValue(String value) {          this.value &#x3D; value;      }        public void method1(){          System.out.println(&quot;执行第一个选择!&quot;);      }            public void method2(){          System.out.println(&quot;执行第二个选择!&quot;);      }  }  \n状态切换\n12345678910111213141516171819202122232425package state;public class Context {\tprivate State state;  \t      public Context(State state) {           this.state &#x3D; state;      }        public State getState() {          return state;      }        public void setState(State state) {          this.state &#x3D; state;      }        public void method() {          if (state.getValue().equals(&quot;state1&quot;)) {              state.method1();          } else if (state.getValue().equals(&quot;state2&quot;)) {              state.method2();          }      }  }\n客户端\n12345678910111213141516171819package state;public class learning5_5 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tState state &#x3D; new State();          Context context &#x3D; new Context(state);                    &#x2F;&#x2F;设置第一种状态          state.setValue(&quot;state1&quot;);          context.method();                    &#x2F;&#x2F;设置第二种状态          state.setValue(&quot;state2&quot;);          context.method();  \t}}\n输出结果\n12执行第一个选择!执行第二个选择!\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/05/06/201705/设计模式状态模式/","link":"","plink":"http://example.com/2017/05/06/201705/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-解释器模式","content":"解释器模式，给定一个语言，定义它的文法的一种表示，并定义一个解释器。这个解释器使用该表示来解释语言中的句子。\n12345package Interpreter;public interface Expression {      public int interpret(Context context);  } \n123456789package Interpreter;public class Plus implements Expression {  \t      @Override      public int interpret(Context context) {          return context.getNum1()+context.getNum2();      }  }  \n123456789package Interpreter;public class Minus implements Expression {  \t      @Override      public int interpret(Context context) {          return context.getNum1()-context.getNum2();      }  }  \n12345678910111213141516171819202122232425package Interpreter;public class Context {          private int num1;      private int num2;            public Context(int num1, int num2) {          this.num1 &#x3D; num1;          this.num2 &#x3D; num2;      }            public int getNum1() {          return num1;      }      public void setNum1(int num1) {          this.num1 &#x3D; num1;      }      public int getNum2() {          return num2;      }      public void setNum2(int num2) {          this.num2 &#x3D; num2;      }   }  \n客户端   计算9+2-8的值  \n12345678910111213141516package Interpreter;public class learning5_5 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\t&#x2F;&#x2F; 计算9+2-8的值          int result &#x3D; new Minus().interpret((        \t\t\tnew Context(        \t\t\t\tnew Plus().interpret(new Context(9, 2)), 8        \t\t\t)        \t\t));          System.out.println(result);  \t}}\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/05/06/201705/设计模式解释器模式/","link":"","plink":"http://example.com/2017/05/06/201705/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-访问者模式","content":"访问者模式就是分离对象数据结构和行为的方法。通过这种分离，可以达到一个访问者动态添加新的操作而无需做其他的修改。要访问的对象\n12345package visitor;public interface Visitor {\tpublic void visit(Subject sub);}\n123456789101112package visitor;public class MyVisitor implements Visitor{\t@Override\tpublic void visit(visitor.Subject sub) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(&quot;visit the subject：&quot;+sub.getSubject());  \t}}\n被访问\n12345678package visitor;public interface Subject {\t&#x2F;&#x2F;accept方法，接受将要访问它的对象\tpublic void  accept(Visitor visitor);\t&#x2F;&#x2F;getSubject()获取将要被访问的属性\tpublic String getSubject();}\n1234567891011121314151617package visitor;public class MySubject implements Subject{\t@Override\tpublic void accept(Visitor visitor) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tvisitor.visit(this);\t}\t@Override\tpublic String getSubject() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\treturn &quot;love&quot;;\t}}\n客户端\n123456789101112package visitor;public class learning5_5 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tVisitor visitor &#x3D; new MyVisitor();\t\tSubject sub &#x3D; new MySubject();\t\tsub.accept(visitor);\t}}\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/05/06/201705/设计模式访问者模式/","link":"","plink":"http://example.com/2017/05/06/201705/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-责任链模式","content":"责任链模式使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个关系连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。操作\n12345package ChainofResponsibility;public interface Handler {\tpublic void operator();}\nget和set方法\n123456789101112package ChainofResponsibility;public abstract class AbstractHandler {\tprivate Handler handler;\t\tpublic Handler getHandler(){\t\treturn handler;\t}\tpublic void setHandler(Handler handler){\t\tthis.handler &#x3D; handler;\t}}\n核心\n12345678910111213141516171819package ChainofResponsibility;public class MyHandler extends AbstractHandler implements Handler{\tprivate String name;\t\tpublic MyHandler(String name){\t\tthis.name &#x3D; name;\t}\t@Override\tpublic void operator() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSystem.out.println(name+&quot;deal!&quot;);\t\tif(getHandler()!&#x3D;null){\t\t\tgetHandler().operator();\t\t}\t}\t}\n客户端\n12345678910111213141516package ChainofResponsibility;public class learning_5_5 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tMyHandler h1 &#x3D; new MyHandler(&quot;h1&quot;);\t\tMyHandler h2 &#x3D; new MyHandler(&quot;h2&quot;);\t\tMyHandler h3 &#x3D; new MyHandler(&quot;h3&quot;);\t\th1.setHandler(h2);\t\th2.setHandler(h3);\t\t\t\th1.operator();\t}}\n输出\n123h1deal!h2deal!h3deal!\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美从菜鸟到高手演变之设计模式.","url":"/2017/05/06/201705/设计模式责任链模式/","link":"","plink":"http://example.com/2017/05/06/201705/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-迭代器模式","content":"迭代器模式是提供一种方法顺序的访问对象中的各个元素，而不暴露该对象的内部表示。\n操作\n12345678910111213package Iterator;public interface Iterator {\t&#x2F;&#x2F;前移\tpublic Object previous();\t\t&#x2F;&#x2F;后移\tpublic Object next();\tpublic boolean hasNext();\t\t&#x2F;&#x2F;取得第一个元素\tpublic Object first();}\n对象\n1234567891011package Iterator;public interface Collection {\tpublic Iterator iterator();\t&#x2F;&#x2F;\t取得集合元素\tpublic Object get(int i);\t&#x2F;&#x2F;\t取得集合大小\tpublic int size();}\n实际操作\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package Iterator;public class MyIterator implements Iterator{\t\tprivate Collection collection;\tprivate int pos &#x3D; -1;\t\tpublic MyIterator(Collection collection){\t\tthis.collection &#x3D; collection;\t}\t\t@Override\tpublic Object previous() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tif(pos &gt; 0){\t\t\tpos--;\t\t}\t\treturn collection.get(pos);\t}\t@Override\tpublic Object next() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tif(pos &lt; collection.size()-1){\t\t\tpos ++;\t\t}\t\treturn collection.get(pos);\t}\t@Override\tpublic boolean hasNext() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tif(pos &lt; collection.size()-1){\t\t\treturn true;\t\t}else{\t\t\treturn false;\t\t}\t}\t@Override\tpublic Object first() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tpos &#x3D; 0;\t\treturn collection.get(pos);\t}}\n对象\n123456789101112131415161718192021222324package Iterator;public class MyCollection implements Collection{\tpublic String string[] &#x3D; {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;};\t@Override\tpublic Iterator iterator() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\treturn new MyIterator(this);\t}\t@Override\tpublic Object get(int i) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\treturn string[i];\t}\t@Override\tpublic int size() {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\treturn string.length;\t}}\n客户端\n1234567891011121314package Iterator;public class learning5_3 {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tCollection collection &#x3D; new MyCollection();\t\tIterator it &#x3D; collection.iterator();\t\t\t\twhile(it.hasNext()){\t\t\tSystem.out.println(it.next());\t\t}\t}}\n输出\n12345ABCDE\n参考资料[1] 程杰. 大话设计模式[M]. 清华大学出版社, 2007.[2] Java之美(从菜鸟到高手演变)之设计模式三","url":"/2017/05/03/201705/设计模式迭代器模式/","link":"","plink":"http://example.com/2017/05/03/201705/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"Nginx中优化性能的配置项","content":"（1） Nginx worker 进程数量语法： worker_processes  number;默认：worker_processes  1;在master/worker 方式运行下，定义worker进程个数。具体配置个数跟实际业务有关。&gt;&gt;&gt;线程数究竟设多少合理&lt;&lt;&lt;（2）绑定Nginx worker 进程到指定的CPU内核语法： worker_cpu_affinity cpumask [cpumask..]假设每个worker进程都是非常忙的，如果有多个worker进程都在抢一个CPU，就会出现同步问题。反之，如果每个worker进程都独享一个CPU，则在内核调度策略上实现了完全并发。配置规则为：\n1232核cpu，开启2个进程worker_processes     2;worker_cpu_affinity 01 10;\n1232核cpu，开启4个进程worker_processes     4;worker_cpu_affinity 01 10 01 10;\n1234个cpu，开启4个进程worker_processes     4;worker_cpu_affinity 0001 0010 0100 1000;\n1234核cpu，开启2个进程worker_processes     2;worker_cpu_affinity 0101 1010;\n1238核cpu，开启8个进程worker_processes     8;worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;\n（3）SSL硬件加速语法：ssl_engine device;如果设备上有SSL硬件加速设备，那么可以配置加快SSL协议的处理速度。可以使用OpenSSL命令查看是否有SSL硬件设备：\n1openssl engine -t\n（4）系统调用gettimeofday的执行频率语法：timer_resolution t;默认情况下，每次内核时间调用返回时都会执行一次gettimeofday，实现用内核的时钟来更新Nginx中的缓存时钟。设置timer_resolution  100ms; 表示至少100ms才会调用一次gettimeofday。早期linux调用gettimeofday代价比较大，现在代价并不大，一般不用配置这个。（5）Nginx worker 进程优先级设置语法: worker_priority nice;默认: worker_priority 0;该项配置用于设置Nginx worker进程的nice优先级。在linux系统中，进程分配的CPU时间片大小和进程优先级有关，优先级越高，进程分配到的时间片越大（在默认配置下，最小时间片5ms，最大800ms）。优先级越高占用系统资源时间越多。\n参考资料：1、陶辉. 深入理解Nginx（第二版）[M]. 机械工业出版社.2、解读：nginx的一个神秘配置worker_cpu_affinity","url":"/2017/06/21/201706/Nginx中优化性能的配置项/","link":"","plink":"http://example.com/2017/06/21/201706/Nginx%E4%B8%AD%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9/"},{"title":"算法导论学习笔记--二叉搜索树","content":"二叉搜索树上的基本操作所花费的时间与这颗树的高度成正比。对于有n个结点的一棵完全二叉树来说，这些操作最坏运行时间是O（lgn）。如果这棵树是一条n个结点组成的线性链，那么同样的操作就要花费O（n）的最坏运行时间。在树中查找是否存在value==x的node的代价是O(h),h是树的深度。\n什么是二叉搜索树二叉搜索树，又称为二叉查找树或二叉排序树。一棵二叉搜索树是以一棵二叉树来组织。这样一棵树可以使用一个链表 数据结构来表示。每一个结点是一个对象。除了key和卫星数据外，每个结点还包含属性left，right和p，它们分别指向结点的左孩子、右孩子和双亲。如果某个孩子结点和父结点不存在，则对应的属性为NIL.根结点是树中唯一一个父指针为NIL的结点。对于一个二叉搜索树来说：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n\n二叉树允许我们使用简单的中序遍历算法来按序输出二叉树中的所有关键字。中序遍历是因为输出的子树根的关键字位于其左子树的关键字值和右子树的关键字值之间。类似的：先序遍历中输出的根的关键字在其左右子树的关键字值之前，后序遍历输出的根的关键字在其左右关键字值之后。通过调用INORDER-TREE-WALK(T.root)，就可以输出一棵二叉树T中的所有元素。\n1234567INORDER-TREE-WALK(x){    if(x !&#x3D; NIL){        INORDER-TREE-WALK(x.left);        print x.key;        INORDER-TREE-WALK(x.right);    }}\n所以，上图中（a）的中序遍历结果应该为：2，5，5，6，7，8。\n12定理 12.1 如果x是一棵有n个结点的子树的根，那么调用INORDER-TREE-WALK(x)需要O(n)时间。\n查询二叉搜索树查找在一棵二叉搜索树中查找一个具有给定关键字的结点。输入一个指向树根的结点和一个关键字k，如果这个结点存在，TREE-SEARCH返回一个指向关键字为k的结点的指针，否则返回NIL.\n12345678910TREE-SEARCH(x,k){    if(x &#x3D;&#x3D; NIL or k &#x3D;&#x3D; x.key){        return x;    }    if(k &lt; x.key){        return TREE-SEARCH(x.left,k);    }else{        return TREE-SEARCH(x.right,k);    }}\nTREE-SEARCH(x,k)的运行时间为O(h)我们可以采用while循环来代替递\n12345678910ITERATIVE-TREE-SEARCH(x,k){    while(x !&#x3D; NIL and k !&#x3D; x.key){        if(k &lt; x.key){            x &#x3D; x.left;        }else{            x &#x3D; x.right;        }    }    return x;}\n最大关键字元素和最小关键字元素123456TREE-MINIMUM(x){    while(x.left !&#x3D; NIL){        x &#x3D; x.left;    }    return x;}\nTREE-MAXIMUM(x)的代码是对称的。\n123456TREE-MAXIMUM(x){    while(x.right !&#x3D; NIL){        x &#x3D; x.right;    }    return x;}\n后继和前驱给定一个二叉查找树中的结点，有时要求找出其在中序遍历顺序下它的后继。如果所有的关键字均不相同，则某一结点 x 的后继即具有大于 x.key 中的关键字中最小者的那个结点。\n1234567891011TREE-SUCCESSOR(x){    if(x.right !&#x3D; NIL){        return TREE-MINIMUM(x.right);    }    y &#x3D; x.p;    while(y !&#x3D; NIL and x &#x3D;&#x3D; y.right){        x &#x3D; y;        y &#x3D; y.p;    }    return y;}\n12定理 12.2在一棵高度为h的二叉搜索树上 ，动态集合上的操作SEARCH,MINIMUM,MAXIMUM,SUCCESSOR和PREDECESSOR可以在O（h）时间内完成。\n插入和删除插入和删除操作会引起由二叉搜索树表示的动态集合的变化。一定要修改 数据结构来反应变化，但是修改后要保持二叉搜索树的性质。\n插入要将一个值v插入到一棵二叉搜索树T中，需要TREE-INSERT.这个过程以结点z作为输入，其中z.key = v,z.left = NIL,z.right = NIL.\n123456789101112131415161718192021TREE-INSERT(T,z){    y &#x3D; NIL;    x &#x3D; T.root;    while(x !&#x3D; NIL){  &#x2F;&#x2F;找到自己的位置        y &#x3D; x;        if(z.key &lt; x.key){            x &#x3D; x.left;        }else{            x &#x3D; x.right;        }    }    z.p &#x3D; y;    if(y &#x3D;&#x3D; NIL){        T.root &#x3D; z;    }else if(z.key &lt; y.key){        y.left &#x3D; z;    }else{        y.right &#x3D; z;    }}\n删除在二叉搜索树T中删除一个结点z的整个策略分为三种情况。1、如果z没有孩子结点，那么简单的删除，并修改父结点，用NIL作为孩子来替换z2、如果z只有一个孩子，那么将这个孩子提升到树中z的位置，并修改z的父结点，用z的孩子来代替掉z。3、如果z有两个孩子，那么找z的后继y（一定在z的右子树中），并让y占据树中z的位置。z原来的右子树变为y的右子树，并且z的左子树成为y的新左子树。TREE-DELETE 过程用于从二叉查找树 T 中删除一个给定的结点 z ，它按如下四种情况组织代码。\n12345如果结点 z 没有左孩子，那么我们用右孩子替换 z ，其中右孩子可能为 NIL 。右孩子为 NIL 即结点 z 没有孩子结点的情况。如果结点 z 有且只有左孩子，那么就用左孩子替代结点 z 。否则，结点 z 有两个子结点。首先找到 z 的后继结点 y ，它位于 z 的右子树且没有左孩子。这里我们打算用 y 替换 z 。如果 y 是 z 的右孩子，那么直接用 y 替换 z 。否则，用 y 自己的右孩子替换 y ，再用 y 来替换 z 。\n为了在二叉搜索树内移动子树，定义一个子过程TRANSPLANT，它是用另一颗子树替换一棵子树并成为其双亲的孩子结点。当TRANSPLANT用一棵以v为根的子树来替换一棵以u为根的子树时，结点u的双亲就变为结点v的双亲，并且最后v变成u的双亲响应孩子。\n123456789101112TRANSPLANT(T,u,v){    if (u.p &#x3D;&#x3D; NIL){        T.root &#x3D; v;    }else if(u &#x3D;&#x3D; u.p.left){        u.p.left &#x3D; v;    }else{        u.p.right &#x3D; v;    }    if(v !&#x3D; NIL){        v.p &#x3D; u.p;    }}\n1234567891011121314151617TREE-DELETE(T,z){    if(z.left &#x3D;&#x3D; NIL){        TRANSPLANT(T,z,z.right);    }else if(z.right &#x3D;&#x3D; NIL){        TRANSPLANT(T,z,z.left);    }else{        y &#x3D; TREE-MINIMUM(z.right);        if (y.p !&#x3D; z){  &#x2F;&#x2F;如果y的父结点不是z                TRANSPLANT(T, y, y.right);                y.right &#x3D; z.right;                y.right.p &#x3D; y;        }        TRANSPLANT(T, z, y);        y.left &#x3D; z.left;        y.left.p &#x3D; y;    }}","url":"/2017/06/22/201706/算法导论学习笔记二叉搜索树/","link":"","plink":"http://example.com/2017/06/22/201706/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"算法导论学习笔记--散列表","content":"散列表　　许多应用都要用到一种动态集合结构，它至少要支持 INSERT ， SEARCH 和 DELETE 字典操作。散列表（hash table）就是实现字典的一种有效的数据结构。在最坏情况下，从散列表中查找一个元素的时间与在链表中查找一个元素的时间相同，都是Ｏ( n )，但在实际应用中，散列技术的效率是很高的。在一些合理的假设下，从散列表中查找一个元素的期望时间是 O(1)。散列表是普通数组的推广。因为可以对数组进行直接寻址，故可以在 O ( 1 )时间内访问数组的任意元素。如果存储空间允许，我们可以提供一个数组，为每个可能的关键字保留一个位置，以利用直接寻址技术的优势。当实际存储的关键字数比可能的关键字总数小的时候，采用散列表就比直接数组寻址更加有效，因为散列表通常采用的数组长度与所要存储的关键字数是成正比的。在散列表中，不是直接把关键字用作数组下标，而是根据关键字计算出下标。\n直接寻址表当关键字的全域U比较小时，直接寻址是一种简单而有效的技术。假设某应用用到一个动态集合，其中每一个元素都是取至全域U=｛0，1，……，m-1｝中的一个关键字，这里m不是一个很大的数。假设没有两个关键字相同。我们用一个数组，或者称为直接寻址表。记为T[0…m-1]。其中每一个位置称为槽，对应全域U中的一个关键字。下图说明了这个方法；槽 k 指向集合中关键字为 k 的元素。如果该集合中没有关键字为 k 的元素，则 T [ k ] = NIL 。\n字典的几种操作\n123456789DIRECT-ADDRESS-SEARCH(T,k){    return T[k]}DIRECT-ADDRESS-INSERT(T,x){    T[x.key] &#x3D; x}DIRECT-ADDRESS-DELETE(T,x){    T[x.key] &#x3D; NIL}\n上面的每一个操作都只需O(1)时间。\n散列表直接寻址技术有一个很大的缺点：如果全域U很大，那么在内存中存储大小为|U|的一张表T就有点不实际，甚至是不可能。此外，如果实际要存储的关键字集合K相对于U来说可能很小，那么因而分配给T的大部分空间都要浪费掉。当存储在字典中的关键字集合K比所有可能的关键字域U要小很多时，散列表需要的存储空间要比直接寻址表少很多。特别地，在保持仅需O(1)时间即可在散列表中查找一个元素的好处的情况下，存储要求可以降至Θ(|K|)。问题是这个界是针对平均时间的，而对直接寻址来说，它对最坏情况也成立。在直接寻址方式下，具有关键字k的元素被存放在槽k中。　　 在散列方式下，该元素处于h(k)中，亦即，利用散列函数h，根据关键字k计算出槽的位置。函数h将关键字域U映射到散列表T[0..m-1]的槽位上：  h:U-&gt;{0,1,…,m-1}\n这样做有一个问题：两个关键字可能映射到同一个槽上。这种情形称为碰撞 （collision）。理想的解决方案是完全避免碰撞。可以考虑选用合适的散列函数h。在选择时的一个主导思想，就是使 h 尽可能的“随机”，从而避免或者最小化碰撞。（当然，一个散列函数 h 必须是确定的，即某一给定的输入k应始终产生相同的结果h(k)。）但是，由于 | U | &gt; m ，故必然有两个关键字的散列值相同，所以想要完全避免碰撞时不可能的。\n通过链接法解决冲突链接法是一种最简单的碰撞解决技术。在链接法中，把散列到同一槽中的所有元素都放在一个链表中。如下图所示，槽 j 中有一个指针，它指向由所有散列到 j 的元素构成的链表的头：如果不存在这样的元素，则 j 中为 NIL 。\n\n散列函数####除数散列法在 除数散列法 中，通过取 k 除以 m 的余数，来将关键字 k 映射到 m 个槽的某一个中去。亦即，散列函数为：h ( k ) = k mod m当应用除数散列时，要注意 m 的选择，可选的 m 值通常是与 2 的整数幂不太接近的质数。####乘法散列法乘法散列法 包含两个步骤。第一步，用关键字 k 乘上常数 A （0 &lt; A &lt; 1），并抽取出 k A 的小数部分。第二部，用m乘以这个值，再取结果的底（向下取整）。散列函数为：h ( k ) = FLOOR( m ( k A mod 1 ))乘法方法的一个优点是对 m 的选择没有什么特别的要求，一般选择它为 2 的幂（ m = 2p ， p 为某个整数）。####全域散列任何的散列函数都可能出现最坏情况性态，即 n 个关键字都散列到同一个槽中，使得平均的检索时间为 Θ ( n )：唯一有效的改进方法是随机地选择散列函数，使之独立于要存储的关键字。这种方法称作 全域散列 （universal hashing）。全域散列 的基本思想是在执行开始时，就从一族仔细设计的函数中，随机地选择一个作为散列函数。随机化保证了没有哪一种输入会始终导致最坏情况性态。同时，随机化使得即使是对同一个输入，算法在每一次执行时的性态也是不一样的。这样就可以确保对于任何输入，算法都具有良好的平均情况性态。设 H 为有限的一组散列函数，它将给定的关键字域 U 映射到{ 0， 1， …， m - 1 }。这样的一组函数称为是 全域的 （universal），如果对每一对不同的关键字 k ， l ∈ U ，满足 h ( k ) = h ( l )的散列函数 h ∈ H 的个数至多为 | U | / m 。换言之，如果从 H 中随机选择一个散列函数，当关键字 k ≠ l 时，两个发生碰撞的概率不大于 1 / m ，这也正是从集合{ 0， 1， …， m - 1 }中随机地，独立地选择 h ( k )和 h ( l )时发生碰撞的概率。\n12定理如果 h 选择一组全域的散列函数，并用于将 n 个关键字散列到一个大小为 m 的，用链接法解决碰撞的表 T 中。如果关键字 k 不在表中，则 k 被散列至其中的链表的期望长度E[ nh(k) ]至多为 α 。如果关键字 k 在表中，则包含关键字 k 的链表的期望长度E[ nh(k) ]至多为 1 + α 。\n开放寻址法　　在开放寻址法 （open addressing）中，所有的元素都存放在散列表中。也就是说，每个表项或包含动态集合的一个元素，或包含 NIL 。当查找某个元素时，要检查所有的表项，直到找到所需的元素，或最终发现该元素不在表中。该方法的装载因子 α 绝对不会超过 1 。　　在开放寻址法中，当要插入一个元素时，可以连续地检查散列表的各项，或成为探查，直到找到一个空槽来放置待插入的关键字为止。检查的顺序不一定是 0， 1， …， m - 1 （这种顺序下的查找时间为 Θ ( n )），而是要依赖于待插入的关键字。为了确定要探查哪些槽，应该将散列函数加以扩充，使之包含探查号（从 0 开始）以作为其第二个输入参数。这样，散列函数就变为：\n1h : U ⅹ { 0， 1， …， m - 1 } → { 0， 1， …， m - 1 }\n对每个关键字k，使用开放寻址法的探查序列\n1&lt; h(k，0)，h(k，1)，…，h(k，m-1)&gt;\n必须是&lt; 0，1，…，m-1&gt;的一个排列，使得当散列表逐渐填满时，每一个表位最终都可以被视为用来插入新关键字的槽。下面是插入和查找的伪码。\n123456789101112HASH-INSERT(T, k){      i &#x3D; 0      repeat      j &#x3D; h(k, i)      if T[j] &#x3D;&#x3D; k          T[j] &#x3D;&#x3D; k          return j      else          i &#x3D; i + 1until i &#x3D;&#x3D; merror &quot;hash table overflow&quot;}\n123456789HASH-SEARCH(T, k) i &#x3D; 0 repeat     j &#x3D; h(k, i)     if T[j] &#x3D;&#x3D; k         return j     i &#x3D; i + 1 until T[j] &#x3D;&#x3D; NIL or i &#x3D;&#x3D; m return NIL\n　　在开放寻址法中，对散列表元素的删除操作执行起来比较困难。当我们从槽 i 中删除关键字时，不能仅将 NIL 置于其中来标识它为空。否则就会有个问题：在插入某关键字 k 的探查过程中，发现 i 被占用了，则 k 被插入到后面的位置上。在将槽 i 中的关键字删除后，就无法检索关键字 k 了。解决的办法就是在槽 i 中置一个特定的值 DELETED ，而不用 NIL 。这样要对过程 HASH-INSERT 作相应的修改。当时，当使用特殊值 DELETED 时，查找时间就不再依赖于装载因子 α 了。因此，在必须删除关键字的应用中，往往采用链接法来解决碰撞。　　在实践中，常用三种技术来计算开放寻址法中的探查序列：线性探查，二次探查，以及双重散列。\n线性探查给定一个普通的散列函数 h ‘ : U → { 0，1，…，m-1}（称为 辅助散列函数 ）， 线性探查 （linear probing）方法采用的散列函数为：\n1h(k，i) &#x3D; (h&#39;(k)+i)  mod  m，i&#x3D;0,1，…，m - 1\n二次探查1h(k，i) &#x3D; (h&#39;(k) + c1i + c2 i2 ) mod m\n双重散列双重散列 是用于开放寻址法的最好方法之一，它采用如下形式的散列函数：\n1h(k，i) &#x3D; (h1(k) + i h2 (k) ) mod m","url":"/2017/06/17/201706/算法导论学习笔记散列表/","link":"","plink":"http://example.com/2017/06/17/201706/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%A3%E5%88%97%E8%A1%A8/"},{"title":"Redis高级应用--降低内存占用","content":"降低redis内存占用的优点　　1、有助于减少创建快照和加载快照所用的时间　　2、提升载入AOF文件和重写AOF文件时的效率　　3、缩短从服务器同步时间　　4、无需添加额外的硬件\n短结构　　Redis为列表、集合、散列、有序集合提供了一组配置选项，这些选项可以让Redis以更节约的方式存储较短的结构（简称为：短结构）。　　在列表、散列和有序集合的长度较短或者体积较小的时候，Redis提供一种压缩列表（ziplist）的紧凑存储方式来存储。压缩列表是一种非结构化表（unstructured）示：Redis通常使用双链表表示列表、使用散列表表示散列、散列表加上跳跃表表示有序集合。压缩列表会以序列化的方式存储数据，每次读取压缩列表都会进行解码，每次写入也要进行编码。　　跟列表、散列和有序集合一样，体积较小的集合也有自己的表示方式：如果整数包含的所有成员都能解释为十进制整数，而这些整数又处于平台有的符号整数范围之内，并且集合成员数量又少，那么Redis就会以有序整数数组的方式存储集合，称为整数集合（intset）\n压缩列表　　以简单的列表结构对比压缩列表，了解压缩列表比列表结构更省内存的原因。　　在典型双向列表里面，每个值都都会有一个节点表示。每个节点都会带有指向链表前一个节点和后一个节点的指针，以及一个指向节点包含的字符串值的指针。　　每个节点包含的字符串值都会分为三部分进行存储。包括字符串长度、字符串值中剩余可用字节数量、以空字符结尾的字符串本身。　　在32位的平台下每存储一个字符串至少需要21个字节的额外开销（三个指针+两个int+空字符即：3 x 4 + 2 x 4 +1 = 21）。　　压缩列表是由节点组成的序列，每个节点包含两个长度和一个字符串。第一个长度记录前一个节点的长度（用于对压缩列表从后向前遍历）；第二个长度是记录本当前点的长度；被存储的字符串。\n使用压缩列表1234567891011121314151617181920############################### ADVANCED CONFIG ################################ Hashes are encoded using a memory efficient data structure when they have a# small number of entries, and the biggest entry does not exceed a given# threshold. These thresholds can be configured using the following directives.hash-max-ziplist-entries 512   #表示允许包含的最大元素数量hash-max-ziplist-value 64     #表示压缩节点允许存储的最大体积# Similarly to hashes, small lists are also encoded in a special way in order# to save a lot of space. The special representation is only used when# you are under the following limits:list-max-ziplist-entries 512list-max-ziplist-value 64# Similarly to hashes and lists, sorted sets are also specially encoded in# order to save a lot of space. This encoding is only used when the length and# elements of a sorted set are below the following limits:zset-max-ziplist-entries 128zset-max-ziplist-value 64\n　　列表、散列和有序集合的配置都相似，由max-ziplist-entries和max-ziplist-value组成，entries表示在压缩列表的情况下，所允许包含的最大元素数量。value表示压缩列表中每个结点允许存储的最大体积。当超过任一限制后，将不会使用ziplist方式进行存储。\n1234567891011121314&lt;?php$redis&#x3D;new Redis();$redis-&gt;connect(&#39;192.168.28.131&#39;,&#39;6379&#39;);$stime&#x3D;microtime(true);for ($i&#x3D;0; $i&lt;512; $i++) { \t$redis-&gt;lpush(&#39;test&#39;,$i);   #往test-list推入512条数据}$etime&#x3D;microtime(true); #获取程序执行结束的时间$total&#x3D;$etime-$stime;   #计算差值echo &#39;完成&lt;br&#x2F;&gt;&#39;;echo &quot;&lt;br &#x2F;&gt;&quot;.$total.&quot;times&quot;;?&gt;\n使用代码测试一下，首先使用flushall清空所有数据。然后执行程序，执行玩之后使用debug object test查看信息，使用的是ziplist。然后将上面的循环中的512改成513，上面配置中list-max-ziplist-entries 512。清空数据，再次运行，可以看到程序使用linkedlist方式进行存储。\n\n集合的整数集合编码前提条件是集合中包含的所有member都可以被解析为十进制整数。以有序数组的方式存储集合不仅可以降低内存消耗，还可以提升集合操作的执行速度。\n123456# Sets have a special encoding in just one case: when a set is composed# of just strings that happen to be integers in radix 10 in the range# of 64 bit signed integers.# The following configuration setting sets the limit in the size of the# set in order to use this special memory saving encoding.set-max-intset-entries 512\n1234567891011121314&lt;?php$redis&#x3D;new Redis();$redis-&gt;connect(&#39;192.168.28.131&#39;,&#39;6379&#39;);$stime&#x3D;microtime(true);for ($i&#x3D;0; $i&lt;512; $i++) { \t$redis-&gt;sadd(&#39;test-set&#39;,$i); }$etime&#x3D;microtime(true); #获取程序执行结束的时间$total&#x3D;$etime-$stime;   #计算差值echo &#39;完成&lt;br&#x2F;&gt;&#39;;echo &quot;&lt;br &#x2F;&gt;&quot;.$total.&quot;times&quot;;?&gt;\n\n长压缩列表和大整数集合带来的性能问题　　不管列表、散列、有序集合、集合，当超出限制的条件后，就会转换为更为典型的底层结构类型。因为随着紧凑结构的体积不断变大，操作这些结构的速度将会变得越来越慢。　　在这里我就不实际的测试性能变化了，根据《Redis实战》这本书中的结论，将压缩列表的长度限制在500~2000个元素之内，并将每个元素的体积限制在128字节或以下，压缩表的性能就会处于合理范围内。\n分片结构　　分片的本质就是基于简单的规则将数据划分为更小的部分，然后根据数据所属的部分来决定将数据发送到哪个位置上。很多数据库使用这种技术来扩展存储空间，并提高自己所能处理的负载量。　　结合前面讲到的，我们不难发现分片结构对于redis的重要意义。因此我们需要在配置文件中关于ziplist以及intset的相关配置做出适当的调整。\n分片式散列　　散列分片主要是根据基础键以及散列包含的键计算出分片键ID，然后再与基础键拼接成一个完整的分片键。在执行hset与hget以及大部分hash命令时，都需要先将key（field）通过shardKey方法处理，得到分片键才能够进行下一步操作。\n分片式集合　　如何构造分片式集合才能够让它更节省内存，性能更加强大呢？主要的思路就是，将集合里面的存储的数据尽量在不改变其原有功能的情况下转换成可以被解析为十进制的数据。根据前面所讲到的，当集合中的所有成员都能够被解析为十进制数据时，将会采用intset存储方式，这不仅能够节省内存，而且还可以提高响应的性能。例子：　　假若要某个大型网站需要存储每一天的唯一用户访问量。那么就可以使用将用户的唯一标识符转化成十进制数字，再存入分片式set中。\n学习资料：《redis实战》","url":"/2017/07/07/201707/Redis高级应用降低内存占用/","link":"","plink":"http://example.com/2017/07/07/201707/Redis%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/"},{"title":"二叉树的遍历","content":"二叉树前序遍历12345678&#x2F;*前序遍历非递归实现伪代码*&#x2F;void PreOrder(r){   &#x2F;&#x2F;传入树r    if(r !&#x3D; NULL){     &#x2F;&#x2F;判断是不是NULL，如果是NULL则代表该结点是叶子结点        print  r-&gt;value;        PreOrder(r-&gt;left);        PreOrder(r-&gt;right);     }}\n非递归形式使用栈来辅助，右儿子先进入，左儿子后进入\n12345678910111213void PreOrder(r){    stack s; &#x2F;&#x2F;创建一个栈，用来辅助    s.push(r);    while(! s.empty()){        r &#x3D; s.top();        s.pop();        if(r !&#x3D; NULL){            print  r-&gt;value;            s.push(r-&gt;right);            s.push(r-&gt;left);        }     }}\n二叉树中序遍历非递归形式有左儿子则自己进栈，r=左儿子左儿子访问完，栈顶开始被弹出，访问当前节点，  r=右儿子\n12345678910111213141516void InOrder(r){    stack s;    while(!s.empty() || r !&#x3D; NULL){        while(r !&#x3D; NULL){   &#x2F;&#x2F;首先将所有左儿子遍历完            s.push(r);            r &#x3D; r-&gt;left;        }        if(!s.empty()){            r &#x3D; s.top();               s.pop();          &#x2F;&#x2F;弹出来最后一个左儿子            print r-&gt;value;            r &#x3D; r-&gt;right;        }    }}\n二叉树后序遍历非递归形式\n12345678910111213141516171819202122232425262728293031323334struct StackNode{    TreeNode *r;    bool isFirst;   &#x2F;&#x2F;标识是不是左右孩子都已经输出}void PostOrder2(TreeNode *r){    stack&lt;StackNode&gt; s;    StackNode snode;\t&#x2F;&#x2F;两个判断条件，当s为空时，表示所有元素都遍历完或刚开始还没有将root节点放入。当r为NULL时，表示刚传进来的树是空树或输出该节点后，r赋值为NULL    while(!s.empty() ||  r !&#x3D; NULL){        &#x2F;&#x2F;如果r！&#x3D;NULL,则把新发现的节点放入到栈s中\t        while( r !&#x3D; NULL){            snode.isFirst &#x3D; true;  &#x2F;&#x2F;true表示未输出左右孩子            snode.r &#x3D; r;            s.push(snode);            r &#x3D; r -&gt; left;\t\t &#x2F;&#x2F;先判断当前节点的左节点        }        if(! s.empty()){                      snode &#x3D; s.top();      &#x2F;&#x2F;先获取栈顶元素            s.pop();\t\t\t&#x2F;&#x2F;弹出栈顶元素            if(snode.isFirst){    &#x2F;&#x2F;如果左右孩子都没有输出                snode.isFirst &#x3D; false;&#x2F;&#x2F; false表示已经输出了左孩子                s.push(snode);    &#x2F;&#x2F;将已经遍历过左孩子的节点重新放入栈s中，这时isFirst的值为false。                r &#x3D; snode.r-&gt;right;&#x2F;&#x2F;上面已经遍历完左孩子，这里开始去判断右孩子            }else{     &#x2F;&#x2F;如果已经输出了左孩子                cout &lt;&lt; snode.r-&gt;value &lt;&lt; &quot; &quot;;                r &#x3D; NULL;            }        }    }}","url":"/2017/07/28/201707/二叉树的遍历/","link":"","plink":"http://example.com/2017/07/28/201707/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"title":"AVL树学习笔记","content":"简介AVL树本质上还是一棵二叉搜索树，它的特点是：\n　　1.本身首先是一棵二叉搜索树。\n　　2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。\n　　也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。\n对于AVL树来说，维护高度平衡所需要的代价比获取的收益大，如果在应用场景中，对查找有特殊要求，对插入删除不频繁，AVL树要优于红黑树。\n实现节点12345678910111213141516171819202122typedef int Type;typedef struct AVLTreeNode{    Type key;                   &#x2F;&#x2F;进行排序的关键字    int height;                 &#x2F;&#x2F;高度    struct AVLTreeNode *left;   &#x2F;&#x2F;左孩子    struct AVLTreeNode *right;  &#x2F;&#x2F;右孩子}Node, *AVLTree;static Node* avltree_create_node(Type key,Node *left,Node *rigth){    Node *p;    if((p &#x3D; (Node *)malloc(sizeof(Node))) &#x3D;&#x3D; NULL){        return NULL;    }    P-&gt;key &#x3D; key;    p-&gt;height &#x3D; 0;    p-&gt;left &#x3D; left;    p-&gt;right &#x3D; right;        return p;    }\n树的高度1234567#define HEIGHT(p) ((p&#x3D;&#x3D;NULL)? 0 : (((Node *)(p)) -&gt; height))int avltree_height(AVLTree tree){    return HEIGHT(tree);}\n旋转\n1234567891011121314151617181920#define MAX(a, b)    ( (a) &gt; (b) ? (a) : (b) )&#x2F;* * LL： * * 返回值：旋转后的根节点 *&#x2F;static Node* left_left_rotation(AVLTree k2){    AVLTree k1;    k1 &#x3D; k2-&gt;left;   &#x2F;&#x2F;k1 表示为k2的左孩子    k2-&gt;left &#x3D; k1-&gt;right;    k1-&gt;right &#x3D; k2;    k2-&gt;height &#x3D; MAX( HEIGHT(k2-&gt;left), HEIGHT(k2-&gt;right)) + 1;    k1-&gt;height &#x3D; MAX( HEIGHT(k1-&gt;left), k2-&gt;height) + 1;    return k1;}\n\n123456789101112131415161718&#x2F;* * RR：右右对应的情况(右单旋转)。 * * 返回值：旋转后的根节点 *&#x2F;static Node* right_right_rotation(AVLTree k1){    AVLTree k2;    k2 &#x3D; k1-&gt;right;  &#x2F;&#x2F;k2为k1的右孩子    k1-&gt;right &#x3D; k2-&gt;left;    k2-&gt;left &#x3D; k1;    k1-&gt;height &#x3D; MAX( HEIGHT(k1-&gt;left), HEIGHT(k1-&gt;right)) + 1;    k2-&gt;height &#x3D; MAX( HEIGHT(k2-&gt;right), k1-&gt;height) + 1;    return k2;}\n\n1234567891011&#x2F;* * LR：左右对应的情况(左双旋转)。 * * 返回值：旋转后的根节点 *&#x2F;static Node* left_right_rotation(AVLTree k3){    k3-&gt;left &#x3D; right_right_rotation(k3-&gt;left);    return left_left_rotation(k3);}\n\n1234567891011&#x2F;* * RL：右左对应的情况(右双旋转)。 * * 返回值：旋转后的根节点 *&#x2F;static Node* right_left_rotation(AVLTree k1){    k1-&gt;right &#x3D; left_left_rotation(k1-&gt;right);    return right_right_rotation(k1);}\n插入节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#x2F;*  * 将节点插入到AVL树中，并返回根节点 * * 参数说明： *     tree AVL树的根节点 *     key 插入的结点的键值 * 返回值： *     根节点 *&#x2F;Node* avltree_insert(AVLTree tree, Type key){    if (tree &#x3D;&#x3D; NULL)     {        &#x2F;&#x2F; 新建节点        tree &#x3D; avltree_create_node(key, NULL, NULL);        if (tree&#x3D;&#x3D;NULL)        {            printf(&quot;ERROR: create avltree node failed!\\n&quot;);            return NULL;        }    }    else if (key &lt; tree-&gt;key) &#x2F;&#x2F; 应该将key插入到&quot;tree的左子树&quot;的情况    {        tree-&gt;left &#x3D; avltree_insert(tree-&gt;left, key);        &#x2F;&#x2F; 插入节点后，若AVL树失去平衡，则进行相应的调节。        if (HEIGHT(tree-&gt;left) - HEIGHT(tree-&gt;right) &#x3D;&#x3D; 2)        {            if (key &lt; tree-&gt;left-&gt;key)                tree &#x3D; left_left_rotation(tree);            else                tree &#x3D; left_right_rotation(tree);        }    }    else if (key &gt; tree-&gt;key) &#x2F;&#x2F; 应该将key插入到&quot;tree的右子树&quot;的情况    {        tree-&gt;right &#x3D; avltree_insert(tree-&gt;right, key);        &#x2F;&#x2F; 插入节点后，若AVL树失去平衡，则进行相应的调节。        if (HEIGHT(tree-&gt;right) - HEIGHT(tree-&gt;left) &#x3D;&#x3D; 2)        {            if (key &gt; tree-&gt;right-&gt;key)                tree &#x3D; right_right_rotation(tree);            else                tree &#x3D; right_left_rotation(tree);        }    }    else &#x2F;&#x2F;key &#x3D;&#x3D; tree-&gt;key)    {        printf(&quot;添加失败：不允许添加相同的节点！\\n&quot;);    }    tree-&gt;height &#x3D; MAX( HEIGHT(tree-&gt;left), HEIGHT(tree-&gt;right)) + 1;    return tree;}\n删除节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&#x2F;*  * 删除节点(z)，返回根节点 * * 参数说明： *     ptree AVL树的根结点 *     z 待删除的结点 * 返回值： *     根节点 *&#x2F;static Node* delete_node(AVLTree tree, Node *z){    &#x2F;&#x2F; 根为空 或者 没有要删除的节点，直接返回NULL。    if (tree&#x3D;&#x3D;NULL || z&#x3D;&#x3D;NULL)        return NULL;    if (z-&gt;key &lt; tree-&gt;key)        &#x2F;&#x2F; 待删除的节点在&quot;tree的左子树&quot;中    {        tree-&gt;left &#x3D; delete_node(tree-&gt;left, z);        &#x2F;&#x2F; 删除节点后，若AVL树失去平衡，则进行相应的调节。        if (HEIGHT(tree-&gt;right) - HEIGHT(tree-&gt;left) &#x3D;&#x3D; 2)        {            Node *r &#x3D;  tree-&gt;right;            if (HEIGHT(r-&gt;left) &gt; HEIGHT(r-&gt;right))                tree &#x3D; right_left_rotation(tree);            else                tree &#x3D; right_right_rotation(tree);        }    }    else if (z-&gt;key &gt; tree-&gt;key)&#x2F;&#x2F; 待删除的节点在&quot;tree的右子树&quot;中    {        tree-&gt;right &#x3D; delete_node(tree-&gt;right, z);        &#x2F;&#x2F; 删除节点后，若AVL树失去平衡，则进行相应的调节。        if (HEIGHT(tree-&gt;left) - HEIGHT(tree-&gt;right) &#x3D;&#x3D; 2)        {            Node *l &#x3D;  tree-&gt;left;            if (HEIGHT(l-&gt;right) &gt; HEIGHT(l-&gt;left))                tree &#x3D; left_right_rotation(tree);            else                tree &#x3D; left_left_rotation(tree);        }    }    else    &#x2F;&#x2F; tree是对应要删除的节点。    {        &#x2F;&#x2F; tree的左右孩子都非空        if ((tree-&gt;left) &amp;&amp; (tree-&gt;right))        {            if (HEIGHT(tree-&gt;left) &gt; HEIGHT(tree-&gt;right))            {                &#x2F;&#x2F; 如果tree的左子树比右子树高；                &#x2F;&#x2F; 则(01)找出tree的左子树中的最大节点                &#x2F;&#x2F;   (02)将该最大节点的值赋值给tree。                &#x2F;&#x2F;   (03)删除该最大节点。                &#x2F;&#x2F; 这类似于用&quot;tree的左子树中最大节点&quot;做&quot;tree&quot;的替身；                &#x2F;&#x2F; 采用这种方式的好处是：删除&quot;tree的左子树中最大节点&quot;之后，AVL树仍然是平衡的。                Node *max &#x3D; avltree_maximum(tree-&gt;left);                tree-&gt;key &#x3D; max-&gt;key;                tree-&gt;left &#x3D; delete_node(tree-&gt;left, max);            }            else            {                &#x2F;&#x2F; 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)                &#x2F;&#x2F; 则(01)找出tree的右子树中的最小节点                &#x2F;&#x2F;   (02)将该最小节点的值赋值给tree。                &#x2F;&#x2F;   (03)删除该最小节点。                &#x2F;&#x2F; 这类似于用&quot;tree的右子树中最小节点&quot;做&quot;tree&quot;的替身；                &#x2F;&#x2F; 采用这种方式的好处是：删除&quot;tree的右子树中最小节点&quot;之后，AVL树仍然是平衡的。                Node *min &#x3D; avltree_maximum(tree-&gt;right);                tree-&gt;key &#x3D; min-&gt;key;                tree-&gt;right &#x3D; delete_node(tree-&gt;right, min);            }        }        else        {            Node *tmp &#x3D; tree;            tree &#x3D; tree-&gt;left ? tree-&gt;left : tree-&gt;right;            free(tmp);        }    }    return tree;}&#x2F;*  * 删除结点(key是节点值)，返回根节点 * * 参数说明： *     tree AVL树的根结点 *     key 待删除的结点的键值 * 返回值： *     根节点 *&#x2F;Node* avltree_delete(AVLTree tree, Type key){    Node *z;     if ((z &#x3D; avltree_search(tree, key)) !&#x3D; NULL)        tree &#x3D; delete_node(tree, z);    return tree;}\n学习资料-AVL树(一)之 图文解析 和 C语言的实现","url":"/2017/08/04/201708/AVL树学习笔记/","link":"","plink":"http://example.com/2017/08/04/201708/AVL%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Java NIO学习笔记","content":"Java NIO介绍Java传统IO是基于流，而NIO是基于Block，也就是NIO的操作在正常情况下是以相对较大的Block为单位，而不是针对字节或者是字符。NIO和传统IO相比：\n123IO 基于流(Stream oriented), 而 NIO 基于 Buffer (Buffer oriented)IO 操作是阻塞的, 而 NIO 操作是非阻塞的IO 没有 selector 概念, 而 NIO 有 selector 概念.\nNIO其他功能：\n1234多路选择的非封锁式I&#x2F;O设施支持文件锁和内存映射支持正则表达式的模式匹配设施字符集编码器和译码器\nJava NIO 缓存区　　标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Java NIO里关键的Buffer实现:\n1234567ByteBufferCharBufferDoubleBufferFloatBufferIntBufferLongBufferShortBuffer\n123456789101112131415161718192021\tpublic static void main(String[] args) {\t\tIntBuffer buffer  &#x3D; IntBuffer.allocate(100);&#x2F;&#x2F;开辟容量为100大小的IntBuffer\t\tSystem.out.println(&quot;Position：&quot;+ buffer.position() + &quot;， Limit：&quot;+ buffer.limit() + &quot;， Capacity:&quot;+buffer.capacity());\t\t&#x2F;*while(buffer.hasRemaining()){\t\t\tSystem.out.println(buffer.get());\t\t}*&#x2F;\t\tint[] data &#x3D; {10,9,8,7,6,5,4,3,2,1};\t\tbuffer.put(data);\t\tSystem.out.println(&quot;Position：&quot;+ buffer.position() + &quot;， Limit：&quot;+ buffer.limit() + &quot;， Capacity:&quot;+buffer.capacity());\t\tbuffer.put(100);\t\tSystem.out.println(&quot;Position：&quot;+ buffer.position() + &quot;， Limit：&quot;+ buffer.limit() + &quot;， Capacity:&quot;+buffer.capacity());\t\tbuffer.flip();   &#x2F;&#x2F;重设缓冲区\t\tSystem.out.println(&quot;Position：&quot;+ buffer.position() + &quot;， Limit：&quot;+ buffer.limit() + &quot;， Capacity:&quot;+buffer.capacity());\t}&#x2F;*输出结果是：Position：0， Limit：100， Capacity:100Position：10， Limit：100， Capacity:100Position：11， Limit：100， Capacity:100Position：0， Limit：11， Capacity:100*&#x2F;\n123Position：表示下一个缓存区读取或者写入的操作指针Limit：在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）Capacity：表示缓冲区的最大容量\nByteBuffer提供了两种静态实例(开辟空间)方式：\n12public static ByteBuffer allocate(int capacity)  public static ByteBuffer allocateDirect(int capacity) \n　　　　第一种分配方式产生的内存开销是在JVM中的，而第二种的分配方式产生的开销在JVM之外，以就是系统级的内存分配。当Java程序接收到外部传来的数据时，首先是被系统内存所获取，然后在由系统内存复制拷贝到JVM内存中供Java程序使用。所以在第二种分配方式中，可以省去复制这一步操作，效率上会有所提高。但是系统级内存的分配比起JVM内存的分配要耗时得多，所以并不是任何时候allocateDirect的操作效率都是最高的。\n通道(Channel)与内存映射121，  Channel是基于缓存区来读取和写入数据的；2，  Channel说双向的，既可以完成输入也可以完成输出；\n下面是JAVA NIO中的一些主要Channel的实现：\n1234FileChannel从文件中读写数据。DatagramChannel以UDP的形式从网络中读写数据。SocketChannel以TCP的形式从网络中读写数据。ServerSocketChannel允许你监听TCP连接。\n将buffer中的数据读出来\n12345678910111213141516171819202122232425262728293031323334&#x2F;** * 将buffer中的数据读出来 * @param args *&#x2F;public static void main(String[] args) {\tFileOutputStream fileOutputStream &#x3D; null;\tFileChannel fileChannel &#x3D; null;\tString[] data &#x3D; {&quot;Scala&quot;,&quot;spark&quot;,&quot;Java&quot;,&quot;Hadoop&quot;};\t\tFile file &#x3D; new File(&quot;F:\\\\javaio\\\\nio.txt&quot;);\ttry {\t\tfileOutputStream &#x3D; new FileOutputStream(file);\t\tfileChannel &#x3D; fileOutputStream.getChannel();\t\t\t} catch (FileNotFoundException e) {\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\te.printStackTrace();\t}               &#x2F;&#x2F;为Buffer初始化数据\tByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\tfor (String item : data) {\t\tbuffer.put(item.getBytes());\t}\tbuffer.flip();\t&#x2F;&#x2F;将buffer中的数据读出来，并写入到文件中\ttry {\t\tfileChannel.write(buffer);\t\tfileChannel.close();\t\tfileOutputStream.close();\t} catch (IOException e) {\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\te.printStackTrace();\t}}\nScatter / Gather可以同时将多个buffer中的数据放入到一个数组后然后统一放入到channel后传递给服务器：\n123456789ByteBuffer buffer1 &#x3D; ByteBuffer.allocate(128);ByteBuffer buffer2 &#x3D; ByteBuffer.allocate(16);buffer1.put(&quot;hello &quot;.getBytes());buffer2.put(&quot;world&quot;.getBytes());buffer1.flip();buffer2.flip();ByteBuffer[] bufferArray &#x3D; {buffer1, buffer2};socketChannel.write(bufferArray);\nSelector　　Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道）,省去了创建线程以及线程之间进行上下文切换的开销。每个连接的流量都很低，使用Selector就会很方便。通过调用selector类的静态方法open我们就可以创建一个selector对象：\n1Selector selector &#x3D; Selector.open();\n为了保证selector能够监听多个channel，我们需要将channel注册到selector当中：\n12channel.configureBlocking(false);SelectionKey key &#x3D; channel.register(selector, SelectionKey.OP_READ);\n我们可以监听四种事件：\n1234SelectionKey.OP_CONNECT：当客户端的尝试连接到服务器SelectionKey.OP_ACCEPT：当服务器接受来自客户端的请求SelectionKey.OP_READ：当服务器可以从channel中读取数据SelectionKey.OP_WRITE：当服务器可以向channel中写入数据\n对SelectorKey调用channel方法可以得到key对应的channel:\n1Channel channel &#x3D; key.channel();\n而key自身感兴趣的监听事件也可以通过interestOps来获得：\n1int interestSet &#x3D; selectionKey.interestOps();\n对selector调用selectedKeys()方法我们可以得到注册的所有key：\n1Set&lt;SelectionKey&gt; selectedKeys &#x3D; selector.selectedKeys();\n学习资料：[1] 并发编程网 – ifeve.comJava NIO 系列教程[2] Java并发编程之NIO简明教程[3] ByteBuffer的allocate和allocateDirect","url":"/2017/08/23/201708/JavaNIO学习笔记/","link":"","plink":"http://example.com/2017/08/23/201708/JavaNIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Java 事务处理","content":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.sql.Connection;import java.sql.ResultSet;import java.sql.DriverManager;import java.sql.SQLException;import com.mysql.jdbc.Statement;public class JDBCTest {\t&#x2F;**\t * 创建数据库连接\t * @return\t *&#x2F;\tpublic static Connection getConnection(){\t\tConnection connection &#x3D; null;\t\ttry {\t\t\tClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\t\t\tconnection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;,&quot;root&quot;,&quot;&quot;);  &#x2F;&#x2F;连接数据库\t\t} catch (ClassNotFoundException | SQLException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t}  &#x2F;&#x2F;注册驱动程序\t\treturn connection;\t\t\t\t\t}\tpublic static void insertUserData(Connection connection) throws SQLException{\t\t\t\tString sql &#x3D; &quot;INSERT INTO &#96;t_user&#96;(&#96;id&#96;, &#96;name&#96;, &#96;pass&#96;) VALUES (2,&#39;gavin&#39;,&#39;123456&#39;)&quot;;\t\tStatement statement &#x3D; (Statement) connection.createStatement();\t\tint count &#x3D; statement.executeUpdate(sql);\t\tSystem.out.println(&quot;向用户表插入了&quot; + count +&quot;条信息！&quot;);\t}\tpublic static void insertAddressData(Connection connection) throws SQLException{\t\t\t\tString sql &#x3D; &quot;INSERT INTO &#96;t_address&#96;(&#96;id&#96;, &#96;city&#96;, &#96;country&#96;, &#96;user_id&#96;) VALUES (1,&#39;jining&#39;,&#39;qvfu&#39;,1)&quot;;\t\tStatement statement &#x3D; (Statement) connection.createStatement();\t\tint count &#x3D; statement.executeUpdate(sql);\t\tSystem.out.println(&quot;向地址表插入了&quot; + count +&quot;条信息！&quot;);\t\t\t\t}\t\t\t\t\tpublic static void main(String[] args) {\t\tConnection connection &#x3D; null;\t\t\t\ttry {\t\t\tconnection &#x3D; getConnection();\t\t\t&#x2F;**\t\t\t * setAutoCommit(false);\t\t\t * true：sql命令的提交（commit）由驱动程序负责\t\t\t * false：sql命令的提交由应用程序负责，程序必须调用commit或者rollback方法\t\t\t *&#x2F;\t\t\tconnection.setAutoCommit(false);\t\t\tinsertUserData(connection);\t\t\tinsertAddressData(connection);\t\t\t\t\t\tconnection.commit();\t\t\t\t\t} catch (SQLException e) {\t\t\tSystem.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;捕获到sql异常&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\t\t\ttry {\t\t\t\tconnection.rollback();    &#x2F;&#x2F;回滚\t\t\t\tSystem.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;数据回滚成功&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\t\t\t} catch (SQLException e1) {\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\te1.printStackTrace();\t\t\t}\t\t}finally{\t\t\ttry {\t\t\t\tif(connection !&#x3D; null){\t\t\t\t\tconnection.close();\t\t\t\t}\t\t\t} catch (Exception e2) {\t\t\t\t&#x2F;&#x2F; TODO: handle exception\t\t\t}\t\t}\t\t\t}}","url":"/2017/08/30/201708/Java事务处理/","link":"","plink":"http://example.com/2017/08/30/201708/Java%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"},{"title":"Java基础之I/O","content":"I/O介绍核心类\n\n\n类\n说明\n\n\n\nFile\n文件类\n\n\nInputStream\n字节输入流\n\n\nOutputStream\n字节输出流\n\n\nReader\n字符输入流\n\n\nWriter\n字符输出流\n\n\nCloseable\n关闭流接口\n\n\nFlushable\n刷新流接口\n\n\nSerializable\n序列化接口\n\n\nFile文件路径12String path &#x3D; &quot;E:&#x2F;JavaProgarm&#x2F;JavaStudy&#x2F;src&#x2F;20181231110532.jpg&quot;; &#x2F;&#x2F;最好使用&quot;&#x2F;&quot;,因为Java是跨平台，windows中可以使用\\和&#x2F;，但是linux和unix中用&#x2F;path &#x3D; &quot;E:&quot; + File.separator + &quot;JavaProgarm&quot; + File.separator + &quot;JavaStudy&quot; + File.separator + &quot;src&quot; + File.separator + &quot;20181231110532.jpg&quot;;&#x2F;&#x2F;或者用 File.separator\n重要的API\n\n\nAPI\n说明\n\n\n\npathSeparator   separator\n路径 / 路径分隔符\n\n\nFile(String parent,String child)  File(File parent,String child)  File(String name)\n构造器 没有盘符以user.id作为相对目录\n\n\ngetName()getPath()//构建的时候是相对路径，返回相对路径；构建的时候是绝对路径，返回绝对路径getAbsolutePath()//绝对路径getParent()//返回父路径\n文件名、路径名\n\n\nexists() isFile()isDrectory()\n判断状态\n\n\nlength()\n文件长度(如果是文件夹或者不存在路径，则长度为0)\n\n\ncreateNewFile()delete()\n创建新文件 删除文件\n\n\nmkdir() mkdirs()\n创建目录，父路径不存在则失败创建目录，父路径不存在直接创建父路径\n\n\nlist()\n下级名称 （返回值是：String[]）\n\n\nlistFiles()\n下级File（返回值是：File[]）\n\n\nlistRoots()\n根路径(返回值是:File[] ),也就是盘符\n\n\n文件编码\n\n\n编码\n一个汉字字符占几个字节\n\n\n\nASCII码\n2\n\n\nUTF-8编码\n3\n\n\nUnicode编码\n2\n\n\n字符–&gt; 字节  编码字节–&gt; 字符  解码\n123456String msg &#x3D; &quot;你好&quot;;byte[] datas &#x3D; msg.getBytes();   &#x2F;&#x2F;字符转字节数组  编码System.out.println(datas.length);  &#x2F;&#x2F;长度取决于项目默认的编码String str &#x3D; new String(datas);  &#x2F;&#x2F;字节转字符  解码System.out.println(str);\n流四个抽象类\n\n\n抽象类\n说明\n常用方法\n\n\n\nInputStream\n字节输入流的父类，数据单位为字节\nint read()void close()\n\n\nOutputStream\n字节输出流的父类，数据单位为字节\nvoid write(int)void flush() void close()\n\n\nReader\n字符输入流的父类，数据单位为字符\nint read() void close()\n\n\nWriter\n字符输出流的父类，数据单位为字符\nvoid write(String)void flush() void close()\n\n\n使用步骤创建源 –&gt; 选择流 –&gt; 操作（读写）–&gt;释放资源\n\n字节流字节输入流的抽象基类是InputStream，常用的子类是 FileInputStream和BufferedInputStream。\nFileInputStream &amp; FileOutputStream12FileInputStream---&gt;具体实现了在文件上读取数据FileOutputStream 实现了向文件中写出byte数据的方法\n1、输入流基本方法\n123int  b &#x3D; in.read();读取一个字节无符号填充到int低八位.-1是 EOFin.read(byte[] buf) in.read(byte[] buf,int start,int size)\n2、输出流基本方法\n123out.write(int b)  写出一个byte到流，b的低8位out.write(byte[] buf)将buf字节数组都写入到流out.write(byte[] buf,int start,int size)\n3、DataOutputStream/DataInputStream 对”流”功能的扩展，可以更加方面的读取int,long，字符等类型数据\n12DataOutputStream     writeInt()&#x2F;writeDouble()&#x2F;writeUTF()\n4、例子（简单读取字节）\n1234567891011   &#x2F;&#x2F;创建源   File f &#x3D; new File(&quot;abc.txt&quot;);   &#x2F;&#x2F;选用合适的流InputStream in &#x3D; new FileInputStream(f);int temp;&#x2F;&#x2F;操作while ((temp &#x3D; in.read())!&#x3D; -1){\tSystem.out.print((char)temp);}&#x2F;&#x2F;释放资源in.close();\n例子2（批量读取）\n123456789   File f &#x3D; new File(&quot;abc.txt&quot;);InputStream in &#x3D; new FileInputStream(f);byte[] url &#x3D; new byte[3]; &#x2F;&#x2F;设置大小为3的容器int len &#x3D; -1;while ((len &#x3D; in.read(url))!&#x3D; -1){\t&#x2F;&#x2F;字节数组转字符\tString str &#x3D; new String(url,0,len);\tSystem.out.println(str);in.close();\n例子3（保存数据到文件）\n123456   OutputStream os &#x3D; new FileOutputStream(f);String msg &#x3D; &quot;hahahahhah&quot;;byte[] datas &#x3D; msg.getBytes();os.write(datas);os.flush();  &#x2F;&#x2F;os关闭的时候也会将数据刷新到文件中去os.close();\nBufferedInputStream &amp; BufferedOutputStream BufferedInputStream&amp;BufferedOutputStream BufferedInputStream 内部有一个缓冲区，默认大小为8M，每次调用read方法的时候，它首先尝试从缓冲区里读取数据，若读取失败或者取不到数据，则选择从文件中读取新数据放入到缓冲区中，最后再将缓冲区中的内容返回给用户.由于从缓冲区里读取数据远比直接从存储介质读取速度快，所以BufferedInputStream的效率很高。 这两个流类位IO提供了带缓冲区的操作，一般打开文件进行写入或读取操作时，都会加上缓冲，这种流模式提高了IO的性能\n文件拷贝：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#x2F;** * 文件拷贝，字节批量读取(最快的方式) * @param srcFile * @param destFile * @throws IOException *&#x2F;public static void copyFile(File srcFile,File destFile)throws IOException{\tif(!srcFile.exists()){\t\tthrow new IllegalArgumentException(&quot;文件:&quot;+srcFile+&quot;不存在&quot;);\t}\tif(!srcFile.isFile()){\t\tthrow new IllegalArgumentException(srcFile+&quot;不是文件&quot;);\t}\tFileInputStream in &#x3D; new FileInputStream(srcFile);\tFileOutputStream out &#x3D; new FileOutputStream(destFile);\tbyte[] buf &#x3D; new byte[50*1024];\tint b ;    while((b &#x3D; in.read(buf,0,buf.length))!&#x3D;-1){    \tout.write(buf,0,b);    \tout.flush();&#x2F;&#x2F;最好加上    }    in.close();    out.close();\t}&#x2F;** * 进行文件的拷贝，利用带缓冲的字节流（比单字节不带缓冲的进行文件拷贝快） * @param srcFile * @param destFile * @throws IOException *&#x2F;public static void copyFileByBuffer(File srcFile,File destFile)throws IOException{\tif(!srcFile.exists()){\t\tthrow new IllegalArgumentException(&quot;文件:&quot;+srcFile+&quot;不存在&quot;);\t}\tif(!srcFile.isFile()){\t\tthrow new IllegalArgumentException(srcFile+&quot;不是文件&quot;);\t}\tBufferedInputStream bis &#x3D; new BufferedInputStream(\t\t\tnew FileInputStream(srcFile));\tBufferedOutputStream bos &#x3D; new BufferedOutputStream(\t\t\tnew FileOutputStream(destFile));\tint c ;\twhile((c &#x3D; bis.read())!&#x3D;-1){\t\tbos.write(c);\t\tbos.flush();&#x2F;&#x2F;刷新缓冲区\t}\tbis.close();\tbos.close();}&#x2F;** * 单字节，不带缓冲进行文件拷贝（最慢） * @param srcFile * @param destFile * @throws IOException *&#x2F;public static void copyFileByByte(File srcFile,File destFile)throws IOException{\tif(!srcFile.exists()){\t\tthrow new IllegalArgumentException(&quot;文件:&quot;+srcFile+&quot;不存在&quot;);\t}\tif(!srcFile.isFile()){\t\tthrow new IllegalArgumentException(srcFile+&quot;不是文件&quot;);\t}\tFileInputStream in &#x3D; new FileInputStream(srcFile);\tFileOutputStream out &#x3D; new FileOutputStream(destFile);\tint c ;\twhile((c &#x3D; in.read())!&#x3D;-1){\t\tout.write(c);\t\tout.flush();\t}\tin.close();\tout.close();}\n 测试函数：\n12345678910111213141516public static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\ttry {\t\t\tlong start &#x3D; System.currentTimeMillis();\t\t\tIOUtil.copyFileByByte(new File(&quot;f:\\\\javaio\\\\1.mp3&quot;), new File(\t\t\t\t\t&quot;f:\\\\javaio\\\\2.mp3&quot;));  &#x2F;&#x2F;两万多毫秒\t\t\tIOUtil.copyFileByBuffer(new File(&quot;f:\\\\javaio\\\\1.mp3&quot;), new File(\t\t\t\t\t&quot;f:\\\\javaio\\\\3.mp3&quot;));&#x2F;&#x2F;一万多毫秒\t\t\tIOUtil.copyFile(new File(&quot;f:\\\\javaio\\\\1.mp3&quot;), new File(\t\t\t\t\t&quot;f:\\\\javaio\\\\4.mp3&quot;));&#x2F;&#x2F;7毫秒\t\t\tlong end &#x3D; System.currentTimeMillis();\t\t\tSystem.out.println(end - start );\t\t} catch (IOException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t}\n字符流按照字符读取数据，Java提供了Reader、Writer两个专门操作字符流的类。字符流操作的是文本文本文件，就是我们看到的汉字和英文等Unicode字符，在实际操作中，如果是音频文件、图片和视频等文件用字节流，如果是汉字可以用字符流。\nInputStreamReader &amp; OutputStreamWriter字符流的基本实现\n12InputStreamReader   完成byte流解析为char流,按照编码解析OutputStreamWriter  提供char流到byte流，按照编码处理  \n12345678910111213141516171819202122232425public static void main(String[] args)throws IOException {\tFileInputStream in &#x3D; new FileInputStream(&quot;e:\\\\javaio\\\\haha.txt&quot;);\tInputStreamReader isr &#x3D; new InputStreamReader(in,&quot;utf-8&quot;);&#x2F;&#x2F;默认项目的编码,操作的时候，要写文件本身的编码格式\tFileOutputStream out &#x3D; new FileOutputStream(&quot;e:\\\\javaio\\\\haha1.txt&quot;);\tOutputStreamWriter osw &#x3D; new OutputStreamWriter(out,&quot;utf-8&quot;);\t&#x2F;*int c ;\twhile((c &#x3D; isr.read())!&#x3D;-1){\t\tSystem.out.print((char)c);\t}*&#x2F;\tchar[] buffer &#x3D; new char[8*1024];\tint c;\t&#x2F;*批量读取，放入buffer这个字符数组，从第0个位置开始放置，最多放buffer.length个\t  返回的是读到的字符的个数\t*&#x2F;\twhile(( c &#x3D; isr.read(buffer,0,buffer.length))!&#x3D;-1){\t\tString s &#x3D; new String(buffer,0,c);\t\tSystem.out.print(s);\t\tosw.write(buffer,0,c);\t\tosw.flush();\t}\tisr.close();\tosw.close();\t}\nFileReader &amp; FileWriter12345678910111213public static void main(String[] args) throws IOException{\t\tFileReader fr &#x3D; new FileReader(&quot;e:\\\\javaio\\\\haha.txt&quot;);\t\tFileWriter fw &#x3D; new FileWriter(&quot;e:\\\\javaio\\\\haha2.txt&quot;);\t\t&#x2F;&#x2F;FileWriter fw &#x3D; new FileWriter(&quot;e:\\\\javaio\\\\haha2.txt&quot;,true);&#x2F;&#x2F;是否为追加数据才\t\tchar[] buffer &#x3D; new char[2056];\t\tint c ;\t\twhile((c &#x3D; fr.read(buffer,0,buffer.length))!&#x3D;-1){\t\t\tfw.write(buffer,0,c);\t\t\tfw.flush();\t\t}\t\tfr.close();\t\tfw.close();\t}\n字符流的过滤器12BufferedReader   ----&gt;readLine 一次读一行BufferedWriter&#x2F;PrintWriter   ----&gt;写一行    \n123456789101112131415161718192021222324public static void main(String[] args) throws IOException{\t\t &#x2F;&#x2F;对文件进行读写操作 \t\tBufferedReader br &#x3D; new BufferedReader(\t\t\t\tnew InputStreamReader(\t\t\t\t\t\tnew FileInputStream(&quot;e:\\\\javaio\\\\haha.txt&quot;)));\t\t&#x2F;*BufferedWriter bw &#x3D; new BufferedWriter(\t\t\t\tnew OutputStreamWriter(\t\t\t\t\t\tnew FileOutputStream(&quot;e:\\\\javaio\\\\haha3.txt&quot;)));*&#x2F;\t\tPrintWriter pw &#x3D; new PrintWriter(&quot;e:\\\\javaio\\\\haha4.txt&quot;);\t\t&#x2F;&#x2F;PrintWriter pw1 &#x3D; new PrintWriter(outputStream,boolean autoFlush);\t\tString line ;\t\twhile((line &#x3D; br.readLine())!&#x3D;null){\t\t\tSystem.out.println(line);&#x2F;&#x2F;一次读一行，并不能识别换行\t\t\t&#x2F;*bw.write(line);\t\t\t&#x2F;&#x2F;单独写出换行操作\t\t\tbw.newLine();&#x2F;&#x2F;换行操作\t\t\tbw.flush();*&#x2F;\t\t\tpw.println(line);\t\t\tpw.flush();\t\t}\t\tbr.close();\t\t&#x2F;&#x2F;bw.close();\t\tpw.close();\t}\nRandomAccessFileRandomAccessFile java提供的对文件内容的访问，既可以读文件，也可以写文件。RandomAccessFile支持随机访问文件，可以访问文件的任意位置。使用RandomAccessFile类，可以实现零内存追加数据，其实这就是支持任意位置读写类的强大之处。如果我们只希望访问文件的部分内容，而不是把文件从头读到尾，使用RandomAccessFile将会带来更简洁的代码以及更好的性能。两个重要的方法：\n12getFilePointer()\t返回文件记录指针的当前位置seek(long pos)\t将文件记录指针定位到pos的位置\n(1)java文件模型　　在硬盘上的文件是byte byte byte存储的,是数据的集合(2)打开文件　　有两种模式”rw”(读写)  “r”（只读)　　RandomAccessFile raf = new RandomeAccessFile(file,”rw”)　　文件指针，打开文件时指针在开头 pointer = 0;(3) 写方法 　　raf.write(int)—&gt;只写一个字节（后8位),同时指针指向下一个位置，准备再次写入(4)读方法　　int b = raf.read()—&gt;读一个字节(5)文件读写完成以后一定要关闭  \n123456789101112131415161718192021222324252627282930313233343536373839404142File demo &#x3D; new File(&quot;demo&quot;);if(!demo.exists())\tdemo.mkdir();File file &#x3D; new File(demo,&quot;raf.dat&quot;);if(!file.exists())\tfile.createNewFile();RandomAccessFile raf &#x3D; new RandomAccessFile(file, &quot;rw&quot;);&#x2F;&#x2F;指针的位置System.out.println(raf.getFilePointer());raf.write(&#39;A&#39;);&#x2F;&#x2F;只写了一个字节System.out.println(raf.getFilePointer());raf.write(&#39;B&#39;);int i &#x3D; 0x7fffffff;&#x2F;&#x2F;用write方法每次只能写一个字节，如果要把i写进去就得写4次raf.write(i &gt;&gt;&gt; 24);&#x2F;&#x2F;高8位raf.write(i &gt;&gt;&gt; 16);raf.write(i &gt;&gt;&gt; 8);raf.write(i);System.out.println(raf.getFilePointer());&#x2F;&#x2F;可以直接写一个intraf.writeInt(i);String s &#x3D; &quot;中&quot;;byte[] gbk &#x3D; s.getBytes(&quot;gbk&quot;);raf.write(gbk);System.out.println(raf.length());&#x2F;&#x2F;读文件，必须把指针移到头部raf.seek(0);&#x2F;&#x2F;一次性读取,把文件中的内容都读到字节数组中byte[] buf &#x3D; new byte[(int)raf.length()];raf.read(buf);System.out.println(Arrays.toString(buf));for (byte b : buf) {\tSystem.out.println(Integer.toHexString(b &amp; 0xff)+&quot; &quot;);}raf.close();","url":"/2017/08/19/201708/Java基础之IO/","link":"","plink":"http://example.com/2017/08/19/201708/Java%E5%9F%BA%E7%A1%80%E4%B9%8BIO/"},{"title":"Java网络编程笔记之HTTP模拟请求（七）","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package creatHTTP;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.net.InetSocketAddress;import java.net.Socket;public class HttpSimulator {\t\tprivate Socket socket;\tprivate int port &#x3D; 80;\tprivate String host &#x3D; &quot;localhost&quot;;\tprivate String request &#x3D; &quot;&quot;;\tprivate boolean isPort,isHead;\t\tpublic void run()throws Exception{\t\tBufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in));\t\twhile(true){\t\t\tif(!readHostAndPort(reader)){  &#x2F;&#x2F;从控制台读取域名和端口号\t\t\t\tbreak;\t\t\t}\t\t\treadHeadRequest(reader);&#x2F;&#x2F;从控制台读取HTTP请求消息\t\t\tsendHttpRequest();&#x2F;&#x2F;向服务器发送HTTP请求消息\t\t\treadHeadResponse(reader);&#x2F;&#x2F;读取服务器回送的HTTP响应消息。\t\t}\t}\t\tpublic static void main(String[] args) throws Exception {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tnew HttpSimulator().run();\t}\t\t&#x2F;**\t * \t * 从控制台读取数据,输入q退出程序\t *&#x2F;\tprivate boolean readHostAndPort(BufferedReader reader)throws Exception {\t\tSystem.out.println(&quot;host:port&gt;&quot;);\t\tString[] ss &#x3D; null;\t\tString s &#x3D; reader.readLine();&#x2F;&#x2F;从控制台读取一行字符串\t\tif(s.equals(&quot;q&quot;)){   &#x2F;&#x2F;退出程序\t\t\treturn false;\t\t}else{\t\t\tss &#x3D; s.split(&quot;[:]&quot;);&#x2F;&#x2F;将域名和端口分开\t\t\tif(!ss[0].equals(&quot;&quot;)){\t\t\t\thost &#x3D; ss[0];\t\t\t}\t\t\tif(ss.length &gt; 1){\t\t\t\tport &#x3D; Integer.parseInt(ss[1]);\t\t\t}\t\t\tSystem.out.println(host+&quot;:&quot;+String.valueOf(port));\t\t}\t\t\t\treturn true;\t}\t&#x2F;**\t *   从控制台读取HTTP请求消息\t *&#x2F;\tprivate void readHeadRequest(BufferedReader reader) throws Exception{\t\tSystem.out.println(&quot;请输入HTTP请求：&quot;);\t\tString s &#x3D; reader.readLine(); &#x2F;&#x2F;读取行\t\trequest &#x3D; s + &quot;\\r\\n&quot;;\t\tboolean isPort &#x3D; s.substring(0, 4).equals(&quot;POST&quot;);\t\tboolean isHead &#x3D; s.substring(0, 4).equals(&quot;HEAD&quot;);\t\twhile(!(s &#x3D; reader.readLine()).equals(&quot;&quot;)){\t\t\trequest &#x3D; request + s + &quot;\\r\\n&quot;;\t\t}\t\trequest &#x3D; request + &quot;\\r\\n&quot;;   &#x2F;&#x2F;跳出循环\t\tif(isPort){\t\t\tSystem.out.println(&quot;请输入POST方法的内容：&quot;);\t\t\ts &#x3D; reader.readLine();\t\t\trequest &#x3D; request + s;\t\t}\t}\t&#x2F;**\t * 读取数据\t * @param reader\t *&#x2F;\tprivate void readHeadResponse(BufferedReader reader) {\t\tString s &#x3D; &quot;&quot;;\t\ttry {\t\t\tInputStream in &#x3D; socket.getInputStream();\t\t\tInputStreamReader inReader &#x3D; new InputStreamReader(in);\t\t\tBufferedReader socketReader &#x3D; new BufferedReader(inReader);\t\t\tSystem.out.println(&quot;----------HTTP头----------&quot;);\t\t\tboolean b &#x3D; true;\t\t\twhile((s &#x3D; socketReader.readLine()) !&#x3D; null){\t\t\t\tif(s.equals(&quot;&quot;) &amp;&amp; b &#x3D;&#x3D; true &amp;&amp; !isHead){\t\t\t\t\tSystem.out.println(&quot;------------------&quot;);\t\t\t\t\tb &#x3D; false;\t\t\t\t\tSystem.out.println(&quot;是否显示HTTP的内容（Y&#x2F;N）:&quot;);\t\t\t\t\tString choice &#x3D; reader.readLine();\t\t\t\t\tif(choice.equals(&quot;Y&quot;)|| choice.equals(&quot;y&quot;)){\t\t\t\t\t\tSystem.out.println(&quot;----------HTTP内容----------&quot;);\t\t\t\t\t\tcontinue;\t\t\t\t\t}else{\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t}else{\t\t\t\t\tSystem.out.println(s);\t\t\t\t}\t\t\t}\t\t} catch (IOException e) {\t\t\tSystem.out.println(&quot;error:&quot;+e.getMessage());\t\t}finally{\t\t\ttry {\t\t\t\tsocket.close();\t\t\t} catch (IOException e) {\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t}\t\t}\t\t\t\tSystem.out.println(&quot;-----------------&quot;);\t\t\t}&#x2F;** *  发送数据 *  *  *&#x2F;\tprivate void sendHttpRequest() throws Exception{\t\tsocket &#x3D; new Socket();\t\tsocket.setSoTimeout(10 * 1000);&#x2F;&#x2F;设置超时时间为10秒\t\tSystem.out.println(&quot;正在连接服务器..&quot;);\t\tsocket.connect(new InetSocketAddress(host, port), 10*1000);\t\tSystem.out.println(&quot;连接服务器成功！&quot;);\t\tOutputStream out &#x3D; socket.getOutputStream();\t\tOutputStreamWriter write &#x3D; new OutputStreamWriter(out);\t\twrite.write(request);\t\twrite.flush();\t}}\n12345678910111213141516171819host:port&gt;www.xxxxx.comwww.xxxxx.com:80请输入HTTP请求：GET &#x2F; HTTP&#x2F;1.1Host:www.xxxxx.com正在连接服务器..连接服务器成功！----------HTTP头----------HTTP&#x2F;1.1 200 OKServer: nginx&#x2F;1.12.0Content-Type: text&#x2F;html; charset&#x3D;UTF-8Transfer-Encoding: chunkedConnection: keep-aliveCache-Control: no-cacheDate: Thu, 10 Aug 2017 03:46:31 GMT------------------是否显示HTTP的内容（Y&#x2F;N）:\n通用头字段Connection　　这个字段只在 HTTP1.1 协议中存在。它决定了客户端和服务器进行了一次会话后，服务器是否立即关闭网络连接。 在客户端最直接的表现是使用 read 方法(readLine 方法也是一样)读完客户端请求的 Web 资源后，是否立即返回-1（readLine 返回 null）。Connection 有两个值：Close 和 Keep-Alive。当使用 Connection：Close 时，和 HTTP1.0 协议是一样的，当 read 方法读完数据时立即返回, 而使用 Connection：Keep-Alive 时，read 方法在读完数据后还要被阻塞一段时间。直接读取数据超时时间过后，还继续往下执行。\nDate　　Date 头字段描述了请求消息和响应消息被创建的时间。这个字段值是一个 HTTP-date 类型，它的格式必须是 GMT（格林尼治）时间，GMT 时间是就是北京时间减 8 小时。下面是 Date 字段的一个例子：\n1Date: Tue, 15 Nov 2007 08:12:31 GMT\nContent-Length指定消息实体的字节数。在请求消息中 POST 方法必须使用 Content-Length 来指定请求消息的实体内容的字节数。在响应消息中这个字段值指定了当前 HTTP 响应所返回的 Web 资源的字节数。\nHTTP 请求消息头字段HostHost 字段用于指定客户端所访问的资源所在的主机名和端口号。如果端口号等于连接服务器时所使用的端口号，则端口号可以省略。\nAcceptAccept 字段头确定客户端可以接收的媒体类型。一般的格式是”/“或”类型/“子类型”。这个子段头可以传递多个媒体类型，中间用”，”隔开。如下面是一个 Accept 的例子：\n1Accept:：image&#x2F;gif，image&#x2F;jpg\n如果请求头使用上述的 Accept 字段值，则服务器端在动态生成网页的 IMG 头时将首先包含 gif 格式的图像，如果 gif 图象不存在，则包含 jpg 格式的图象。\nUser-Agent这个字段头用于指定客户端是用什么访问的服务器\n1User-Agent:Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.78 Safari&#x2F;537.36\n服务器可以通过这个字段检查客户机的浏览器版本，并根据不同的版本来确定向客户端发送的数据。\nRangeRange 字段头通过服务器只传输一部分 Web 资源。这个字段头可以用来实现断点续传功能。有很多下载工具就是通过这个字段头进行断点续传的。Range字段可以通过三种格式设置要传输的字节范围：（1）Range: bytes=1000-2000传输范围从 1000 到 2000 字节。（2）Range: bytes=1000-传输 Web 资源中第 1000 个字节以后的所有内容。（3）Range bytes=1000传输最后 1000 个字节。\nHTTP 响应消息头字段Accept-Ranges这个字段说明 Web 服务器是否支持 Range（是否支持断点续传功能），如果支持，则返回 Accept-Ranges: bytes，如果不支持，则返回 Accept-Ranges: none\nContent-Range指定了返回的 Web 资源的字节范围。这个字段值的格式是：开始字节位置—结束字节位置/Web 资源的总字节数\nLocation这个字段指定了上哪个新地址获得新的 Web 资源。当 Web 资源更换 URL 后，而一些老用户不能及时得知这个新的 URL；因此，在老用户访问原来的 URL 时，使用 Location 将这个新的 URL 返回给客户端。这个地址转换对用户来说是完全透明，也就是302跳转。","url":"/2017/08/10/201708/Java网络编程笔记之HTTP模拟请求七/","link":"","plink":"http://example.com/2017/08/10/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8BHTTP%E6%A8%A1%E6%8B%9F%E8%AF%B7%E6%B1%82%E4%B8%83/"},{"title":"Java网络编程笔记之InetAddress对象（一）","content":"简介常用的实现系统间通信的协议有TCP/IP和UDP/IP。TCP/IP 协议族中的主要 socket 类型为流套接字（sockets sockets）和数据报套接字（datagram sockets）。\nTCP/IPTCP/IP是一种可靠的网络数据传输协议。TCP/IP要求通信双方先建立连接，再进行传输，保证数据的可靠性，但是会牺牲一些性能。流套接字将TCP作为其端对端协议（底层使用IP协议），提供了一个可信赖的字节流服务。一个TCP/IP流套接字代表了TCP连接的一端。\nUDP/IPUDP/IP不保证数据一定到达。UDP/IP不直接给通信双方建立连接，，而是发送到网络上进行传输，因此不保证数据传输的可靠性，但是性能上表现较好。数据报套接字使用UDP协议（底层同样使用IP协议），提供了一个”尽力而为”（best-effort）的数据报服务，应用程序可以通过它发送最长65500 字节的个人信息。\nInetAddress对象InetAddress对象代表了一个网络目标地址，包括主机名和数字类型的地址信息。该类有两个子类，Inet4Address 和 Inet6Address，分别对应了目前IP 地址的两个版本。创建InetAddress对象必须依靠它的四个静态方法。getLocalHost方法得到本机的InetAddress对象，getByName、getAllByName和getByAddress得到远程主机的InetAddress对象。\ngetLocalHost方法12345678910111213141516import java.net.InetAddress;import java.net.UnknownHostException;public class InetAddressExample {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\ttry {\t\t\tInetAddress lcoalAddress &#x3D; InetAddress.getLocalHost();\t\t\tSystem.out.println(lcoalAddress.toString());\t\t} catch (UnknownHostException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t}\t}}\n12运行结果是：name-PC&#x2F;192.168.9.80\nInetAddress类中覆盖了Object类中的toString方法\n12345public String toString() {    String hostName &#x3D; holder().getHostName();    return ((hostName !&#x3D; null) ? hostName : &quot;&quot;)        + &quot;&#x2F;&quot; + getHostAddress();}\n如果本机中绑定多个IP，getLocalHost只返回第一个IP，如果想返回全部IP，可以使用getAllByName方法。\ngetByName方法getByName方法可以通过指定的域名从DNS中得到相应的IP地址。如果host所指域名对应多个IP，getByName返回第一个IP地址。getByName方法不会验证IP地址是否正确。\n12345678910111213141516import java.net.InetAddress;import java.net.UnknownHostException;public class InetAddressExample2 {\tpublic static void main(String[] args) throws UnknownHostException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tif(args.length &#x3D;&#x3D; 0){\t\t\treturn;\t\t}\t\tString host &#x3D; args[0];\t\tInetAddress address &#x3D; InetAddress.getByName(host);\t\tSystem.out.println(address);\t}}\n传入值www.baidu.com，输出：\n1www.baidu.com&#x2F;115.239.210.27\ngetAllByName方法使用getAllByName方法可以从DNS中得到域名对应的所有IP地址。返回一个InetAddress类型的数组。getAllByName方法也不会验证IP地址是否存在。\n1234567891011121314151617import java.net.InetAddress;import java.net.UnknownHostException;public class InetAddressExample3 {\tpublic static void main(String[] args) throws UnknownHostException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tif(args.length &#x3D;&#x3D; 0){\t\t\treturn;\t\t}\t\tString host &#x3D; args[0];\t\tInetAddress addresses[] &#x3D; InetAddress.getAllByName(host);\t\tfor(InetAddress address : addresses){\t\t\tSystem.out.println(address);\t\t}\t}}\n输出结果：\n12www.baidu.com&#x2F;115.239.210.27www.baidu.com&#x2F;115.239.211.112\n实际上，getByName方法返回的IP地址是getAllByName返回的第一个IP地址，实际上，getByName就是这样实现的。\n1234public static InetAddress getByName(String host)    throws UnknownHostException {    return InetAddress.getAllByName(host)[0];}\ngetByAddress方法这个方法必须通过IP来创建InetAddress对象，并且IP地址必须是byte数组形式。\n123456789101112131415import java.net.InetAddress;import java.net.UnknownHostException;public class InetAddressExample4 {\tpublic static void main(String[] args) throws UnknownHostException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tbyte ip[] &#x3D; new byte[]{(byte)141,(byte)146,8,66};\t\tInetAddress address1 &#x3D; InetAddress.getByAddress(ip);\t\tInetAddress address2 &#x3D; InetAddress.getByAddress(&quot;Oracle官网&quot;,ip);\t\tSystem.out.println(address1);\t\tSystem.out.println(address2);\t}}\n输出结果\n12&#x2F;141.146.8.66Oracle官网&#x2F;141.146.8.66","url":"/2017/08/03/201708/Java网络编程笔记之InetAddress对象一/","link":"","plink":"http://example.com/2017/08/03/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8BInetAddress%E5%AF%B9%E8%B1%A1%E4%B8%80/"},{"title":"Java网络编程笔记之ServerSocket 对象（八）","content":"ServerSocket 类的构造方法有四种重载形式，它们的定义如下：\n1234public ServerSocket() throws IOExceptionpublic ServerSocket(int port) throws IOExceptionpublic ServerSocket(int port, int backlog) throws IOExceptionpublic ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException\n　　其中 port 是 ServerSocket 对象要绑定的端口，backlog 是请求队列的长度，bindAddr 是 ServerSocket 对象要绑定的 IP 地址。\n通过构造方法绑定端口通过构造方法绑定端口是创建 ServerSocket 对象最常用的方式\n1public ServerSocket(int port) throws IOException\n　　如果 port 参数所指定的端口已经被绑定，构造方法就会抛出 IOException 异常。但实际上抛出的异常是 BindException。如果 port 的值为 0，系统就会随机选取一个端口号。但随机选取的端口意义不大，因为客户端在连接服务器时需要明确知道服务端程序的端口号。可以通过 ServerSocket 的 toString 方法输出和 ServerSocket对象相关的信息。\n12ServerSocket serverSocket &#x3D; new ServerSocket(1320);System.out.println(serverSocket);\n输出：\n1ServerSocket[addr&#x3D;0.0.0.0&#x2F;0.0.0.0,port&#x3D;0,localport&#x3D;1234]\n　　addr 是服务端绑定的 IP 地址，如果未绑定 IP 地址，这个值是 0.0.0.0，在这种情况下，ServerSocket 对象将监听服务端所有网络接口的所有 IP 地址。port 永远是 0。localport 是 ServerSocket 绑定的端口， 如果 port 值为 0 （此处不指输出结果的 port， 指 ServerSocket 构造方法的参数 port），localport（此处指输出结果的 port）是一个随机选取的端口号.在操作系统中规定 1 ~ 1023 为系统使用的端口号。端口号的最小值是 1，最大值是 65535。在 Windows 中用户编写的程序可以绑定端口号小于 1024 的端口， 但在 Linux/Unix 下必须使用 root 登录才可以绑定小于 1024 的端口。\n设置请求队列的长度　　在编写服务端程序时，一般会通过多线程来同时处理多个客户端请求。也就是说，使用一个线程来接收客户端请求，当接到一个请求后（得到一个 Socket 对象），会创建一个新线程，将这个客户端请求交给这个新线程处理。而那个接收客户端请求的线程则继续接收客户端请求\n12345678ServerSocket serverSocket &#x3D; new ServerSocket(1234); &#x2F;&#x2F; 绑定端口    &#x2F;&#x2F; 处理其他任务的代码    while(true)    {        Socket socket &#x3D; serverSocket.accept(); &#x2F;&#x2F; 等待接收客户端请求        ….&#x2F;&#x2F; 处理其他任务的代码        new ThreadClass(socket).start(); &#x2F;&#x2F; 创建并运行处理客户端请求的线程    }\n　　这段代码只要服务器配置足够高，就能处理所有的请求。但是实际情况下，如果需要处理的请求太过复杂，执行时间也会变长，意味着服务器不能够及时响应客户端的请求。　　假设循环内的代码是 Thread.sleep(3000)，这将使程序延迟 3 秒。那么在这 3 秒内，程序不会执行 accept 方法.这段程序只是将端口绑定到了 1234 上，并未开始接收客户端请求。如果在这时一个客户端向端口 1234 发来了一个请求，从理论上讲，客户端应该出现拒绝连接错误，但客户端却显示连接成功。究其原因，就是这节要讨论的请求队列在起作用。　　在使用 ServerSocket 对象绑定一个端口后，操作系统就会为这个端口分配一个先进先出的队列（这个队列长度的默认值一般是 50），这个队列用于保存未处理的客户端请求，因此叫请求队列。而 ServerSocket 类的 accept 方法负责从这个队列中读取未处理的客户端请求。如果请求队列为空，accept 则处于阻塞状态。每当客户端向服务端发来一个请求，服务端会首先将这个客户端请求保存在请求队列中，然后 accept 再从请求队列中读取。这也可以很好地解释为什么上面的代码在还未执行到 accept 方法时，仍然可以接收一定数量的客户端请求。 如果请求队列中的客户端请求数达到请求队列的最大容量时， 服务端将无法再接收客户端请求。如果这时客户端再向服务端发请求，客户端将会抛出一个 SocketException 异常。服务器端处理：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TestRequestQueue {\tpublic static void main(String[] args) throws IOException, InterruptedException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tif(args.length &#x3D;&#x3D; 0){\t\t\treturn;\t\t}\t\tint queueLength &#x3D; Integer.parseInt(args[0]);\t\tServerSocket serverSocket &#x3D; new ServerSocket(1234,queueLength);\t\tSystem.out.println(&quot;端口：1234已经绑定，按回车开始处理客户端请求&quot;);\t\tSystem.in.read();\t\tint n &#x3D; 0;\t\twhile(true){\t\t\tSystem.out.println(&quot;准备接收第&quot;+(++n)+&quot;个客户端请求！&quot;);\t\t\tSocket socket &#x3D; serverSocket.accept();\t\t\tSystem.out.println(&quot;正在处理第&quot;+n+&quot;个客户端请求！&quot;);\t\t\tThread.sleep(3000);\t\t\tSystem.out.println(&quot;第&quot;+n+&quot;个客户端请求处理完成！&quot;);\t\t}\t}}&#x2F;*&#x2F;&#x2F;设置队列长度为：20端口：1234已经绑定，按回车开始处理客户端请求准备接收第1个客户端请求！正在处理第1个客户端请求！第1个客户端请求处理完成！准备接收第2个客户端请求！正在处理第2个客户端请求！第2个客户端请求处理完成！准备接收第3个客户端请求！正在处理第3个客户端请求！第3个客户端请求处理完成！准备接收第4个客户端请求！正在处理第4个客户端请求！第4个客户端请求处理完成！准备接收第5个客户端请求！正在处理第5个客户端请求！第5个客户端请求处理完成！准备接收第6个客户端请求！正在处理第6个客户端请求！第6个客户端请求处理完成！准备接收第7个客户端请求！正在处理第7个客户端请求！第7个客户端请求处理完成！准备接收第8个客户端请求！正在处理第8个客户端请求！第8个客户端请求处理完成！准备接收第9个客户端请求！正在处理第9个客户端请求！第9个客户端请求处理完成！准备接收第10个客户端请求！正在处理第10个客户端请求！第10个客户端请求处理完成！准备接收第11个客户端请求！*&#x2F;\n客户端请求：\n123456789101112131415161718192021222324252627import java.io.IOException;import java.net.Socket;import java.net.UnknownHostException;public class RequestQueue {\tpublic static void main(String[] args) throws UnknownHostException, IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tfor(int i &#x3D; 0;i &lt; 10;i++){\t\t\tSocket socket &#x3D; new Socket(&quot;localhost&quot;,1234);\t\t\tsocket.getOutputStream().write(1);\t\t\tSystem.out.println(&quot;已经创建第&quot;+String.valueOf(i+1)+&quot;个客户端连接！&quot;);\t\t}\t}}&#x2F;*已经创建第1个客户端连接！已经创建第2个客户端连接！已经创建第3个客户端连接！已经创建第4个客户端连接！已经创建第5个客户端连接！已经创建第6个客户端连接！已经创建第7个客户端连接！已经创建第8个客户端连接！已经创建第9个客户端连接！已经创建第10个客户端连接！*&#x2F;\n绑定IP地址在有多个网络接口或多个 IP 地址的计算机上可以使用如下的构造方法将服务端绑定在某一个 IP 地址上：\n1public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException\nbindAddr 参数就是要绑定的 IP 地址。如果将服务端绑定到某一个 IP 地址上，就只有可以访问这个 IP地址的客户端才能连接到服务器上。如一台机器上有两块网卡，一块网卡连接内网，另一块连接外网。如果用Java 实现一个 Email 服务器，并且只想让内网的用户使用它。就可以使用这个构造方法将 ServerSocket 对象绑定到连接内网的 IP 地址上。这样外网就无法访问 Email 服务器了。\n1ServerSocket serverSocket &#x3D; new ServerSocket(1234, 0, InetAddress.getByName(&quot;192.168.18.10&quot;));\n默认构造方法的使用　　除了使用 ServerSocket 类的构造方法绑定端口外， 还可以用 ServerSocket 的 bind 方法来完成构造方法所做的工作。要想使用 bind 方法，必须得用 ServerSocket 类的默认构造方法(没有参数的构造方法)来创建 ServerSocket 对象。bind 方法有两个重载形式\n12public void bind(SocketAddress endpoint) throws IOExceptionpublic void bind(SocketAddress endpoint, int backlog) throws IOException\n　　bind 方法不仅可以绑定端口，也可以设置请求队列的长度以及绑定 IP 地址。bind 方法的作用是为了在建立 ServerSocket 对象后设置 ServerSocket 类的一些选项。而这些选项必须在绑定端口之前设置，一但绑定了端口后，再设置这些选项将不再起作用。下面的代码演示了 bind 方法的使用及如何设置 ServerSocket 类的选项。\n123456789ServerSocket serverSocket1 &#x3D; new ServerSocket();serverSocket1.setReuseAddress(true);serverSocket1.bind(new InetSocketAddress(1234));ServerSocket serverSocket2 &#x3D; new ServerSocket();serverSocket2.setReuseAddress(true);serverSocket2.bind(new InetSocketAddress(&quot;192.168.18.10&quot;, 1234));ServerSocket serverSocket3 &#x3D; new ServerSocket();serverSocket3.setReuseAddress(true);serverSocket3.bind(new InetSocketAddress(&quot;192.168.18.10&quot;, 1234), 30);\n在上面的代码中设置了 SO_REUSEADDR 选项。如果使用下面的代码，这个选项将不起作用。\n12ServerSocket serverSocket3 &#x3D; new ServerSocket(1234);serverSocket3.setReuseAddress(true);","url":"/2017/08/12/201708/Java网络编程笔记之ServerSocket对象八/","link":"","plink":"http://example.com/2017/08/12/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8BServerSocket%E5%AF%B9%E8%B1%A1%E5%85%AB/"},{"title":"Java网络编程笔记之Socket接收和发送数据（二）","content":"TCP 的 Java 支持Java 为 TCP 协议提供了两个类：Socke 类和 ServerSocket 类。一个 Socket 实例代表了TCP连接的一个客户端，而一个ServerSocket实例代表了TCP连接的一个服务器端。服务器端要同时处理 ServerSocket 实例和Socket实例，而客户端只需要使用Socket实例。每个 Socket 实例会关联一个 InputStream和 OutputStream 对象，通过将字节写入套接字的 OutputStream 来发送数据，并通过从 InputStream 来接收数据。\nTCP 连接的建立步骤一般TCP客户端要经过三个步骤：（1）、创建一个 Socket 实例：构造函数向指定的远程主机和端口建立一个 TCP 连接；（2）、通过套接字的 I/O 流与服务端通信；（3）、使用 Socket 类的 close 方法关闭连接。一般TCP 服务端执行如下两步操作：（1）、创建一个 ServerSocket 实例并指定本地端口，用来监听客户端在该端口发送的 TCP 连接请求；（2）、重复执行：　　调用 ServerSocket 的 accept（）方法以获取客户端连接，并通过其返回值创建一个 Socket 实例；　　为返回的 Socket 实例开启新的线程，并使用返回的 Socket 实例的 I/O流与客户端通信； 通信完成后，使用 Socket 类的 close（）方法关闭该客户端的套接字连接。\n连接服务器在客户端可以通过域名和IP两种方式来连接服务器。使用域名连接还需要在DNS服务器中找到IP地址再进行连接。通过Socket连接服务器的方式最常用的是通过Socket类构造函数将IP或域名以及端口号作为参数传递到Socket类中。这里使用最常用的一种。\n123456789101112131415161718192021import java.io.IOException;import java.net.Socket;import java.net.UnknownHostException;public class SocketExample {\tpublic static void main(String[] args) {\t\t\ttry {\t\t\t\tif(args.length &gt; 0){\t\t\t\t\tSocket socket &#x3D; new Socket(args[0], 80);   &#x2F;&#x2F;传入参数，端口为80\t\t\t\t\tSystem.out.println(args[0]+&quot;连接成功！&quot;);\t\t\t\t}else{\t\t\t\t\tSystem.out.println(&quot;请输入域名或ip&quot;);\t\t\t\t}\t\t\t} catch (UnknownHostException e) {\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t} catch (IOException e) {\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\tSystem.out.println(&quot;错误信息&quot;+e.getMessage());\t\t\t}\t}}\n发送接收数据在Socket中最重要的两个方法就是getInputStream和getOutputStream。这两个方法分别用来得到用于读取和写入数据的 InputStream和 OutputStream 对象。以服务器为中心，InputStream读取的是服务器程序向客户端发送过来的数据。而OutputStream 是客户端向服务器发送的数据。\n123456789101112131415161718192021222324252627282930313233import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.net.Socket;import java.net.UnknownHostException;public class SocketSendData {\tpublic static void main(String[] args) throws UnknownHostException, IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub&#x2F;&#x2F;\t\t向服务器发送数据\t\tSocket socket &#x3D; new Socket(&quot;www.xxxx.com&quot;, 80);\t\tOutputStream ops &#x3D; socket.getOutputStream();\t\tOutputStreamWriter opsw &#x3D; new OutputStreamWriter(ops);\t\tBufferedWriter bw &#x3D; new BufferedWriter(opsw);\t\tbw.write(&quot;hello world \\r\\n\\r\\n&quot;);  &#x2F;&#x2F;将数据放到缓冲区，提高效率。 HTTP协议头以\\r\\n\\r\\n结束\t\tbw.flush();&#x2F;&#x2F;\t\t从服务器端接收数据\t\tInputStream ips &#x3D; socket.getInputStream();\t\tInputStreamReader ipsr &#x3D; new InputStreamReader(ips);\t\tBufferedReader br &#x3D;  new BufferedReader(ipsr);\t\tString s &#x3D; &quot;&quot;;\t\twhile((s &#x3D; br.readLine()) !&#x3D; null){\t\t\tSystem.out.println(s);\t\t}\t\tsocket.close();\t}}\n返回的数据为：\n1234567891011121314HTTP&#x2F;1.1 400 Bad RequestServer: nginx&#x2F;1.12.0Date: Thu, 03 Aug 2017 15:33:14 GMTContent-Type: text&#x2F;htmlContent-Length: 173Connection: close&lt;html&gt;&lt;head&gt;&lt;title&gt;400 Bad Request&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body bgcolor&#x3D;&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.12.0&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n关闭网络连接关闭网络连接的方法有4个：（后两种方法不可取）1、直接调用Socket的close方法2、只要Socket类中的OutputStream 和InputStream  有一个关闭，网络连接自动关闭3、程序退出时网络连接自动关闭4、将Socket对象设置为null或未关闭使用new Socket（）建立新的对象后，由JVM的垃圾回收器回收Socket对象分配的内存后自动关闭网络连接。在Socket对象被关闭后，可以通过isClosed方法来判断某个Socket是否关闭。只要Socket处于关闭状态isClosed就返回true，如果只是建立一个未连接的Socket对象，isClosed返回false。\n1234567891011import java.net.Socket;public class isClosedExample {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSocket socket &#x3D; new Socket();\t\tSystem.out.println(socket.isClosed());\t}}&#x2F;&#x2F;输出false\n 　　除了isClosed方法，Socket还有一个isConnected方法来判断Socket对象是否连接成功。isConnected方法不是判断当前Socket对象的当前连接状态，而是Socket对象是否曾经成功连接过。如果成功连接过，即时isClosed返回true，isConnected仍然返回true。所以要判断当前Socket是否处于连接状态，必须同时使用isClosed和isConnected方法。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.IOException;import java.net.Socket;public class isClosedExample {\tpublic static void printState(Socket socket,String name){\t\tSystem.out.println(name + &quot;.isClosed();&quot; + socket.isClosed());\t\tSystem.out.println(name + &quot;.isConnected();&quot; + socket.isConnected());\t\tif(socket.isClosed() &#x3D;&#x3D; false &amp;&amp; socket.isConnected() &#x3D;&#x3D; true){\t\t\tSystem.out.println(name + &quot;处于连接状态！&quot;);\t\t}else{\t\t\tSystem.out.println(name + &quot;处于非连接状态！&quot;);\t\t}\t\tSystem.out.println();\t}\tpublic static void main(String[] args) throws IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSocket socket1 &#x3D; null;\t\tSocket socket2 &#x3D; null;\t\t\t\tsocket1 &#x3D; new Socket(&quot;www.xxxxxx.com&quot;, 80);\t\tprintState(socket1, &quot;socket1&quot;);\t\t\t\tsocket1.getOutputStream().close();\t\tprintState(socket1, &quot;socket1&quot;);\t\t\t\tsocket2 &#x3D; new Socket();\t\tprintState(socket2, &quot;socket2&quot;);\t\t\t\tsocket2.close();\t\tprintState(socket2, &quot;socket2&quot;);\t\t\t}}&#x2F;&#x2F;结果&#x2F;*socket1.isClosed();falsesocket1.isConnected();truesocket1处于连接状态！socket1.isClosed();truesocket1.isConnected();truesocket1处于非连接状态！socket2.isClosed();falsesocket2.isConnected();falsesocket2处于非连接状态！socket2.isClosed();truesocket2.isConnected();falsesocket2处于非连接状态！*&#x2F;\n 有时候我们指向关闭OutputStream或InputStream，而在关闭输入输出流的同时，不关闭网络连接。 因此我们需要另外两个方法：shutdownInput和shutdownOutput,这两个方法只关闭相应的输入输出流，Socket提供了两个方法来判断Socket对象的输入、输出流是否被关闭，这两个方法是isInputShutdown()和isOutputShutdown(). \n1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.net.Socket;import java.net.UnknownHostException;public class shutdownStream {\tpublic static void printState(Socket socket){\t\tSystem.out.println(&quot;isInputShutdown:&quot;+ socket.isInputShutdown());\t\tSystem.out.println(&quot;isOutShutdown:&quot; + socket.isOutputShutdown());\t\tSystem.out.println(&quot;isClosed:&quot; + socket.isClosed());\t\tSystem.out.println();\t}\tpublic static void main(String[] args) throws UnknownHostException, IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\t\tSocket socket &#x3D; new Socket(&quot;www.xxxxx.com&quot;, 80);\t\tprintState(socket);\t\t\t\tsocket.shutdownInput();\t\tprintState(socket);\t\t\t\tsocket.shutdownOutput();\t\tprintState(socket);\t}}&#x2F;&#x2F;输出结果&#x2F;*isInputShutdown:falseisOutShutdown:falseisClosed:falseisInputShutdown:trueisOutShutdown:falseisClosed:falseisInputShutdown:trueisOutShutdown:trueisClosed:false*&#x2F;","url":"/2017/08/04/201708/Java网络编程笔记之Socket接收和发送数据二/","link":"","plink":"http://example.com/2017/08/04/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8BSocket%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E4%BA%8C/"},{"title":"Java网络编程笔记之Socket类的getter和setter方法（六）","content":"用于获得信息的getter方法我们可以在Socket对象中获取到3种信息。\n服务器信息对于客户端来说，服务器的信息只有两个：IP和端口。Socket类为我们提供了3个方法来得到这两个信息。\npublic InetAddress getInetAddress()通过Socket的这个方法返回一个InetAddress对象。再通过这个对象的get方法，就可以得到服务器的IP、域名等信息。\n1234567891011import java.io.IOException;import java.net.Socket;import java.net.UnknownHostException;public class getSocketInfo {\tpublic static void main(String[] args) throws UnknownHostException, IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSocket socket &#x3D; new Socket(&quot;www.xxxxx.com&quot;,80);\t\tSystem.out.println(socket.getInetAddress().getHostAddress()); &#x2F;&#x2F;输出IP地址\t\tSystem.out.println(socket.getInetAddress().getHostName());  &#x2F;&#x2F;输出域名\t}}\npublic int getPort()获取端口\n12Socket socket &#x3D; new Socket(&quot;www.xxxxx.com&quot;,80);System.out.println(socket.getPort());\npublic SocketAddress getRemoteSocketAddress()这个方法返回结果是将 getInetAddress 和 getPort 方法结合在了一起，利用这个方法可以同时得到服务器的 IP 和端口号。但这个方法返回了一个 SocketAddress 对象，这个对象只能作为 connect 方法的参数用于连接服务器；而要想获得服务器的 IP 和端口号，必须得将 SocketAddress 转换为它的子类 InetSocketAddress。\n123Socket socket &#x3D; new Socket(&quot;www.xxxx.com&quot;,80);\tSystem.out.println(((InetSocketAddress)socket.getRemoteSocketAddress()).getHostName());\t\tSystem.out.println(((InetSocketAddress)socket.getRemoteSocketAddress()).getPort());","url":"/2017/08/10/201708/Java网络编程笔记之Socket类的getter和setter方法六/","link":"","plink":"http://example.com/2017/08/10/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8BSocket%E7%B1%BB%E7%9A%84getter%E5%92%8Csetter%E6%96%B9%E6%B3%95%E5%85%AD/"},{"title":"Java网络编程笔记之Socket超时（五）","content":"客户端超时分成两种：连接超时和读取数据超时\n连接超时在 Socket 类中只有通过 connect 方法的第二个参数才能指定连接超时的时间。由于使用 connect方法连接服务器必须要指定IP和端口。因此，无效的IP或端口必将引发连接超时错误。\n读取数据超时客户端接收数据可能会因为网络延迟、网络堵塞等原因，使客户端一直处于等待的状态。而客户端在等待一段时间后,如果服务器还没有将数据发送到客户端。客户端Socket将会抛出一个超时错误。通过 Socket类的setSoTimeout方法来设置读取数据超时的时间；时间的单位是毫秒。这个方法必须在读取数据之前调用才会生效。如果将超时时间设为 0，则不使用超时时间；也就是说，客户端什么时候和服务器断开，将完全取决于服务端程序的超时设置。如下面的语句将读取数据超时时间设为5秒。\n1234Socket socket &#x3D; new Socket();socket.setSoTimeout(5000);socket.connect();socket.getInputStream().read();\n要注意不能将连接超时和读取数据超时时间设置过小，如果太小，有可能服务器还没来得及发送数据过来，客户端就抛出超时错误。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.IOException;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketTimeoutException;public class socketOuttime {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tlong time1 &#x3D; 0,time2 &#x3D; 0;\t\tSocket socket &#x3D; new Socket();\t\ttry {\t\t\t\t\t\tif(args.length &lt; 4){\t\t\t\tSystem.out.println(&quot;参数错误！&quot;);\t\t\t\treturn;\t\t\t}\t\t\ttime1 &#x3D; System.currentTimeMillis();\t\t\tsocket.connect(new InetSocketAddress(args[0],Integer.parseInt(args[1])), Integer.parseInt(args[2]));\t\t\ttime1 &#x3D; System.currentTimeMillis();\t\t\tsocket.getInputStream().read();\t\t} catch (SocketTimeoutException e) {\t\t\t&#x2F;&#x2F; TODO: handle exception\t\t\t&#x2F;*\t\t\t \t判断当前是否为连接状态\t\t\t \t因为超时报错只有两种，一个是读取数据超时，一个是连接超时\t\t\t \t如果当前为连接状态，只能是读取数据超时。如果不是连接状态，说明当前还未连接成功，所以是连接超时。\t\t\t \t\t\t\t *&#x2F;\t\t\tif(!socket.isClosed() &amp;&amp; socket.isConnected()){   \t\t\t\tSystem.out.println(&quot;读取数据超时&quot;);  \t\t\t}else{\t\t\t\tSystem.out.println(&quot;连接超时&quot;);\t\t\t}\t\t}catch (NumberFormatException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t} catch (IOException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t} finally{\t\t\ttime2 &#x3D; System.currentTimeMillis();\t\t\tSystem.out.println(time2 - time1);\t\t}\t}}","url":"/2017/08/08/201708/Java网络编程笔记之Socket超时五/","link":"","plink":"http://example.com/2017/08/08/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8BSocket%E8%B6%85%E6%97%B6%E4%BA%94/"},{"title":"Java网络编程笔记之使用SocketAddress管理网络地址（四）","content":"Socket类的connect方法不提供简单的直接调用IP和端口方式，而是使用SocketAddress类来向connect方法传递服务器的IP和端口。虽然麻烦，但是带来一个好处，就是网络地址可以重用。网络地址重用表现在两个方面：1.通过建立一个SocketAddress对象，可以多次连接同一个服务器时使用这个Socket对象。2.Socket类中提供了两个方法：getRemoteSocketAddress和getLocalSocketAddress，通过两个方法可以得到服务器和本机的网络地址。并且得到的网络地址在有效的Socket对象关闭后仍然可以使用。\n12public SocketAddress getRemoteSocketAddress();public SocketAddress  getLocalSocketAddress();\n不管在使用Socket类连接服务器时是直接使用IP和端口还是使用SocketAddress，这两个方法都返回SocketAddress形式的网络地址。当Socket对象未连接时这两个方法都返回null，但是只有在Socket未连接时这两个方法才返回null，当已经连接成功过的Socket对象关闭之后仍然可以使用这两个方法得到响应的IP地址。SocketAddress类只是一个抽象类，除了有一个默认的构造方法外，其他方法都是abstract的，因此必须使用SocketAddress的子类来建立SocketAddress对象。在JDK1.4中提供了IP网络地址的实现类：java.net.InetSocketAddress。这个类是从SocketAddress继承的，可以通过下面的方法建立SocketAddress对象：\n1SocketAddress socketAddress &#x3D; new InetSocketAddress(host,ip);\n共享网络IP\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.IOException;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;import java.net.UnknownHostException;public class socketAddressExample {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSocket socket1;\t\ttry {\t\t\tsocket1 &#x3D; new Socket(&quot;www.xxxxx.com&quot;, 80);\t\t\tSocketAddress socketaddress &#x3D; socket1.getRemoteSocketAddress();\t\t\tsocket1.close();\t\t\t\t\t\tSocket socket2 &#x3D; new Socket();\t\t\tsocket2.connect(socketaddress);\t\t\tsocket2.close();\t\t\t\t\t\tInetSocketAddress inetSocketAddress1 &#x3D; (InetSocketAddress) socketaddress;\t\t\tSystem.out.println(&quot;服务器域名是：&quot;+ inetSocketAddress1.getAddress().getHostName());\t\t\tSystem.out.println(&quot;服务器IP是：&quot;+ inetSocketAddress1.getAddress().getHostAddress());\t\t\tSystem.out.println(&quot;服务器端口是：&quot;+ inetSocketAddress1.getPort());\t\t\t\t\t\tInetSocketAddress inetSocketAddress2 &#x3D; (InetSocketAddress) socket2.getLocalSocketAddress();\t\t\tSystem.out.println(&quot;本地IP是：&quot;+ inetSocketAddress2.getAddress().getLocalHost());\t\t\tSystem.out.println(&quot;本地端口是：&quot;+ inetSocketAddress2.getPort());\t\t\t\t\t} catch (UnknownHostException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t} catch (IOException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\tSystem.out.println(e.getMessage());\t\t}\t}}&#x2F;&#x2F;输出结果&#x2F;*服务器域名是：www.xxxx.com服务器IP是：xxx.xxx.xxx.xxx   服务器端口是：80本地IP是：Gavin-PC&#x2F;192.168.107.1本地端口是：62750*&#x2F;","url":"/2017/08/06/201708/Java网络编程笔记之使用SocketAddress管理网络地址四/","link":"","plink":"http://example.com/2017/08/06/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BD%BF%E7%94%A8SocketAddress%E7%AE%A1%E7%90%86%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E5%9B%9B/"},{"title":"Java网络编程笔记之关闭服务端连接（十）","content":"在客户端和服务端的数据交互完成后，一般需要关闭网络连接。对于服务端来说，需要关闭服务端建立的 Socket 和 ServerSocket。在关闭 Socket 后，客户端并不会马上感知自已的 Socket 已经关闭，也就是说，在服务端的 Socket 关闭后，客户端的 Socket 的 isClosed 和 isConnected 方法仍然会分别得到 false 和 true。但对已关闭的 Socket 的输入输出流进行操作会抛出一个 SocketException 异常。在关闭服务端的 ServerSocket 后，ServerSocket 对象所绑定的端口被释放。这时客户端将无法连接服务端程序。\n123456789101112131415import java.io.IOException;import java.net.Socket;import java.net.UnknownHostException;public class Client {\tpublic static void main(String[] args) throws UnknownHostException, IOException, InterruptedException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSocket socket &#x3D; new Socket(&quot;127.0.0.1&quot;,1234);\t\tThread.sleep(1000);\t\tSystem.out.println(&quot;read（）&#x3D;&quot;+socket.getInputStream().read());\t\tSystem.out.println(&quot;isConnected() &#x3D; &quot;+socket.isConnected());\t\tSystem.out.println(&quot;isClosed() &#x3D; &quot; + socket.isClosed());\t}}\n12345678910111213141516import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;public class server {\tpublic static void main(String[] args) throws IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tServerSocket serverSocket &#x3D; new ServerSocket(1234);\t\twhile(true){\t\t\tSocket socket  &#x3D; serverSocket.accept();\t\t\tsocket.close();\t\t}\t}}\n输出结果：\n123read（）&#x3D;-1       &#x2F;&#x2F;因为没有发送数据，没保存isConnected() &#x3D; trueisClosed() &#x3D; false\n可以使用 ServerSocket 类的 isClosed 和 isBound 方法判断 ServerSocket 是否处于活动状态\n123456789101112131415import java.io.IOException;import java.net.ServerSocket;public class testServer {\tpublic static void main(String[] args) throws IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tServerSocket serverSocket &#x3D; new ServerSocket(1234);\t\tif (serverSocket.isBound() &#x3D;&#x3D; true &amp;&amp; serverSocket.isClosed() &#x3D;&#x3D; false){\t\t\tSystem.out.println(&quot;serverSocket 处于活动状态!&quot;);\t\t}else{\t\t\tSystem.out.println(&quot;serverSocket 处于非活动状态!&quot;);\t\t\t\t\t}\t}}\n“非活动状态”可能是 serverSocket 对象已经关闭，也可能是 serverSocket 对象是使用 ServerSocket 类的默认构造方法创建的，而且未调用 bind 方法绑定端口。 isBound 方法返回 true不意味着 serverSocket 对象处于活动状态，调用 close 方法不会将绑定状态置为 false，和 Socket 类的 isConnected 方法类似。","url":"/2017/08/12/201708/Java网络编程笔记之关闭服务端连接十/","link":"","plink":"http://example.com/2017/08/12/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%8D%81/"},{"title":"Java网络编程笔记之多种建立网络连接的方式（三）","content":"通过构造方法可以通过6个重载构造函数以不同方式连接服务器。并且可以分为两类。\n自动选择IP当本机有多块网卡，或者一个网卡上绑定了多个IP地址，Socket会自动为我们选择一个可用的IP地址。\npublic Socket(String host,int port)一个字符串类型的IP或域名以及一个整形的端口号。\npublic Socket(InetAddress inetaddress,int port)和第一种类似，将字符串类型的host改为InetAddress对象类型。使用InetAddress主要是考虑在程序中可能需要使用Socket类多次连接同一个IP或域名，这样使用InetAddress的效率比较高。\npublic Socket(String inetaddress,int port,boolean stream)这个方法和第一个差不多，多了一个boolean类型的stream参数。如果这个stream参数为true，那这个构造方法和第一种构造方法完全一样。如果stream为false，则使用UDP协议建议一个UDP连接。后来在JDK中加入了DatagramSocket类，所以说这个类很少用。\npublic Socket(InetAddress inetaddress,int port, boolean flag)这个构造方法和第三种构造方法的的flag标记的含义一样，不建议使用\n123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.IOException;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;public class createSocket {\tprivate static void closeSocket(Socket socket){\t\tif(socket !&#x3D; null){\t\t\ttry {\t\t\t\tsocket.close();\t\t\t} catch (IOException e) {\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t}\t\t}\t}\tpublic static void main(String[] args) throws UnknownHostException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tSocket socket1 &#x3D; null,socket2 &#x3D; null,socket3 &#x3D; null,socket4 &#x3D; null;\t\t\t\ttry {\t\t\tsocket1 &#x3D; new Socket(&quot;www.xxxx.com&quot;, 80);\t\t\tSystem.out.println(&quot;socket1 连接成功！&quot;);\t\t\t\t\t\t\t\t\tsocket2 &#x3D; new Socket(InetAddress.getByName(&quot;www.xxxx.com&quot;), 80);\t\t\tSystem.out.println(&quot;socket2 连接成功！&quot;);\t\t\t\t\t\tsocket3 &#x3D; new Socket(&quot;www.xxxx.com&quot;, 80,false);\t\t\tSystem.out.println(&quot;socket3 连接成功！&quot;);\t\t\t\t\t\tsocket4 &#x3D; new Socket(InetAddress.getByName(&quot;www.xxxx.com&quot;), 80,false);\t\t\tSystem.out.println(&quot;socket4 连接成功！&quot;);\t\t\t\t\t} catch (IOException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t}finally{\t\t\tcloseSocket(socket1);\t\t\tcloseSocket(socket2);\t\t\tcloseSocket(socket3);\t\t\tcloseSocket(socket4);\t\t}\t}}\n手动绑定IP当本机有多个IP时，在连接服务器时需要由客户端确定需要使用哪个IP。\npublic Socket(String host ,int port, InetAddress inetaddress,int localPort)这个构造方法参数分为两部分，第一部分分为前两个参数：host和port，分别表示要连接的服务器的IP和端口号。第二部分分为后两个参数：inetaddress和localPort，其中inetaddress表示要使用的本机IP地址，而localPort表示要绑定本地端口号。localPort可以设置为本机任何未被绑定的端口号，如果localPort设置为0，java将在1024到65536之间随机一个未被绑定的端口号。\npublic Socket(InetAddress  inetaddress,int port, InetAddress inetaddress1,int localPort)这个构造方法和第一个基本相同，只不过第一个参数换成了inetaddress。\n1我电脑只有一个ip，我就不写代码了。。。\n通过connect方法连接服务器Socket不仅可以通过构造方法直接连接服务器，还能建立Socket对象，通过connect方法连接服务器。Socket类的connect方法有两个重载方式：\npublic void connect(InetSocketAddress endpoint) throws IOExceptionSocket类的connect方法与其构造方法描述服务器信息有一些差异。connect直接将IP和端口封装在了SocketAddress类的子类InetSocketAddress中\n12Socket socket &#x3D; new Socket();socket.connect(new InetSocketAddress(host , port));\npublic void connect(InetSocketAddress endpoint,int timeout) throws IOException这个和上一个相比，多了一个timeout参数。这个参数表示连接的超时时间，单位是毫秒。如果设置为0，则使用默认的超时时间。connect方法可以通过Socket的bind方法来绑定本地IP\n123456789101112131415161718192021222324252627282930313233import java.io.IOException;import java.net.InetSocketAddress;import java.net.Socket;public class socket_connect {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\t\t\ttry {\t\t\tSocket socket1 &#x3D; new Socket();\t\t\tSocket socket2 &#x3D; new Socket();\t\t\tSocket socket3 &#x3D; new Socket();\t\t\tsocket1.connect(new InetSocketAddress(&quot;www.supeixun.com&quot;,80));\t\t\tsocket1.close();\t\t\tSystem.out.println(&quot;socket1连接成功！&quot;);\t\t\t\t\t\tsocket2.bind(new InetSocketAddress(&quot;200.200.200.200&quot;, 0));\t\t\tsocket2.connect(new InetSocketAddress(&quot;200.200.200.4&quot;, 80));\t\t\tsocket2.close();\t\t\tSystem.out.println(&quot;socket2连接成功！&quot;);\t\t\t\t\t\tsocket3.bind(new InetSocketAddress(&quot;192.168.18.252&quot;, 0));\t\t\tsocket3.connect(new InetSocketAddress(&quot;200.200.200.4&quot;, 80),2000);\t\t\tsocket3.close();\t\t\tSystem.out.println(&quot;socket3连接成功！&quot;);\t\t\t\t\t} catch (IOException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\tSystem.out.println(e.getMessage());\t\t}\t}}","url":"/2017/08/05/201708/Java网络编程笔记之多种建立网络连接的方式三/","link":"","plink":"http://example.com/2017/08/05/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%9A%E7%A7%8D%E5%BB%BA%E7%AB%8B%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%89/"},{"title":"Java网络编程笔记之服务端接收和发送数据（九）","content":"在建立完 ServerSocket 对象后，通过 accept 方法返回的 Socket 对象，服务端就可以和客户端进行数据交互。Socket 类和 ServerSocket 类都有两个得到输入输出流的方法：getInputStream 和 getOutputStream。对于 Socket 类而言，使用 getInputStream 方法得到的 InputStream 是从服务端获取数据，而 getOutputStream 方法得到的 OutputStream 是向服务端发送数据。而 ServerSocket 的 getInputStream和 getOutputStream 方法也类似。InputStream 从客户端读取数据，OutputStream 向客户端发送数据。下面的代码是一个接收 HTTP 请求，并返回 HTTP 请求头信息的程序，它演示了 ServerSocket 类如何读取和发送来自客户端的数据。\n123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;public class HttpEchoServer extends Thread{\tprivate Socket socket;\tpublic void run(){\t\ttry {\t\t\tInputStreamReader isr &#x3D; new InputStreamReader(socket.getInputStream());\t\t\tBufferedReader br &#x3D; new BufferedReader(isr);\t\t\tOutputStreamWriter osw &#x3D; new OutputStreamWriter(socket.getOutputStream());\t\t\tosw.write(&quot;HTTP&#x2F;1.1 200 ok \\r\\n\\r\\n&quot;);\t\t\tString s &#x3D; &quot;&quot;;\t\t\twhile(!(s &#x3D; br.readLine()).equals(&quot;&quot;)){\t\t\t\tosw.write(&quot;&lt;html&gt;&lt;body&gt;&quot;+s+&quot;&lt;br&#x2F;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&quot;);\t\t\t}\t\t\tosw.flush();\t\t\tsocket.close();\t\t\t\t} catch (IOException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t}\t\t\t}\tpublic HttpEchoServer(Socket socket){\t\tthis.socket &#x3D; socket;\t}\tpublic static void main(String[] args) throws IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tServerSocket serverSocket &#x3D; new ServerSocket(8888);\t\tSystem.out.println(&quot;服务器已经启动，端口为：8888&quot;);\t\twhile(true){\t\t\tSocket socket &#x3D; serverSocket.accept();\t\t\tnew HttpEchoServer(socket).start();\t\t}\t}}\n12345678910浏览器中输入：http:&#x2F;&#x2F;localhost:8888&#x2F;GET &#x2F; HTTP&#x2F;1.1Host: localhost:8888Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.78 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q&#x3D;0.8Cookie: Hm_lvt_e412b6801483c42a3a6587d769295d4f&#x3D;1502344237\n每读一行请求头信息，就向客户端写一行响应信息。最后用 flush 方法将输出缓冲区中的内容发送到客户端。只要使用 OutputStream，在最后就必须要调用 flush 方法。","url":"/2017/08/12/201708/Java网络编程笔记之服务端接收和发送数据九/","link":"","plink":"http://example.com/2017/08/12/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E4%B9%9D/"},{"title":"Java网络编程笔记之获取 ServerSocket 信息（十一）","content":"与 ServerSocket 对象相关的信息有两个：绑定端口和绑定 IP 地址。绑定端口可以通过 getLocalPort方法获得。绑定 IP 地址可以通过 getInetAddress 方法获得\ngetLocalPort 方法\nServerSocket 对象未绑定端口，getLocalPort 方法的返回值为-1。\nServerSocket 对象绑定了一个固定的端口，getLocalPort 方法返回固定端口。\nServerSocket 对象的绑定端口为 0，getLocalPort 方法返回一个随机的端口也被称为匿名端口。12345678910111213import java.io.IOException;import java.net.ServerSocket;public class getLocalPort {\tpublic static void main(String[] args) throws IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tfor(int i &#x3D;1 ; i &lt;&#x3D; 5;i++){\t\t\tSystem.out.println(&quot;随机端口&quot;+i+&quot;:&quot;);\t\t\tSystem.out.println(new ServerSocket(0).getLocalPort());\t\t}\t}}\n输出结果是：12345678910随机端口1:49556随机端口2:49557随机端口3:49558随机端口4:49559随机端口5:49560\ngetInetAddress 方法getInetAddress 可以得到 ServerSocket 对象绑定的 IP 地址。如果 ServerSocket 对象未绑定 IP 地址，返回 0.0.0.0。1234567891011121314import java.io.IOException;import java.net.InetSocketAddress;import java.net.ServerSocket;public class getInetAddress {\tpublic static void main(String[] args) throws IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tServerSocket serverSocket &#x3D; new ServerSocket();\t\tserverSocket.bind(new InetSocketAddress(&quot;192.168.107.1&quot;,0));\t\tSystem.out.println(serverSocket.getInetAddress().getHostAddress());\t}}\n运行结果：1192.168.107.1\ngetLocalSocketAddress使用 getLocalSocketAddress 方法可以同时得到绑定端口和绑定 IP 地址。 这个方法返回了一个 SocketAddress 对象。SocketAddress 类是一个抽象类，要想分别得到端口和 IP 地址，必须将 SocketAddress 对象转换成 InetSocketAddress 对象（InetSocketAddress 类是从 SocketAddress 类继承的）12345678910111213141516import java.io.IOException;import java.net.InetSocketAddress;import java.net.ServerSocket;public class getInetAddress {\tpublic static void main(String[] args) throws IOException {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tServerSocket serverSocket &#x3D; new ServerSocket();\t\tserverSocket.bind(new InetSocketAddress(&quot;192.168.107.1&quot;,1234));\t\tSystem.out.println(serverSocket.getLocalSocketAddress());\t\tInetSocketAddress nsa &#x3D; (InetSocketAddress) serverSocket.getLocalSocketAddress();\t\tSystem.out.println(nsa.getAddress().getHostAddress());\t\tSystem.out.println(nsa.getPort());\t\t}}\n输出结果：123&#x2F;192.168.107.1:1234192.168.107.11234","url":"/2017/08/17/201708/Java网络编程笔记之获取ServerSocket信息十一/","link":"","plink":"http://example.com/2017/08/17/201708/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%8E%B7%E5%8F%96ServerSocket%E4%BF%A1%E6%81%AF%E5%8D%81%E4%B8%80/"},{"title":"伸展树学习笔记","content":"简介AVL树的构建过于苛刻，在构建过程中要处处保持它的特性。为此我们引入一个较为宽松的二叉搜索树。\n局部性局部性就是实际计算环境中普遍存在的一种现象，就是说刚被访问的数据，极有可能很快的再次被访问。也就是说刚被访问过的节点，极有可能很快的再次被访问。因此利用局部性，是否能提高访问效率？\n伸展树伸展树，或者叫自适应查找树，是一种用于保存有序集合的简单高效的数据结构。伸展树实质上是一个二叉查找树。允许查找，插入，删除，删除最小，删除最大，分割，合并等许多操作，这些操作的时间复杂度为O(logN)。由于伸展树可以适应需求序列，因此他们的性能在实际应用中更优秀。\n实现节点123456typedef int Type;typedef struct SplayTreeNode {    Type key;                        &#x2F;&#x2F; 关键字(键值),用来排序    struct SplayTreeNode *left;        &#x2F;&#x2F; 左孩子    struct SplayTreeNode *right;    &#x2F;&#x2F; 右孩子} Node, *SplayTree; \n旋转12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Node* splaytree_splay(SplayTree tree, Type key){    Node N, *l, *r, *c;    if (tree &#x3D;&#x3D; NULL)  &#x2F;&#x2F;判断是不是空树，如果是空树，直接返回NULL    {            return tree;    }    N.left &#x3D; N.right &#x3D; NULL;    l &#x3D; r &#x3D; &amp;N;    for (;;)    {        if (key &lt; tree-&gt;key)    &#x2F;&#x2F;没找到key值，但是判断出来key比当前节点小，也就是在树的左边        {            if (tree-&gt;left &#x3D;&#x3D; NULL)  &#x2F;&#x2F;当前节点的左子树是NULL，直接退出                break;            if (key &lt; tree-&gt;left-&gt;key)  &#x2F;&#x2F;如果key小于当前节点左子树的key            {                c &#x3D; tree-&gt;left;                         &#x2F;&#x2F;下面四条语句是当前节点和左孩子节点通过左旋，使左孩子成为根结点                tree-&gt;left &#x3D; c-&gt;right;                c-&gt;right &#x3D; tree;                tree &#x3D; c;                if (tree-&gt;left &#x3D;&#x3D; NULL)                     break;            }            r-&gt;left &#x3D; tree;                                        r &#x3D; tree;            tree &#x3D; tree-&gt;left;        }else if (key &gt; tree-&gt;key)   &#x2F;&#x2F;找到了key值，key值比当前节点大，也就是在树的右边        {            if (tree-&gt;right &#x3D;&#x3D; NULL)                 break;            if (key &gt; tree-&gt;right-&gt;key)             {                c &#x3D; tree-&gt;right;                          &#x2F;* 03, rotate left *&#x2F;                tree-&gt;right &#x3D; c-&gt;left;                c-&gt;left &#x3D; tree;                tree &#x3D; c;                if (tree-&gt;right &#x3D;&#x3D; NULL)                     break;            }            l-&gt;right &#x3D; tree;                              &#x2F;* 04, link left *&#x2F;            l &#x3D; tree;            tree &#x3D; tree-&gt;right;        }        else        {            break;        }    }    l-&gt;right &#x3D; tree-&gt;left;                                &#x2F;* 05, assemble *&#x2F;    r-&gt;left &#x3D; tree-&gt;right;    tree-&gt;left &#x3D; N.right;    tree-&gt;right &#x3D; N.left;    return tree;}\n插入操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&#x2F;*  * 将结点插入到伸展树中(不旋转) * * 参数说明： *     tree 伸展树的根结点 *     z 插入的结点 * 返回值： *     根节点 *&#x2F;static Node* splaytree_insert(SplayTree tree, Node *z){    Node *y &#x3D; NULL;    Node *x &#x3D; tree;    &#x2F;&#x2F; 查找z的插入位置    while (x !&#x3D; NULL)    {        y &#x3D; x;        if (z-&gt;key &lt; x-&gt;key)            x &#x3D; x-&gt;left;        else if (z-&gt;key &gt; x-&gt;key)            x &#x3D; x-&gt;right;        else        {            printf(&quot;不允许插入相同节点(%d)!\\n&quot;, z-&gt;key);            &#x2F;&#x2F; 释放申请的节点，并返回tree。            free(z);            return tree;        }    }    if (y&#x3D;&#x3D;NULL)        tree &#x3D; z;    else if (z-&gt;key &lt; y-&gt;key)        y-&gt;left &#x3D; z;    else        y-&gt;right &#x3D; z;    return tree;}&#x2F;* * 创建并返回伸展树结点。 * * 参数说明： *     key 是键值。 *     parent 是父结点。 *     left 是左孩子。 *     right 是右孩子。 *&#x2F;static Node* create_splaytree_node(Type key, Node *left, Node* right){    Node* p;    if ((p &#x3D; (Node *)malloc(sizeof(Node))) &#x3D;&#x3D; NULL)        return NULL;    p-&gt;key &#x3D; key;    p-&gt;left &#x3D; left;    p-&gt;right &#x3D; right;    return p;}&#x2F;*  * 新建结点(key)，然后将其插入到伸展树中，并将插入节点旋转为根节点 * * 参数说明： *     tree 伸展树的根结点 *     key 插入结点的键值 * 返回值： *     根节点 *&#x2F;Node* insert_splaytree(SplayTree tree, Type key){    Node *z;    &#x2F;&#x2F; 新建结点    &#x2F;&#x2F; 如果新建结点失败，则返回。    if ((z&#x3D;create_splaytree_node(key, NULL, NULL)) &#x3D;&#x3D; NULL)        return tree;    &#x2F;&#x2F; 插入节点    tree &#x3D; splaytree_insert(tree, z);    &#x2F;&#x2F; 将节点(key)旋转为根节点    tree &#x3D; splaytree_splay(tree, key);}\n删除节点123456789101112131415161718192021222324252627282930313233343536&#x2F;*  * 删除结点(key为节点的键值)，并返回根节点。 * * 参数说明： *     tree 伸展树的根结点 *     z 删除的结点 * 返回值： *     根节点(根节点是被删除节点的前驱节点) * *&#x2F;Node* delete_splaytree(SplayTree tree, Type key){    Node *x;    if (tree &#x3D;&#x3D; NULL)         return NULL;    &#x2F;&#x2F; 查找键值为key的节点，找不到的话直接返回。    if (splaytree_search(tree, key) &#x3D;&#x3D; NULL)        return tree;    &#x2F;&#x2F; 将key对应的节点旋转为根节点。    tree &#x3D; splaytree_splay(tree, key);    if (tree-&gt;left !&#x3D; NULL)    {        &#x2F;&#x2F; 将&quot;tree的前驱节点&quot;旋转为根节点        x &#x3D; splaytree_splay(tree-&gt;left, key);        &#x2F;&#x2F; 移除tree节点        x-&gt;right &#x3D; tree-&gt;right;    }    else        x &#x3D; tree-&gt;right;    free(tree);    return x;}\n最坏情况伸展树无需记录节点高度或者平衡因子，编程上比AVL树更容易实现，分摊时间复杂度O（logN），与AVL树相当。但是无法保证单次最坏情况出现，不适用于效率敏感的场景。\n伸展树：双层伸展上面介绍的伸展树旋转是逐层上升，这里的双层伸展是向上旋转两层，节点v的位置可能性为：和AVL树的双旋一样。这样做的好处是：在最坏情况下，每一次旋转都会将树的高度将为原来高度的一半\n\n学习资料：\n\n伸展树(一)之 图文解析 和 C语言的实现\n[学堂在线]30240184X 数据结构(下)(自主模式)","url":"/2017/08/04/201708/伸展树学习笔记/","link":"","plink":"http://example.com/2017/08/04/201708/%E4%BC%B8%E5%B1%95%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"算法导论学习笔记--数据结构的扩张","content":"动态顺序统计前面介绍过 顺序统计的概念。在一个无序的集合中，任意的顺序统计量都可以在 O ( n )时间内找到。而这里我们将介绍如何在 O ( lg n )时间内确定任意的顺序统计量。还将看到如何在 O ( lg n )的时间内计算一个元素的秩,即它在集合线性序中的位置。　　下图显示的是一种支持快速顺序统计量操作的数据结构。一棵 顺序统计树 T 通过在红黑树的每个结点中存入附加信息而成。在一个结点 x 内，增加域 x.size 。该域包含以结点 x 为根的子树的（内部）结点数（包括 x 本身），即子树的大小。设 T.nil.size 为0，则有\n1x.size &#x3D; x.left.size + x.right.size + 1 \n\n查找具有给定秩的元素过程 OS-SELECT(x, i) 返回一个指向以 x 为根的子树中包含第 i 小关键字的结点的指针。为找出顺序统计树 T 中的第 i 小关键字，调用过程 OS-SELECT(T.root, i) 。\n123456789101112OS-SELECT(x, i){   r &#x3D; x.left.size + 1   if i &#x3D;&#x3D; r{       return x   }   elseif i &lt; r{       return OS-SELECT(x.left, i)   }else{       return OS-SELECT(x.right, i)   }}\n对含 n 个元素的动态集合， OS-SELECT 的运行时间为 O ( lg n )。\n确定一个元素的秩　　给定指向一顺序统计树 T 中结点 x 的指针，过程 OS-RANK 返回在对 T 进行中序遍历后得到的线性序中 x 的位置。\n123456789101112OS-RANK(T, x){    r &#x3D; x.left.size + 1   y &#x3D; x   while y !&#x3D; T.root{       if y &#x3D;&#x3D; y.p.right{            r &#x3D; r + y.p.left.size + 1       }       y &#x3D; y.p    }   return r}\nx 的秩可以视为在对树的中序遍历中，排在 x 之前的结点个数再加1（ x 本身）。在最坏情况下，对含 n 个结点的顺序统计树， OS-RANK 的运行时间为 O ( lg n )。假设我们要确定关键值为38的结点的秩时，while开始循环时，值的变化为：\n\n数据结构扩张在算法设计过程中，经常需要对基本的数据结构进行扩张，以便支持一些新功能。而对一种数据结构的扩张过程通常可以分为四个步骤：\n1234选择基础数据结构确定要在基础数据结构中添加哪些信息验证可用基础数据结构上的基本修改操作来维护这些新添加的信息设计新的操作\n以上只是给出了一个一般模式，设计顺序统计树时，我们就依照了这些步骤。","url":"/2017/08/31/201708/算法导论学习笔记数据结构的扩张/","link":"","plink":"http://example.com/2017/08/31/201708/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%89%A9%E5%BC%A0/"},{"title":"算法导论学习笔记--红黑树","content":"简介　　红黑树 是一种二叉查找树，它在每个结点上增加了一个存储位表示结点的颜色，可以是 RED 或 BLACK 。通过对任何一条从根到叶子的路径上的各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出2倍，因而是接近平衡的。　　红黑树（red-black tree）是许多“平衡的”查找树中的一种，它能保证在最坏情况下，基本的动态集合操作的时间为 O ( lg n )。　　树中每个结点包含五个域： color ， key ， left ， right 和 p 。如果某结点没有一个子结点或父结点，则该结点相应的指针为 NIL 。我们将这些 NIL 视为指向二叉查找树叶结点(外部结点)的指针，而把带关键字的结点视为树的内结点。性质： 12341、树根：必为黑色2、外部节点：均为黑色3、其余节点：若为红，则只能有黑孩子4、外部节点到根：途中黑节点数目相同　　为了便于处理红黑树代码中的边界条件，我们采用一个哨兵来代表 NIL 。对一棵红黑树来说，哨兵 T.nil 是一个与树内普通结点有相同域的对象。它的 color 域为 BLACK ，而其他域可以设为任意允许的值。如下图所示，所有指向 NIL 的指针都被替换成指向哨兵 T.nil 的指针。\n![image.png]/img/blog/2350612-2ba623c23b3600f5.png)通常我们将注意力放在红黑树的内部结点上，因为它们存储了关键字的值。因此本文其余部分都将忽略红黑树的叶子，如下图所示。\n黑高度:从某个结点 x 出发（不包括该结点）到达一个叶结点的任意一条路径上，黑色结点的个数称为该结点 x 的 黑高度 ，用bh( x )表示。因为从该结点出发的所有下降到其叶结点的简单路径的黑结点个数相同，于是红黑树的黑高度定义为其根结点的黑高度。\n1引理:一棵有 n 个内结点的红黑树的高度至多为2lg( n + 1 )。\n旋转　　　　当在含 n 个关键字的红黑树上运行时，查找树操作 TREE-INSERT 和 TREE-DELETE 的时间为 O ( lg n )。由于这两个操作对树做了修改，结果可能违反了红黑树的性质，为保持红黑树的性质，就要改变树中某些结点的颜色和指针结构。　　指针结构的修改是通过旋转来完成的，这是一种能保持二叉查找树性质的查找树局部操作。下图给出了两种旋转：左旋和右旋。旋转和前面学习过的AVL树和伸展树都一样。\n12345678910111213141516LEFT-ROTATE(T, x)    y &#x3D; x.right            &#x2F;&#x2F; set y    x.right &#x3D; y.left       &#x2F;&#x2F; turn y&#39;s left subtree into s&#39;s right subtree    if y.left !&#x3D; T.nil{         y.left.p &#x3D; x    }    y.p &#x3D; x.p    if x.p &#x3D;&#x3D; T.nil{        T.root &#x3D; y    }elseif x &#x3D;&#x3D; x.p.left{        x.p.left &#x3D; y    }else{        x.p.right &#x3D; y    }    y.left &#x3D; x             &#x2F;&#x2F; put x on y&#39;s left    x.p &#x3D; y\n下图显示了 LEFT-ROTATE 的操作过程。 RIGHT-ROTATE 的程序是对称的。它们都在 O ( 1 )时间内完成。\n\n12345678910111213141516RIGHT-ROTATE(T, x)    y &#x3D; x.left    x.left &#x3D; y.right    if y.right !&#x3D; T.nil{        y.right.p &#x3D; x    }    y.p &#x3D; x.p    if x.p &#x3D;&#x3D; T.nil{        T.root &#x3D; y    }elseif x &#x3D;&#x3D; x.p.left{        x.p.left &#x3D; y    }else{        x.p.right &#x3D; right    }    y.right &#x3D; x    x.p &#x3D; y\n插入　　向一棵含 n 个结点的红黑树 T 中插入一个新结点 z 的操作可在 O ( lg n )时间内完成。首先将结点 z 插入树 T 中，就好像 T 是一棵普通的二叉查找树一样，然后将 z 着为红色。为保证红黑性质，这里要调用一个辅助程序 RB-INSERT-FIXUP 来对结点重新着色并旋转。调用 RB-INSERT 会将 z 插入红黑树 T 内，假设 z 的 key 域已经事先被赋值。\n1234567891011121314151617181920212223RB-INSERT(T, z)    y &#x3D; T.nil    x &#x3D; T.root    &#x2F;&#x2F;x为根结点    while (x !&#x3D; T.nil){   &#x2F;&#x2F;判断是不是到达了叶子节点        y &#x3D; x                          if (z.key &lt; x.key){  &#x2F;&#x2F;判断一下要插入的值比当前结点大还是小            x &#x3D; x.left        }else{            x &#x3D; x.right                }    }    z.p &#x3D; y    &#x2F;&#x2F;将y设置为父结点    if( y &#x3D;&#x3D; T.nil){    &#x2F;&#x2F;没有结点的情况下        T.root &#x3D; z    }elseif (z.key &lt; y.key){    &#x2F;&#x2F;判断一下插入的值是父结点的左孩子还是右孩子。        y.left &#x3D; z    }else{        y.right &#x3D; z    }         z.left &#x3D; T.nil        z.right &#x3D; T.nil    z.color &#x3D; RED    RB-INSERT-FIXUP(T, z)  &#x2F;&#x2F;重新着色并旋转\n12345678910111213141516171819202122232425262728293031RB-INSERT-FIXUP(T, z)    while z.p.color &#x3D;&#x3D; RED   &#x2F;&#x2F;因为z结点为red，如果z结点的父结点也是red，表示不符合红黑树规则        if z.p &#x3D;&#x3D; z.p.p.left                              &#x2F;&#x2F; z的父结点是其父结点的左孩子            y &#x3D; z.p.p.right                               &#x2F;&#x2F; 令y为z的叔父结点            if y.color &#x3D;&#x3D; RED                z.p.color &#x3D; BLACK                         &#x2F;&#x2F; case 1                y.color &#x3D; BLACK                           &#x2F;&#x2F; case 1                z.p.p.color &#x3D; RED                         &#x2F;&#x2F; case 1                z &#x3D; z.p.p                                 &#x2F;&#x2F; case 1            else                 if z &#x3D;&#x3D; z.p.right                     z &#x3D; z.p                               &#x2F;&#x2F; case 2                     LEFT-ROTATE(T, z)                     &#x2F;&#x2F; case 2                 z.p.color &#x3D; BLACK                         &#x2F;&#x2F; case 3                 z.p.p.color &#x3D; RED                         &#x2F;&#x2F; case 3                 RIGHT-ROTATE(T, z.p.p)                    &#x2F;&#x2F; case 3         else                                              &#x2F;&#x2F; z的父结点是其父结点的右孩子             y &#x3D; z.p.p.left                                &#x2F;&#x2F; 令y为z的叔父结点             if y.color &#x3D; RED                 z.p.color &#x3D; BLACK                 y.color &#x3D; BLACK                 z.p.p.color &#x3D; RED                 z &#x3D; z.p.p             else                 if z &#x3D; z.p.left                     z &#x3D; z.p                     RIGHT-ROTATE(T, z)                 z.p.color &#x3D; BLACK                 z.p.p.color &#x3D; RED                 LEFT-ROTATE(T, z.p.p)    T.root.color &#x3D; BLACK\n下图显示了在一棵红黑树上 RB-INSERT-FIXUP 是如何操作的。\n删除　　和 n 个结点的红黑树上的其它基本操作一样，对一个结点的删除要花 O ( lg n )时间。首先，我们需要自定义一个类似于 TREE-DELETE 中调用的 TRANSPLANT 的子程序。该过程接收三个参数，红黑树 T 以及两棵子树 u ， v 。过程用子树 v 来替代子树 u 在树中的位置。\n1234567891011RB-TRANSPLANT(T, u, v){    if u.p &#x3D;&#x3D; T.nil{        T.root &#x3D; v    }elseif u &#x3D;&#x3D; u.p.left{        u.p.left &#x3D; v    }else{        u.p.right &#x3D; v    }    v.p &#x3D; u.p}\n　　过程 RB-DELETE同TREE-DELETE类似，但是多了些代码。有些代码用于跟踪记录可能破坏红黑性质的结点 y 的状态。如果待删除的结点 z 的孩子结点少于两个，那么可以直接从树中删除 z ，并让 y 等于 z 。如果待删除的结点 z 有两个孩子，令 y 为 z 的后继，并用 y 替代 z 在树中的位置。我们还要记住 y 在删除或移动之前的颜色。由于结点 x 也可能破坏树的红黑性质，我们也需要跟踪记录下这个占据了结点 y 最初位置的结点 x 的状态。删除结点 z 后，过程 RB-DELETE 还要调用 RB-DELETE-FIXUP以保持红黑性质。\n123456789101112131415161718192021222324252627282930RB-DELETE(T, z){    y &#x3D; z    y-original-color &#x3D; y.color    if z.left &#x3D;&#x3D; T.nil{   &#x2F;&#x2F;判断左子树是不是null        x &#x3D; z.right        RB-TRANSPLANT(T, z, z.right)   &#x2F;&#x2F;右子树替换z的位置    } elseif z.right &#x3D;&#x3D; T.nil{   &#x2F;&#x2F;判断右子树是不是null        x &#x3D; z.left        RB-TRANSPLANT(T, z, z.left)    &#x2F;&#x2F;左子树替换z的位置    }else{        y &#x3D; TREE-MINIMUM(z.right)  &#x2F;&#x2F;找到最小的值        y-original-color &#x3D; y.color        x &#x3D; y.right        if y.p &#x3D;&#x3D; z{   &#x2F;&#x2F;z的右结点只有一个的情况            x.p &#x3D; y        }else{            RB-TRANSPLANT(T, y, y.right)   &#x2F;&#x2F;将最小值的右孩子替换掉最小值            y.right &#x3D; z.right       &#x2F;&#x2F;将最小的值变成z的右孩子            y.right.p &#x3D; y             }        RB-TRANSPLANT(T, z, y)    &#x2F;&#x2F;z的右孩子里面的最小值替换z        y.left &#x3D; z.left        y.left.p &#x3D; y        y.color &#x3D; z.color    }     if y-original-color &#x3D;&#x3D; BLACK{    &#x2F;&#x2F;如果删除的是red结点，则不用关心颜色         RB-DELETE-FIXUP(T, x)    }}\n12345678910111213141516171819202122232425262728293031323334353637RB-DELETE-FIXUP(T, x){    while x !&#x3D; T.root and x.color &#x3D;&#x3D; BLACK{        if x &#x3D;&#x3D; x.p.left         {            w &#x3D; x.p.right            if w.color &#x3D;&#x3D; RED            {                w.color &#x3D; BLACK                                          &#x2F;&#x2F; case 1                x.p.color &#x3D; RED                                          &#x2F;&#x2F; case 1                LEFT-ROTATE(T, x.p)                                      &#x2F;&#x2F; case 1                w &#x3D; x.p.right                                            &#x2F;&#x2F; case 1            }            if w.left.color &#x3D;&#x3D; BLACK and w.right.color &#x3D;&#x3D; BLACK            {                 w.color &#x3D; RED                                            &#x2F;&#x2F; case 2                 x &#x3D; x.p                                                  &#x2F;&#x2F; case 2            } else{                 if w.right.color &#x3D;&#x3D; BLACK                  {                       w.left.color &#x3D; BLACK                                 &#x2F;&#x2F; case 3                       w.color &#x3D; RED                                        &#x2F;&#x2F; case 3                       RIGHT-ROTATE(T, w)                                   &#x2F;&#x2F; case 3                       w &#x3D; x.p.right                                        &#x2F;&#x2F; case 3                  }                 w.color &#x3D; x.p.color                                      &#x2F;&#x2F; case 4                 x.p.color &#x3D; BLACK                                        &#x2F;&#x2F; case 4                 w.right.color &#x3D; BLACK                                    &#x2F;&#x2F; case 4                 LEFT-ROTATE(T, x.p)                                      &#x2F;&#x2F; case 4                 x &#x3D; T.root                                               &#x2F;&#x2F; case 4            }         }else{              (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)         }     }     x.color &#x3D; BLACK}","url":"/2017/08/26/201708/算法导论学习笔记红黑树/","link":"","plink":"http://example.com/2017/08/26/201708/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"title":"Java使用Google-gson解析json数据","content":"首先在官网下载插件，是下载的版本是gson-2.8.2.jar，并导入到项目中，github地址为： https://github.com/google/gson\n获取json数据java解析json代码为：\n123456789JsonParser parser &#x3D; new JsonParser();JsonObject object &#x3D; (JsonObject) parser.parse(new FileReader(&quot;jsonText.json&quot;));System.out.println(&quot;name&#x3D;&quot;+object.get(&quot;name&quot;).getAsString());JsonArray links &#x3D; object.get(&quot;links&quot;).getAsJsonArray();for (int i &#x3D; 0; i &lt; links.size(); i++) {\tJsonObject element &#x3D; links.get(i).getAsJsonObject();\tSystem.out.println(&quot;name &#x3D; &quot; + element.get(&quot;name&quot;).getAsString());\tSystem.out.println(&quot;url &#x3D; &quot; + element.get(&quot;url&quot;).getAsString());}\njson数据为：\n12345678910111213141516171819202122232425{    &quot;name&quot;: &quot;BeJson&quot;,    &quot;url&quot;: &quot;http:&#x2F;&#x2F;www.bejson.com&quot;,    &quot;page&quot;: 88,    &quot;isNonProfit&quot;: true,    &quot;address&quot;: {        &quot;street&quot;: &quot;科技园路.&quot;,        &quot;city&quot;: &quot;江苏苏州&quot;,        &quot;country&quot;: &quot;中国&quot;    },    &quot;links&quot;: [        {            &quot;name&quot;: &quot;Google&quot;,            &quot;url&quot;: &quot;http:&#x2F;&#x2F;www.google.com&quot;        },        {            &quot;name&quot;: &quot;Baidu&quot;,            &quot;url&quot;: &quot;http:&#x2F;&#x2F;www.baidu.com&quot;        },        {            &quot;name&quot;: &quot;SoSo&quot;,            &quot;url&quot;: &quot;http:&#x2F;&#x2F;www.SoSo.com&quot;        }    ]}\n生成json数据代码为：\n123456789101112131415161718192021JsonObject object &#x3D; new JsonObject();object.addProperty(&quot;name&quot;, &quot;BeJson&quot;);JsonArray links &#x3D; new JsonArray();JsonObject url1 &#x3D; new JsonObject();url1.addProperty(&quot;name&quot;, &quot;Google&quot;);url1.addProperty(&quot;url&quot;, &quot;http:&#x2F;&#x2F;www.google.com&quot;);links.add(url1);JsonObject url2 &#x3D; new JsonObject();url2.addProperty(&quot;name&quot;, &quot;Baidu&quot;);url2.addProperty(&quot;url&quot;, &quot;http:&#x2F;&#x2F;www.baidu.com&quot;);links.add(url2);JsonObject url3 &#x3D; new JsonObject();url3.addProperty(&quot;name&quot;, &quot;SoSo&quot;);url3.addProperty(&quot;url&quot;, &quot;http:&#x2F;&#x2F;www.SoSo.com&quot;);links.add(url3);object.add(&quot;links&quot;, links);System.out.println(object.toString());\n生成的数据是：\n1234567891011121314151617{  &quot;name&quot;: &quot;BeJson&quot;,  &quot;links&quot;: [    {      &quot;name&quot;: &quot;Google&quot;,      &quot;url&quot;: &quot;http:&#x2F;&#x2F;www.google.com&quot;    },    {      &quot;name&quot;: &quot;Baidu&quot;,      &quot;url&quot;: &quot;http:&#x2F;&#x2F;www.baidu.com&quot;    },    {      &quot;name&quot;: &quot;SoSo&quot;,      &quot;url&quot;: &quot;http:&#x2F;&#x2F;www.SoSo.com&quot;    }  ]}","url":"/2017/09/06/201709/Java使用Googlegson解析json数据/","link":"","plink":"http://example.com/2017/09/06/201709/Java%E4%BD%BF%E7%94%A8Googlegson%E8%A7%A3%E6%9E%90json%E6%95%B0%E6%8D%AE/"},{"title":"MySQL索引","content":"索引分类索引是在mysql的存储引擎层实现，而不是在服务层实现的。所以每种存储引擎的索引都不一定相同。mysql目前有四种索引：\n12341、B-Tree索引：最常见的索引，大部分引擎都支持B树索引2、HASH索引：只有Memory引擎支持。3、R-Tree索引（空间索引）：空间索引是MyISAM的一个特殊索引类型，主要用于地理空间数据类型，使用较少。4、Full-text（全文索引）：全文索引是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从mysql5.6开始支持全文索引。\n\n索引使用场景（1）匹配全值，对索引中所有列都指定具体值，即是对索引中的所有列都有等值匹配的条件。1（2）匹配值的范围查询，对索引的值能够进行范围查找。（3）匹配最左前缀，仅仅使用索引中的最左边列进行查找。（4）仅仅对索引进行查询，当查询的列都在索引字段中时，查询效率更高。（5）匹配列前缀，仅仅使用索引中的第一列，并且只包含索引第一列的开头一部分进行查找。（6）能够实现索引匹配部分精确而其他部分进行范围匹配。（7）如果列名是索引，那么使用column_name is null 就会使用索引。\n存在索引却不能使用索引的场景（1）以%开头的LIKE查询不能够利用B-Tree索引，执行计划中key的值为NULL表示没有使用索引。一般推荐使用全文索引来解决类似的全文索引问题。（2）数据类型出现隐式替换的时候不会使用索引，特别是当列类型是字符串，那么一定在where条件中把字符常量值用引号引起来，否则即便这个列上有索引，MySQL也不会用到。（3）复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则Leftmost，是不会使用复合索引的。（4）如果MySQL估计使用索引比全表扫描更慢，则不使用索引。（5）用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\n查看索引使用情况1show STATUS LIKE &#39;Handler_read%&#39;\n如果索引正在使用，Handler_read_key 的值将会很高，这个值表示一行被索引值读取的次数。Handler_read_rnd_next的值高表示查询运行低效，应该建立索引补救，这个值表示数据文件中读取下一行的请求数。\n1234567891011121314+--------------------------+-------+| Variable_name            | Value |+--------------------------+-------+| Handler_read_first       | 0     || Handler_read_key         | 0     || Handler_read_last        | 0     || Handler_read_next        | 0     || Handler_read_prev        | 0     || Handler_read_retry       | 0     || Handler_read_rnd         | 0     || Handler_read_rnd_deleted | 0     || Handler_read_rnd_next    | 0     |+--------------------------+-------+9 rows in set (0.00 sec)\n参考资料：《深入浅出MySQL–数据库开发、优化和管理维护》（第2版）","url":"/2017/09/01/201709/MySQL索引/","link":"","plink":"http://example.com/2017/09/01/201709/MySQL%E7%B4%A2%E5%BC%95/"},{"title":"Java并发学习--Copy-On-Write容器","content":"介绍　　JDK1.5开始Java并发包提供了两个基于Copy-On-Write实现的并发容器，CopyOnWriteArrayList和CopyOnWriteArraySet。　　“写入时复制（Copy-On-Write）”容器线程安全性在于，只要正确地发布一个事实不可变的对象，那么在访问该对象时就不再需要进一步同步。每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。每次修改容器都会复制底层数组，这需要一定的开销，特别是当容器规模较大时。因此，仅当迭代操作远远多于修改操作时，才应该使用Copy-On-Write容器。\nCopyOnWriteArrayListadd123456789101112131415161718192021222324252627282930313233&#x2F;** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) *&#x2F;public boolean add(E e) {    final ReentrantLock lock &#x3D; this.lock;    lock.lock();    try {        Object[] elements &#x3D; getArray();   &#x2F;&#x2F;得到数组        int len &#x3D; elements.length;          Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);  &#x2F;&#x2F;复制数组        newElements[len] &#x3D; e;   &#x2F;&#x2F;添加新值        setArray(newElements); &#x2F;&#x2F;将这个数组替换        return true;    } finally {        lock.unlock();    }}&#x2F;** * Gets the array.  Non-private so as to also be accessible * from CopyOnWriteArraySet class. *&#x2F;final Object[] getArray() {    return array;}&#x2F;** * Sets the array. *&#x2F;final void setArray(Object[] a) {    array &#x3D; a;}\n学习资料：[1] BrianGoetz, 戈茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012.[2] 聊聊并发-Java中的Copy-On-Write容器","url":"/2017/11/30/201711/Java并发学习CopyOnWrite容器/","link":"","plink":"http://example.com/2017/11/30/201711/Java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0CopyOnWrite%E5%AE%B9%E5%99%A8/"},{"title":"Java并发学习--信号量 (Semaphore)","content":"Semaphore 是一个计数信号量。信号量维护了一个许可的数量。在请求许可可用前会阻塞每一个acquire()，获取许可后并使用完之后调用release()归还许可证。还可以用tryAcquire()方法尝试获取许可证。\n12345678910111213141516171819202122232425262728293031import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class SemaphoreTest {\tprivate static final int THREAD_COUNT &#x3D; 30;    &#x2F;&#x2F;定义30个线程数量\tprivate static ExecutorService threadPool &#x3D; Executors\t\t\t.newFixedThreadPool(THREAD_COUNT); &#x2F;&#x2F;线程池\tprivate static Semaphore s &#x3D; new Semaphore(10);   &#x2F;&#x2F;10个信号量\tpublic static void main(String[] args) {\t\tfor (int i &#x3D; 0; i &lt; THREAD_COUNT; i++) {\t\t\tthreadPool.execute(new Runnable() {\t\t\t\t@Override\t\t\t\tpublic void run() {\t\t\t\t\ttry {\t\t\t\t\t\ts.acquire();\t\t\t\t\t\tSystem.out.println(&quot;save data&quot;);\t\t\t\t\t\ts.release();\t\t\t\t\t} catch (InterruptedException e) {\t\t\t\t\t}\t\t\t\t}\t\t\t});\t\t}\t\tthreadPool.shutdown();\t}}\n在代码中，虽然有30个线程在执行，但是只允许10个并发的执行。\n学习资料：[1] BrianGoetz, 戈茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012.[2] 并发工具类（三）控制并发线程数的Semaphore","url":"/2017/11/18/201711/Java并发学习信号量Semaphore/","link":"","plink":"http://example.com/2017/11/18/201711/Java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/"},{"title":"Java并发学习--原子操作类Atomic","content":"Java从JDK 1.5开始提供了java.util.concurrent.atomic包，Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。\n1234567891011121314151617原子更新基本类型：　　AtomicBoolean：原子更新布尔类型。　　AtomicInteger：原子更新整型。　　AtomicLong：原子更新长整型。原子更新数组：　　AtomicIntegerArray：原子更新整型数组里的元素。　　AtomicLongArray：原子更新长整型数组里的元素。　　AtomicReferenceArray：原子更新引用类型数组里的元素。　　AtomicIntegerArray类主要是提供原子的方式更新数组里的整型原子更新引用：　　AtomicReference：原子更新引用类型。　　AtomicReferenceFieldUpdater：原子更新引用类型里的字段。　　AtomicMarkableReference：原子更新带有标记位的引用类型。原子更新属性（字段）：　　AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。　　AtomicLongFieldUpdater：原子更新长整型字段的更新器。　　AtomicStampedReference：原子更新带有版本号的引用类型。\n原子更新基本类型基本用法三个类提供的方法几乎类似，这里以AtomicInteger为例介绍用法：\n\nint addAndGet（int delta）：将给定的值原子地添加到当前值（增加并添加）。\n\nboolean compareAndSet（int expect，int update）：如果当前值 == 为预期值，则将该值原子设置为给定的更新值。 \n\nint getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。\n\nint incrementAndGet()：以原子方式将当前值加1，注意，这里返回的是自增后的值。\n12345678910111213141516&#x2F;** * Atomically increments by one the current value. * * @return the updated value *&#x2F;public final int incrementAndGet() {    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;}&#x2F;** * Atomically increments by one the current value. * * @return the previous value *&#x2F;public final int getAndIncrement() {    return unsafe.getAndAddInt(this, valueOffset, 1);}\nint getAndSet（int newValue）：将原子设置为给定值并返回旧值。 \n\nvoid lazySet(int newValue) : 最终设定为给定值。 延时设置变量值(也就是说其他线程在一段时间内读取的还是旧值)，等价于set()方法。\nCAS方法Unsafe提供了三种CAS方法：\n123public final native boolean compareAndSwapObject(Object o,long offset,Object expected,Object x);public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x);\n其中AtomicBoolean类的compareAndSet方法是将值转换成int型，再通过compareAndSwapInt进行CAS\n1234567891011121314&#x2F;** * Atomically sets the value to the given updated value * if the current value {@code &#x3D;&#x3D;} the expected value. * * @param expect the expected value * @param update the new value * @return {@code true} if successful. False return indicates that * the actual value was not equal to the expected value. *&#x2F;public final boolean compareAndSet(boolean expect, boolean update) {    int e &#x3D; expect ? 1 : 0;    int u &#x3D; update ? 1 : 0;    return unsafe.compareAndSwapInt(this, valueOffset, e, u);}\n原子更新数组基本用法以AtomicIntegerArray为例，AtomicIntegerArray提供了一个原子访问数据中元素方法的一种途径。AtomicIntegerArray本质上是对int[]类型的封装。使用Unsafe类通过CAS的方式控制int[]在多线程下的安全性。它提供了以下几个核心API：  \n\nint get(int i)  //获得数组第i个下标的元素  \n\nint length()    //获得数组的长度  \n\nint getAndSet(int i, int newValue)  //将数组第i个下标设置为newValue，并返回旧的值  \n\nboolean compareAndSet(int i, int expect, intupdate)  //进行CAS操作，如果第i个下标的元素等于expect，则设置为update，设置成功返回true  \n\nint getAndIncrement(int i)  //将第i个下标的元素加1  \n\nint getAndDecrement(int i)  //将第i个下标的元素减1  \n\nint getAndAdd(int i, int delta)  //以原子的方式将第i个下标的元素增加delta（delta可以是负数）  \n\n\n原子更新引用使用原子更新引用类型提供的类可以更新多个变量。假设存在一个Person 类\n1234567891011121314151617181920212223242526272829class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name &#x3D; name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age &#x3D; age;    }    public String toString() {        return &quot;[name: &quot; + this.name + &quot;, age: &quot; + this.age + &quot;]&quot;;    }}\n当多线程环境下，对象的更新可能会导致不一致性。因此可以使用AtomicReference类提供的方法。\n123456789101112public class AtomicReferenceTest {    public static AtomicReference&lt;Person&gt; atomicUserRef &#x3D; new        AtomicReference&lt;Person&gt;();    public static void main(String[] args) {        Person user &#x3D; new Person(&quot;tom&quot;， 15);        atomicUserRef.set(user);        Person updateUser &#x3D; new Person(&quot;tom2&quot;， 17);        atomicUserRef.compareAndSet(user， updateUser);        System.out.println(atomicUserRef.get().getName());        System.out.println(atomicUserRef.get().getAge());    }}\n原子更新属性（1）字段必须是volatile类型的，在线程之间共享变量时保证立即可见（2）字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的关系一致。（3）不能加static关键字，只能是实例变量，不能是类变量。（4）对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。\n123456789101112131415161718192021import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;      public class AtomicReferenceFieldUpdaterTest{      public static void main(String[] args) throws Exception      {          AtomicReferenceFieldUpdater&lt;Person, String&gt; updater&#x3D;AtomicReferenceFieldUpdater.newUpdater(Person.class,String.class,&quot;name&quot;);          Person person&#x3D;new Person();          updater.compareAndSet(person,person.name,&quot;test&quot;) ;          System.out.println(person.name);      }  }   class Person  {       volatile  String name &#x3D; &quot;Tom&quot;;  }  &#x2F;*test*&#x2F;\n学习资料：[1] BrianGoetz, 戈茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012.[2] Java中的Atomic包使用指南","url":"/2017/11/11/201711/Java并发学习原子操作类Atomic/","link":"","plink":"http://example.com/2017/11/11/201711/Java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BBAtomic/"},{"title":"Java并发学习--同步屏障CyclicBarrier","content":"CyclicBarrier和CountDownLatch一样，都是关于线程的计数器。CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。比如以下代码执行完之后会返回true。\n12345678910111213141516171819202122232425262728import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest {\tstatic CyclicBarrier c &#x3D; new CyclicBarrier(2);&#x2F;&#x2F;如果这里设置成3，则代码将一直等待下去，因为没有第三个线程执行。\tpublic static void main(String[] args) {\t\tnew Thread(new Runnable() {\t\t\t@Override\t\t\tpublic void run() {\t\t\t\ttry {\t\t\t\t\tc.await();\t\t\t\t} catch (Exception e) {\t\t\t\t}\t\t\t\tSystem.out.println(1);\t\t\t}\t\t}).start();\t\ttry {\t\t\tc.await();\t\t} catch (Exception e) {\t\t}\t\tSystem.out.println(2);\t}}\n学习资料：[1] BrianGoetz, 戈茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012.[2] 并发工具类（二）同步屏障CyclicBarrier","url":"/2017/11/26/201711/Java并发学习同步屏障CyclicBarrier/","link":"","plink":"http://example.com/2017/11/26/201711/Java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9CCyclicBarrier/"},{"title":"Java并发学习--线程间数据交换Exchanger","content":"Exchanger用于进行线程间的数据交换，允许原子性的交换两个（多个）对象，但同时只有一对才会成功。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ExchangerTest {\tprivate static final Exchanger&lt;String&gt; exgr &#x3D; new Exchanger&lt;String&gt;();\tprivate static ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(2);\tpublic static void main(String[] args) {\t\tthreadPool.execute(new Runnable() {\t\t\t@Override\t\t\tpublic void run() {\t\t\t\ttry {\t\t\t\t\tString A &#x3D; &quot;银行流水A&quot;;&#x2F;&#x2F; A录入银行流水数据\t\t\t\t\tString B &#x3D; exgr.exchange(A);\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;接收到的B的值是&quot;+B);\t\t\t\t} catch (InterruptedException e) {\t\t\t\t}\t\t\t}\t\t});\t\tthreadPool.execute(new Runnable() {\t\t\t@Override\t\t\tpublic void run() {\t\t\t\ttry {\t\t\t\t\tString B &#x3D; &quot;银行流水B&quot;;&#x2F;&#x2F; B录入银行流水数据\t\t\t\t\tString A &#x3D; exgr.exchange(B);\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;接收到的A的值是&quot;+A);\t\t\t\t} catch (InterruptedException e) {\t\t\t\t}\t\t\t}\t\t});\t\tthreadPool.shutdown();\t}}&#x2F;*pool-1-thread-1接收到的B的值是银行流水Bpool-1-thread-2接收到的A的值是银行流水A*&#x2F;\n学习资料：[1] BrianGoetz, 戈茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012.[2] 并发工具类（四）两个线程进行数据交换的Exchanger","url":"/2017/11/28/201711/Java并发学习线程间数据交换Exchanger/","link":"","plink":"http://example.com/2017/11/28/201711/Java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2Exchanger/"},{"title":"Java并发学习--读写锁ReentrantReadWriteLock","content":"简介使用synchronized可以实现同步，但是缺点是同时只有一个线程可以访问共享变量。在大多数情况下，读进程与读进程之间是不存在互斥关系，只有读进程与写进程、写进程与写进程之间才需要互斥操作。synchronized每次只允许一个进程访问，无法实现多个读线程同时执行，而大部分情况下读操作次数多于写操作，这大大降低了并发性，因此引入ReentrantReadWriteLock，它的特性是：一个资源可以被多个读操作访问，或者一个写操作访问，但两者不能同时进行。\n1234567线程进入读锁的前提条件：    没有其他线程的写锁，    没有写请求或者有写请求，但调用线程和持有锁的线程是同一个线程进入写锁的前提条件：    没有其他线程的读锁    没有其他线程的写锁\nReentrantReadWriteLock并没有继承ReentrantLock，也并没有实现Lock接口，而是实现了ReadWriteLock接口，该接口提供readLock()方法获取读锁，writeLock()获取写锁。\n123456789public class ReentrantReadWriteLock        implements ReadWriteLock, java.io.Serializable {    private static final long serialVersionUID &#x3D; -6992448646407690164L;    &#x2F;** Inner class providing readlock *&#x2F;    private final ReentrantReadWriteLock.ReadLock readerLock;    &#x2F;** Inner class providing writelock *&#x2F;    private final ReentrantReadWriteLock.WriteLock writerLock;    &#x2F;** Performs all synchronization mechanics *&#x2F;    final Sync sync;\n例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.Random;import java.util.concurrent.locks.ReentrantReadWriteLock;public class ReadWriteLockTest {    public static void main(String[] args) {        final Queue3 q3 &#x3D; new Queue3();        for(int i&#x3D;0;i&lt;3;i++)        {            new Thread(){                public void run(){                    while(true){                        q3.get();                                            }                }                            }.start();        }        for(int i&#x3D;0;i&lt;3;i++)        {                    new Thread(){                public void run(){                    while(true){                        q3.put(new Random().nextInt(10000));                    }                }                                        }.start();            }    }}                                                                                                                              class Queue3{    private Object data &#x3D; null;&#x2F;&#x2F;共享数据，只能有一个线程能写该数据，但可以有多个线程同时读该数据。    private ReentrantReadWriteLock rwl &#x3D; new ReentrantReadWriteLock();    public void get(){        rwl.readLock().lock();&#x2F;&#x2F;上读锁，其他线程只能读不能写        System.out.println(Thread.currentThread().getName() + &quot; 开始读取数据！&quot;);        try {            Thread.sleep((long)(Math.random()*1000));        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot;读到数据 :&quot; + data);                rwl.readLock().unlock(); &#x2F;&#x2F;释放读锁，最好放在finnaly里面    }        public void put(Object data){        rwl.writeLock().lock();&#x2F;&#x2F;上写锁，不允许其他线程读也不允许写        System.out.println(Thread.currentThread().getName() + &quot; 开始写入数据!&quot;);                            try {            Thread.sleep((long)(Math.random()*1000));        } catch (InterruptedException e) {            e.printStackTrace();        }        this.data &#x3D; data;                System.out.println(Thread.currentThread().getName() + &quot; 写入了数据: &quot; + data);                                    rwl.writeLock().unlock();&#x2F;&#x2F;释放写锁        }}&#x2F;*Thread-1 开始读取数据！Thread-2 开始读取数据！Thread-0 开始读取数据！Thread-1读到数据 :nullThread-2读到数据 :nullThread-0读到数据 :nullThread-5 开始写入数据!Thread-5 写入了数据: 1050Thread-5 开始写入数据!Thread-5 写入了数据: 9298Thread-3 开始写入数据!Thread-3 写入了数据: 7597Thread-3 开始写入数据!Thread-3 写入了数据: 5022Thread-3 开始写入数据!Thread-3 写入了数据: 8640Thread-3 开始写入数据!Thread-3 写入了数据: 2022Thread-4 开始写入数据!Thread-4 写入了数据: 3460Thread-4 开始写入数据!Thread-4 写入了数据: 9046Thread-4 开始写入数据!Thread-4 写入了数据: 8768Thread-4 开始写入数据!Thread-4 写入了数据: 579Thread-4 开始写入数据!Thread-4 写入了数据: 203*&#x2F;\n学习资料：[1] BrianGoetz, 戈茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012.","url":"/2017/11/13/201711/Java并发学习读写锁ReentrantReadWriteLock/","link":"","plink":"http://example.com/2017/11/13/201711/Java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/"},{"title":"Java并发学习--重入锁ReentrantLock","content":"简介　　在Java5.0之前，在协调对共享对象的访问时可以使用的机制只有Synchronized和volatile。Java5.0增加了一个新的机制ReentrantLock。ReentrantLock是一个可重入的互斥锁。　　Synchronized有一些功能性的限制，Synchronized无法中断一个正在等候获得锁的线程，也无法通过投票得到锁，如果不想等下去，也就没法得到锁。 ReentrantLock 类实现了Lock，它拥有与synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。　　下面的代码提供了一种标准的Lock接口使用方式，注意一定要在finally块中释放锁。否则，如果在 被保护的代码中抛出了异常，那么锁将永远不会释放。这也是ReentrantLock无法完全代替Synchronized的原因，ReentrantLock更加危险。\n1234567891011121314import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class lockTest {\tpublic static void main(String[] args) {\t\tLock lock &#x3D; new ReentrantLock();  \t\tlock.lock();  \t\ttry {   \t\t  &#x2F;&#x2F; update object state  \t\t}  \t\tfinally {  \t\t  lock.unlock();   \t\t}  \t}}\n轮询锁与定时锁　　轮询锁与定时锁的获取模式是由tryLock方法实现的，具有更完善的错误恢复机制，可以避免死锁的发生。如果不能获取所有需要的锁，那么可以使用可定时的或者可轮询的锁获取方式，从而使你重新获取控制权，它会释放已经获得的锁，然后重新尝试获取所有的锁。\n公平性　　ReentrantLock的构造函数中提供了两种公平性选择：创建一个非公平的锁（默认）或者一个公平的锁。在公平的锁上，线程将按照它们发出的请求顺序来获得锁，但在非公平锁上，运行“插队”：当一个线程请求非公平锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有等待的线程，并获得这个锁。\n学习资料：[1] BrianGoetz, 戈茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012.","url":"/2017/11/16/201711/Java并发学习重入锁ReentrantLock/","link":"","plink":"http://example.com/2017/11/16/201711/Java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock/"},{"title":"Java并发学习--闭锁CountDownLatch","content":"CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。CountDownLatch有一个正数计数器，countDown方法对计数器做减操作，await方法等待计数器达到0。所有await的线程都会阻塞直到计数器为0或者等待线程中断或者超时。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.CountDownLatch;public class CountDownLatchTest {\tpublic static void main(String[] args) {           final CountDownLatch latch &#x3D; new CountDownLatch(2);   &#x2F;&#x2F;等待两个点完成        new Thread(){            public void run() {                try {                   System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);                   Thread.sleep(3000);                   System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);                   latch.countDown();               } catch (InterruptedException e) {                   e.printStackTrace();               }            };        }.start();        new Thread(){            public void run() {                try {                    System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);                    Thread.sleep(3000);                    System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);                    latch.countDown();               } catch (InterruptedException e) {                   e.printStackTrace();               }            };        }.start();        try {            System.out.println(&quot;等待2个子线程执行完毕...&quot;);\t\t\tlatch.await();\t\t\tSystem.out.println(&quot;2个子线程已经执行完毕&quot;);\t\t\tSystem.out.println(&quot;继续执行主线程&quot;);       } catch (InterruptedException e) {           e.printStackTrace();       }    }}\n学习资料：[1] BrianGoetz, 戈茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012.","url":"/2017/11/22/201711/Java并发学习闭锁CountDownLatch/","link":"","plink":"http://example.com/2017/11/22/201711/Java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E9%97%AD%E9%94%81CountDownLatch/"},{"title":"《Redis设计与实现》：双端链表","content":"简介链表在Redis中应用广泛，比如列表键的底层实现之一就是链表。当列表键包含了比较多元素，或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。（其余情况使用ziplist压缩列表）\n链表实现每个链表的节点使用adlist.h中的listNode来表示：\n1234567891011&#x2F;* * 双端链表节点 *&#x2F;typedef struct listNode {    &#x2F;&#x2F; 前置节点    struct listNode *prev;    &#x2F;&#x2F; 后置节点    struct listNode *next;    &#x2F;&#x2F; 节点的值    void *value;} listNode;\n使用adlist.h中的list持有整个链表：\n1234567891011121314151617&#x2F;* * 双端链表结构 *&#x2F;typedef struct list {    &#x2F;&#x2F; 表头节点    listNode *head;    &#x2F;&#x2F; 表尾节点    listNode *tail;    &#x2F;&#x2F; 节点值复制函数，用于复制链表节点所保存的值    void *(*dup)(void *ptr);    &#x2F;&#x2F; 节点值释放函数，用于释放链表节点所保存的值    void (*free)(void *ptr);    &#x2F;&#x2F; 节点值对比函数，用于对比链表节点所保存的值与另一个输入值是否相等    int (*match)(void *ptr, void *key);    &#x2F;&#x2F; 链表所包含的节点数量    unsigned long len;} list;\n\n表头节点prev和表尾节点next都指向NULL，对链表的访问以NULL为终点。\n\n链表API\n\n\n函数\n作用\n时间复杂度\n\n\n\nlistSetDupMethod\n将给定的函数设置为链表的节点值复制函数。\nO(1)\n\n\nlistGetDupMethod\n返回链表当前正在使用的节点值复制函数。\n复制函数可以通过链表的 dup 属性直接获得，  O(1)\n\n\nlistSetFreeMethod\n将给定的函数设置为链表的节点值释放函数。\nO(1)\n\n\nlistGetFree\n返回链表当前正在使用的节点值释放函数。\n释放函数可以通过链表的 free 属性直接获得， O(1)\n\n\nlistSetMatchMethod\n将给定的函数设置为链表的节点值对比函数。\nO(1)\n\n\nlistGetMatchMethod\n返回链表当前正在使用的节点值对比函数。\n对比函数可以通过链表的 match 属性直接获得， O(1)\n\n\nlistLength\n返回链表的长度（包含了多少个节点）。\n链表长度可以通过链表的 len 属性直接获得， O(1)\n\n\nlistFirst\n返回链表的表头节点。\n表头节点可以通过链表的 head 属性直接获得， O(1)\n\n\nlistLast\n返回链表的表尾节点。\n表尾节点可以通过链表的 tail 属性直接获得， O(1)\n\n\nlistPrevNode\n返回给定节点的前置节点。\n前置节点可以通过节点的 prev 属性直接获得， O(1)\n\n\nlistNextNode\n返回给定节点的后置节点。\n后置节点可以通过节点的 next 属性直接获得， O(1)\n\n\nlistNodeValue\n返回给定节点目前正在保存的值。\n节点值可以通过节点的 value 属性直接获得， O(1)\n\n\nlistCreate\n创建一个不包含任何节点的新链表。\nO(1)\n\n\nlistAddNodeHead\n将一个包含给定值的新节点添加到给定链表的表头。\nO(1)\n\n\nlistAddNodeTail\n将一个包含给定值的新节点添加到给定链表的表尾。\nO(1)\n\n\nlistInsertNode\n将一个包含给定值的新节点添加到给定节点的之前或者之后。\nO(1)\n\n\nlistSearchKey\n查找并返回链表中包含给定值的节点。\nO(N) ， N 为链表长度\n\n\nlistIndex\n返回链表在给定索引上的节点。\nO(N) ， N 为链表长度\n\n\nlistDelNode\n从链表中删除给定节点。\nO(1)\n\n\nlistRotate\n将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头， 成为新的表头节点。\nO(1)\n\n\nlistDup\n复制一个给定链表的副本。\nO(N) ， N 为链表长度\n\n\nlistRelease\n释放给定链表，以及链表中的所有节点。\nO(N) ， N 为链表长度\n\n\n学习资料：[1] 黄健宏. Redis设计与实现[M]. 机械工业出版社, 2014.","url":"/2018/03/21/201803/Redis设计与实现双端链表/","link":"","plink":"http://example.com/2018/03/21/201803/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8/"},{"title":"《Redis设计与实现》：简单动态字符串","content":"简介Redis构建了一种名为简单动态字符串（simple dynamic string ，SDS）的抽象类型，用来保存字符串。\nSDS 实现shs.h文件中sdshdr结构体表示了一个SDS的值：\n12345678struct sdshdr {    &#x2F;&#x2F; buf 中已占用空间的长度      int len;    &#x2F;&#x2F; buf 中剩余可用空间的长度    int free;    &#x2F;&#x2F; 数据空间    char buf[];};\n\n\nSDS和C字符串一样，使用空字符结尾，保存空字符串的1字节空间不包含在SDS的len属性里面，因此需要分配N+1个字节空间来保存数据。\nlen属性表示SDS保存字符串的长度，不包含字符串结尾的空字符串。\nfree属性表示数组中未使用的字节数量\nbuf属性是char类型的数组，用来保存SDS字符串数据。SDS 特点常数复杂度获取字符串长度在更新和添加字符串到SDS的过程中，SDS的API会自动更新SDS的len属性，不需要手动更改，因此获取字符串长度的时间复杂度是O(1)。12345678910&#x2F;* * 返回 sds 实际保存的字符串的长度 * * T &#x3D; O(1) *&#x2F;static inline size_t sdslen(const sds s) {    &#x2F;&#x2F;&#x2F;&#x2F; 取出 sdshdr    struct sdshdr *sh &#x3D; (void*)(s-(sizeof(struct sdshdr)));    return sh-&gt;len;}\n防止缓存区溢出C字符串不记录自身的长度，容易发生缓冲区溢出。SDS的free属性记录数组中未使用的字节数量，SDS的API操作SDS会首先检查剩余空间是否满足要求，所以不会发生缓冲区溢出的情况。内容重分配策略空间预分配需要对SDS进行空间扩展时，程序不仅会为SDS分配所必须的空间，还会分配额外未使用的空间。\n对SDS修改之后，SDS的长度小于1MB，那么程序分配和len属性同样大小的空间，假设修改后SDS的大小是13字节，那么将分配13+13+1=27个字节。\n如果对SDS修改之后，SDS的长度大于等于1MB，将分配1M未使用空间。假设修改后SDS的长度是30MB，那么程序会分配1MB未使用空间，实际大小为：30MB+1MB+1byte.12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#x2F;* * 最大预分配长度 *&#x2F;#define SDS_MAX_PREALLOC (1024*1024)&#x2F;* * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后， * buf 至少会有 addlen + 1 长度的空余空间 * （额外的 1 字节是为 \\0 准备的） * * 返回值 *  sds ：扩展成功返回扩展后的 sds *        扩展失败返回 NULL * * 复杂度 *  T &#x3D; O(N) *&#x2F;sds sdsMakeRoomFor(sds s, size_t addlen) {    struct sdshdr *sh, *newsh;    &#x2F;&#x2F; 获取 s 目前的空余空间长度    size_t free &#x3D; sdsavail(s);    size_t len, newlen;    &#x2F;&#x2F; s 目前的空余空间已经足够，无须再进行扩展，直接返回    if (free &gt;&#x3D; addlen) return s;    &#x2F;&#x2F; 获取 s 目前已占用空间的长度    len &#x3D; sdslen(s);    sh &#x3D; (void*) (s-(sizeof(struct sdshdr)));    &#x2F;&#x2F; s 最少需要的长度    newlen &#x3D; (len+addlen);    &#x2F;&#x2F; 根据新长度，为 s 分配新空间所需的大小    &#x2F;&#x2F;判断分配后的总长度是否小于1MB    if (newlen &lt; SDS_MAX_PREALLOC)        &#x2F;&#x2F; 如果新长度小于 SDS_MAX_PREALLOC         &#x2F;&#x2F; 那么为它分配两倍于所需长度的空间        newlen *&#x3D; 2;    else        &#x2F;&#x2F; 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC        newlen +&#x3D; SDS_MAX_PREALLOC;    &#x2F;&#x2F; T &#x3D; O(N)    newsh &#x3D; zrealloc(sh, sizeof(struct sdshdr)+newlen+1);    &#x2F;&#x2F; 内存不足，分配失败，返回    if (newsh &#x3D;&#x3D; NULL) return NULL;    &#x2F;&#x2F; 更新 sds 的空余长度    newsh-&gt;free &#x3D; newlen - len;    &#x2F;&#x2F; 返回 sds    return newsh-&gt;buf;}\n惰性空间释放惰性空间释放是指不通过内存重分配回收缩短后多出来的字节，而是通过改变free属性，惰性的释放空间。下面的代码就是在不释放空间的情况下，重置SDS字符串为空字符串，也就是惰性空间释放：1234567891011121314151617181920212223&#x2F;* * 在不释放 SDS 的字符串空间的情况下， * 重置 SDS 所保存的字符串为空字符串。 * * 复杂度 *  T &#x3D; O(1) *&#x2F;&#x2F;* Modify an sds string on-place to make it empty (zero length). * However all the existing buffer is not discarded but set as free space * so that next append operations will not require allocations up to the * number of bytes previously available. *&#x2F;void sdsclear(sds s) {    &#x2F;&#x2F; 取出 sdshdr    struct sdshdr *sh &#x3D; (void*) (s-(sizeof(struct sdshdr)));    &#x2F;&#x2F; 重新计算属性    sh-&gt;free +&#x3D; sh-&gt;len;    sh-&gt;len &#x3D; 0;    &#x2F;&#x2F; 将结束符放到最前面（相当于惰性地删除 buf 中的内容）    sh-&gt;buf[0] &#x3D; &#39;\\0&#39;;}\n二进制安全C字符串除了字符串的未尾之外，字符串里面不能包含空字符，否则最先被程序读入的空间将被误认为是字符串结尾，这些限制了C字符串只能保存文本数，不能保存图片等二进制数据。SDS没有这种限制,可以保存文本或者二进制数据SDS API\n\n\n函数\n作用\n算法复杂度\n\n\n\nsdsnewlen\n创建一个指定长度的 sds ，接受一个 C 字符串作为初始化值\n(O(N))\n\n\nsdsempty\n创建一个只包含空白字符串 “” 的 sds\n(O(1))\n\n\nsdsnew\n根据给定 C 字符串，创建一个相应的 sds\n(O(N))\n\n\nsdsdup\n复制给定 sds\n(O(N))\n\n\nsdsfree\n释放给定 sds\n(O(N))\n\n\nsdsupdatelen\n更新给定 sds 所对应 sdshdr 结构的 free 和 len\n(O(N))\n\n\nsdsclear\n清除给定 sds 的内容，将它初始化为 “”\n(O(1))\n\n\nsdsMakeRoomFor\n对 sds 所对应 sdshdr 结构的 buf 进行扩展\n(O(N))\n\n\nsdsRemoveFreeSpace\n在不改动 buf 的情况下，将 buf 内多余的空间释放出去\n(O(N))\n\n\nsdsAllocSize\n计算给定 sds 的 buf 所占用的内存总数\n(O(1))\n\n\nsdsIncrLen\n对 sds 的 buf 的右端进行扩展（expand）或修剪（trim）\n(O(1))\n\n\nsdsgrowzero\n将给定 sds 的 buf 扩展至指定长度，无内容的部分用 \\0 来填充\n(O(N))\n\n\nsdscatlen\n按给定长度对 sds 进行扩展，并将一个 C 字符串追加到 sds 的末尾\n(O(N))\n\n\nsdscat\n将一个 C 字符串追加到 sds 末尾\n(O(N))\n\n\nsdscatsds\n将一个 sds 追加到另一个 sds 末尾\n(O(N))\n\n\nsdscpylen\n将一个 C 字符串的部分内容复制到另一个 sds 中，需要时对 sds 进行扩展\n(O(N))\n\n\nsdscpy\n将一个 C 字符串复制到 sds\n(O(N))\n\n\n\n\n学习资料：[1] 黄健宏. Redis设计与实现[M]. 机械工业出版社, 2014.","url":"/2018/03/19/201803/Redis设计与实现简单动态字符串/","link":"","plink":"http://example.com/2018/03/19/201803/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"Java源码分析--ArrayList","content":"介绍ArrayList是一个动态数组，可以动态增长。ArrayList不是线程安全的，因此不建议在多线程中使用，可以选择Vector或者CopyOnWriteArrayList。\n源码定义123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{\nArrayList继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable接口。\n成员变量1234567891011121314private static final long serialVersionUID &#x3D; 8683452581122892189L;&#x2F;&#x2F;默认的初始容量private static final int DEFAULT_CAPACITY &#x3D; 10;&#x2F;&#x2F;空对象数组private static final Object[] EMPTY_ELEMENTDATA &#x3D; {};&#x2F;&#x2F;默认容量的空对象数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; {};&#x2F;&#x2F;存储对象的数组transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access&#x2F;&#x2F;实际存储的数量private int size;&#x2F;&#x2F;数组最大数量private static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;\n构造方法123public ArrayList() {    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}\n无参数的构造函数。调用无参数的构造函数，elementData指向DEFAULTCAPACITY_EMPTY_ELEMENTDATA。\n1234567891011public ArrayList(int initialCapacity) {    &#x2F;&#x2F;    if (initialCapacity &gt; 0) {        this.elementData &#x3D; new Object[initialCapacity];    } else if (initialCapacity &#x3D;&#x3D; 0) {        this.elementData &#x3D; EMPTY_ELEMENTDATA;    } else {        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    }}\n指定参数的构造函数。默认三种情况：当参数大于0，则直接初始化相同大小的对象数组；当参数等于0，用EMPTY_ELEMENTDATA初始化elementData；当参数小于0，抛出异常。\n123456789public ArrayList(Collection&lt;? extends E&gt; c) {    elementData &#x3D; c.toArray();    if ((size &#x3D; elementData.length) !&#x3D; 0) {        if (elementData.getClass() !&#x3D; Object[].class)            elementData &#x3D; Arrays.copyOf(elementData, size, Object[].class);    } else {        this.elementData &#x3D; EMPTY_ELEMENTDATA;    }}\nCollection作为参数的构造函数。直接将Collection转化为数组复制给elementData，当c.toArray不返回Object[]，进行数组拷贝。如果Collection为空，将EMPTY_ELEMENTDATA赋给elementData。\nadd1、add(E e)\n12345public boolean add(E e) {    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!    elementData[size++] &#x3D; e;    return true;}\n看一下ensureCapacityInternal()函数：\n1234&#x2F;&#x2F;minCapacity为对象数组所需的最小空间值private void ensureCapacityInternal(int minCapacity) {    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));}\n123456private static int calculateCapacity(Object[] elementData, int minCapacity) {    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        return Math.max(DEFAULT_CAPACITY, minCapacity);    }    return minCapacity;}\ncalculateCapacity()判断elementData是否为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，如果是则返回DEFAULT_CAPACITY和minCapacity中最大的值（其实这里可以理解为调用无参构造函数的默认大小为10，因为调用add(E e)，minCapacity的大小为1，并且elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，会返回初始容量DEFAULT_CAPACITY）。\n再继续看ensureExplicitCapacity()函数：\n123456private void ensureExplicitCapacity(int minCapacity) {    modCount++;        if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}\n\nmodCount 可以理解为修改次数，用于非线程安全的ArrayList,LinkedList,HashMap等等，主要用于迭代遍历中，当迭代器开始遍历时会获取这个值，遍历过程中如果其他线程修改modCount，迭代器会发现，并报异常。所以在遍历非线程安全的数据结构，尽量使用迭代器。\nensureExplicitCapacity()函数判断elementData的空间能否满足minCapacity，不满足则调用grow()函数扩容\n\n继续看grow()函数：\n12345678910111213141516171819202122232425private void grow(int minCapacity) {    &#x2F;&#x2F; overflow-conscious code    &#x2F;&#x2F;oldCapacity是当前elementData的实际长度    int oldCapacity &#x3D; elementData.length;    &#x2F;&#x2F;oldCapacity &gt;&gt; 1，表示oldCapacity&#x2F;2。也就是说newCapacity的长度为oldCapacity的1.5倍。    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);    &#x2F;&#x2F;扩充了1.5倍，如果超过了int的最大值，就会变成负数，这里是检测是否溢出；    &#x2F;&#x2F;如果扩充了1.5倍，还不够用，直接扩充到当前需要的数量    if (newCapacity - minCapacity &lt; 0)        newCapacity &#x3D; minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity &#x3D; hugeCapacity(minCapacity);    &#x2F;&#x2F; 复制数据到新的数组    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);}private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow        throw new OutOfMemoryError();    &#x2F;&#x2F;newCapacity超出了MAX_ARRAY_SIZE，就返回Integer.MAX_VALUE    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}\n\nMAX_ARRAY_SIZE的问题。MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8，数组作为一个对象，需要一定的内存存储对象头信息，对象头信息最大占用内存不可超过8字节。\n\n2、add(int index, E element)\n12345678910111213141516&#x2F;&#x2F;在列表的指定位置插入指定元素public void add(int index, E element) {    &#x2F;&#x2F;判断界限是否有效    rangeCheckForAdd(index);    &#x2F;&#x2F;判断数组是否够用    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!    &#x2F;&#x2F;将index后面的数据向后移一位    System.arraycopy(elementData, index, elementData, index + 1,                     size - index);    elementData[index] &#x3D; element;    size++;}private void rangeCheckForAdd(int index) {    if (index &gt; size || index &lt; 0)        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));}\n123public static native void arraycopy(Object src,  int  srcPos,                                    Object dest, int destPos,                                    int length);\n\nObject src : 原数组\nint srcPos : 从原数据的起始位置开始\nObject dest : 目标数组\nint destPos : 目标数组的开始起始位置\nint length  : 要copy的数组的长度\n\n其他重要的函数12345678910&#x2F;&#x2F;清理多余未用的空间，假如elementData的实际大小是15,size此时为10，执行该方法后，elementData的实际大小变为10；public void trimToSize() {    &#x2F;&#x2F;modCount并不是添加元素后才变化，清理完空间后，modCount也发生变化。    modCount++;    if (size &lt; elementData.length) {        elementData &#x3D; (size &#x3D;&#x3D; 0)          ? EMPTY_ELEMENTDATA          : Arrays.copyOf(elementData, size);    }}\n1234&#x2F;&#x2F;返回数组元素的数量public int size() {    return size;}\n1234&#x2F;&#x2F;判断是否为空public boolean isEmpty() {    return size &#x3D;&#x3D; 0;}\n1234567891011121314&#x2F;&#x2F;返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。public int indexOf(Object o) {    &#x2F;&#x2F;如果参数为null，则遍历数组，判断是否存在null    if (o &#x3D;&#x3D; null) {        for (int i &#x3D; 0; i &lt; size; i++)            if (elementData[i]&#x3D;&#x3D;null)                return i;    } else {        for (int i &#x3D; 0; i &lt; size; i++)            if (o.equals(elementData[i]))                return i;    }    return -1;}\n1234&#x2F;&#x2F;如果列表包含指定的元素，则返回 true。public boolean contains(Object o) {    return indexOf(o) &gt;&#x3D; 0;}\n1234567891011121314&#x2F;&#x2F;返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。&#x2F;&#x2F;逆序遍历public int lastIndexOf(Object o) {    if (o &#x3D;&#x3D; null) {        for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--)            if (elementData[i]&#x3D;&#x3D;null)                return i;    } else {        for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--)            if (o.equals(elementData[i]))                return i;    }    return -1;}\n123456789101112&#x2F;&#x2F;返回此 ArrayList 实例的浅表副本。(克隆)public Object clone() {    try {        ArrayList&lt;?&gt; v &#x3D; (ArrayList&lt;?&gt;) super.clone();        v.elementData &#x3D; Arrays.copyOf(elementData, size);        v.modCount &#x3D; 0;        return v;    } catch (CloneNotSupportedException e) {        &#x2F;&#x2F; this shouldn&#39;t happen, since we are Cloneable        throw new InternalError(e);    }}\n1234&#x2F;&#x2F;按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。public Object[] toArray() {    return Arrays.copyOf(elementData, size);}\n1234567891011121314&#x2F;&#x2F;按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。@SuppressWarnings(&quot;unchecked&quot;)public &lt;T&gt; T[] toArray(T[] a) {    &#x2F;&#x2F;如果a.length &lt; size，则创建一个a数组，大小为arraylist的大小    if (a.length &lt; size)        &#x2F;&#x2F; Make a new array of a&#39;s runtime type, but my contents:        return (T[]) Arrays.copyOf(elementData, size, a.getClass());    &#x2F;&#x2F;如果a数组大小够用，直接复制elementData到a中    System.arraycopy(elementData, 0, a, 0, size);    if (a.length &gt; size)        a[size] &#x3D; null;    return a;}\n1234567891011&#x2F;&#x2F;返回此列表中指定位置上的元素。public E get(int index) {    &#x2F;&#x2F;检查边界    rangeCheck(index);    return elementData(index);}private void rangeCheck(int index) {    if (index &gt;&#x3D; size)        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));}\n123456789&#x2F;&#x2F;用指定的元素替代此列表中指定位置上的元素。public E set(int index, E element) {    rangeCheck(index);    E oldValue &#x3D; elementData(index);    elementData[index] &#x3D; element;    &#x2F;&#x2F;返回旧值    return oldValue;}\n123456789101112131415&#x2F;&#x2F;移除此列表中指定位置上的元素。public E remove(int index) {    rangeCheck(index);    modCount++;    E oldValue &#x3D; elementData(index);    int numMoved &#x3D; size - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work    return oldValue;}\n1234567891011121314151617181920212223242526&#x2F;&#x2F;移除此列表中首次出现的指定元素public boolean remove(Object o) {    if (o &#x3D;&#x3D; null) {        for (int index &#x3D; 0; index &lt; size; index++)            if (elementData[index] &#x3D;&#x3D; null) {                &#x2F;&#x2F;找到元素后删除                fastRemove(index);                return true;            }    } else {        for (int index &#x3D; 0; index &lt; size; index++)            if (o.equals(elementData[index])) {                fastRemove(index);                return true;            }    }    return false;}private void fastRemove(int index) {    modCount++;    int numMoved &#x3D; size - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work}\n12345678910&#x2F;&#x2F;移除此列表中的所有元素。public void clear() {    modCount++;    &#x2F;&#x2F; clear to let GC do its work    for (int i &#x3D; 0; i &lt; size; i++)        elementData[i] &#x3D; null;    size &#x3D; 0;}\n123456789&#x2F;&#x2F;按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。public boolean addAll(Collection&lt;? extends E&gt; c) {    Object[] a &#x3D; c.toArray();    int numNew &#x3D; a.length;    ensureCapacityInternal(size + numNew);  &#x2F;&#x2F; Increments modCount    System.arraycopy(a, 0, elementData, size, numNew);    size +&#x3D; numNew;    return numNew !&#x3D; 0;}\n1234567891011121314151617&#x2F;&#x2F;从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。public boolean addAll(int index, Collection&lt;? extends E&gt; c) {    rangeCheckForAdd(index);    Object[] a &#x3D; c.toArray();    int numNew &#x3D; a.length;    ensureCapacityInternal(size + numNew);  &#x2F;&#x2F; Increments modCount    int numMoved &#x3D; size - index;    if (numMoved &gt; 0)        System.arraycopy(elementData, index, elementData, index + numNew,                         numMoved);    System.arraycopy(a, 0, elementData, index, numNew);    size +&#x3D; numNew;    return numNew !&#x3D; 0;}","url":"/2018/12/26/201812/Java源码分析ArrayList/","link":"","plink":"http://example.com/2018/12/26/201812/Java%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90ArrayList/"},{"title":"Java源码分析--Iterator、Collection","content":"整体框架\nIteratorIterator是一个接口，是集合的迭代器，集合可以使用Iterator来遍历集合中的元素。\n12345678public interface Iterator&lt;E&gt; {       boolean hasNext();  &#x2F;&#x2F;是否存在下一个元素    E next();           &#x2F;&#x2F;返回迭代的下一个元素。    void remove();      &#x2F;&#x2F;从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。每次调用 next 只能调用一次此方法。如果进行迭代时用调用此方法之外的其他方式修改了该迭代器所指向的 collection，则迭代器的行为是不确定的。}\n\nCollectionCollection继承了Iterable，Iterable\n1234567891011121314151617181920212223242526272829303132public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {    int size();                     &#x2F;&#x2F;返回此 collection 中的元素数。如果此 collection 包含的元素大于 Integer.MAX_VALUE，则返回 Integer.MAX_VALUE。        boolean isEmpty();              &#x2F;&#x2F;如果此 collection 不包含元素，则返回 true。        boolean contains(Object o);     &#x2F;&#x2F;如果此 collection 包含指定的元素，则返回 true。        Iterator&lt;E&gt; iterator();         &#x2F;&#x2F;返回在此 collection 的元素上进行迭代的迭代器。        Object[] toArray();             &#x2F;&#x2F;返回包含此 collection 中所有元素的数组。        &lt;T&gt; T[] toArray(T[] a);         &#x2F;&#x2F;返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。        boolean add(E e);               &#x2F;&#x2F;确保此 collection 包含指定的元素。        boolean remove(Object o);       &#x2F;&#x2F; 从此 collection 中移除指定元素的单个实例，如果存在的话        boolean containsAll(Collection&lt;?&gt; c);&#x2F;&#x2F;如果此 collection 包含指定 collection 中的所有元素，则返回 true。        boolean addAll(Collection&lt;? extends E&gt; c);&#x2F;&#x2F;将指定     collection 中的所有元素都添加到此 collection 中        boolean removeAll(Collection&lt;?&gt; c);&#x2F;&#x2F;移除此 collection 中那些也包含在指定 collection 中的所有元素        boolean retainAll(Collection&lt;?&gt; c);&#x2F;&#x2F;仅保留此 collection 中那些也包含在指定 collection 的元素        void clear();                   &#x2F;&#x2F;移除此 collection 中的所有元素        boolean equals(Object o);       &#x2F;&#x2F;比较此 collection 与指定对象是否相等。        int hashCode();                 &#x2F;&#x2F;返回此 collection 的哈希码值。}\nAbstractCollectionAbstractCollection的定义如下：\n1public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {}\nAbstractCollection是一个抽象类，它实现了除iterator()和size()之外的函数,方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口。\nListList继承于Collection的接口，List是有序的队列。List包含了Collection中的全部接口，也有自己的API接口。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public interface List&lt;E&gt; extends Collection&lt;E&gt; {    &#x2F;&#x2F;Collection的API    int size();    boolean isEmpty();    boolean contains(Object o);    Iterator&lt;E&gt; iterator();    Object[] toArray();    &lt;T&gt; T[] toArray(T[] a);    boolean add(E e);    boolean remove(Object o);    boolean containsAll(Collection&lt;?&gt; c);    boolean addAll(Collection&lt;? extends E&gt; c);    boolean removeAll(Collection&lt;?&gt; c);      boolean retainAll(Collection&lt;?&gt; c);        void clear();    boolean equals(Object o);        int hashCode();        ListIterator&lt;E&gt; listIterator();        &#x2F;&#x2F;新增的API    boolean addAll(int index, Collection&lt;? extends E&gt; c); &#x2F;&#x2F;将指定 collection 中的所有元素都插入到列表中的指定位置     &#x2F;**     * @since 1.8   jdk1.8引入     *&#x2F;    default void replaceAll(UnaryOperator&lt;E&gt; operator) {        Objects.requireNonNull(operator);&#x2F;&#x2F;判断对象是否为空，空的时候报空指针异常        final ListIterator&lt;E&gt; li &#x3D; this.listIterator();        while (li.hasNext()) {            li.set(operator.apply(li.next()));        }    }        @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})    default void sort(Comparator&lt;? super E&gt; c) {        Object[] a &#x3D; this.toArray();        Arrays.sort(a, (Comparator) c);        ListIterator&lt;E&gt; i &#x3D; this.listIterator();        for (Object e : a) {            i.next();            i.set((E) e);        }    }    E get(int index);&#x2F;&#x2F;返回列表中指定位置的元素       E set(int index, E element); &#x2F;&#x2F;用指定元素替换列表中指定位置的元素    void add(int index, E element);&#x2F;&#x2F;在列表的指定位置插入指定元素       E remove(int index);&#x2F;&#x2F;移除列表中指定位置的元素    int indexOf(Object o);&#x2F;&#x2F;返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。       int lastIndexOf(Object o);&#x2F;&#x2F;返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。    ListIterator&lt;E&gt; listIterator(int index);&#x2F;&#x2F;返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。       List&lt;E&gt; subList(int fromIndex, int toIndex);&#x2F;&#x2F;返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。    @Override    default Spliterator&lt;E&gt; spliterator() {        return Spliterators.spliterator(this, Spliterator.ORDERED);    }}\nAbstractListAbstractList的定义如下：\n1public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {}\nAbstractList继承于AbstractCollection，实现了List接口的抽象类，实现了List中除size()、get(int location)之外的函数(实现了iterator()接口)，从而方便其它类继承List。\nSetSet是一个继承于Collection的接口，Set也是集合中的一种。Set是没有重复元素的集合,和数学定义一样。Set的API和Collection的API完全一样。\n1public interface Set&lt;E&gt; extends Collection&lt;E&gt;{}  &#x2F;&#x2F;定义\nAbstractSetAbstractSet的定义如下： \n1public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; {}\nAbstractSet继承于AbstractCollection，Set也就没有自己单独的API,和AbstractCollection一样，它实现了List中除iterator()和size()之外的函数。","url":"/2018/12/25/201812/Java源码分析IteratorCollection/","link":"","plink":"http://example.com/2018/12/25/201812/Java%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90IteratorCollection/"},{"title":"Java源码分析--LinkedList","content":"介绍LinkedList是一个双向链表，可以从头部和尾部对LinkedList进行遍历。\n源码定义1234public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{}\nLinkedList继承了AbstractSequentialList类，实现了List、Deque（双端队列）、Cloneable（克隆）和java.io.Serializable接口；\nNode结点1234567891011private static class Node&lt;E&gt; {    E item;      &#x2F;&#x2F;存储的数据    Node&lt;E&gt; next;  &#x2F;&#x2F;后继结点    Node&lt;E&gt; prev;  &#x2F;&#x2F;前驱结点    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {        this.item &#x3D; element;        this.next &#x3D; next;        this.prev &#x3D; prev;    }}\n从Node结点可以看出来，定义了前驱和后继结点，并且存在带参数的构造函数，也就是说创建一个Node结点必须提供元素值和前驱和后继的结点。\n成员变量12345transient int size &#x3D; 0;&#x2F;&#x2F;LinkedList中元素个数transient Node&lt;E&gt; first;&#x2F;&#x2F;LinkedList第一个结点transient Node&lt;E&gt; last;&#x2F;&#x2F;LinkedList最后一个结点\n构造方法12public LinkedList() {}\n不带参数的构造函数。创建了一个空的LinkedList。\n1234public LinkedList(Collection&lt;? extends E&gt; c) {    this();    addAll(c);}\n带Collection参数的构造方法。首先this()调用无参的构造函数，创建一个空的LinkedList，然后执行addAll()函数，接下来看一下然后执行addAll()函数。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061  public boolean addAll(Collection&lt;? extends E&gt; c) {      return addAll(size, c);  &#x2F;&#x2F;继续看下面的addAll()函数  }  &#x2F;*** @param index 要插入数据的位置*&#x2F;  public boolean addAll(int index, Collection&lt;? extends E&gt; c) {      checkPositionIndex(index);&#x2F;&#x2F;验证index的参数是否合法      Object[] a &#x3D; c.toArray();   &#x2F;&#x2F;Collection集合转为对象数组      int numNew &#x3D; a.length;      if (numNew &#x3D;&#x3D; 0)            &#x2F;&#x2F;判断要插入数据的长度          return false;        &#x2F;&#x2F;这里是两种情况，一个是在链表最后追加数据，一个是在链表内插入数据      Node&lt;E&gt; pred, succ;&#x2F;&#x2F;pred是前驱结点，succ是后继结点      if (index &#x3D;&#x3D; size) {           succ &#x3D; null;          pred &#x3D; last;      } else {          succ &#x3D; node(index);          pred &#x3D; succ.prev;      }      for (Object o : a) {          @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;          Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);          if (pred &#x3D;&#x3D; null)&#x2F;&#x2F;如果添加的结点是第一个结点，first指向这个结点              first &#x3D; newNode;          else              pred.next &#x3D; newNode;          pred &#x3D; newNode;      }      &#x2F;&#x2F;这里也是两种情况的处理，succ对应上面，表示在链表最后追加的数据，直接将last指向最后一个即可。另一种情况是在链表中间插入数据，这里需要将链表后面的数据连接上。      if (succ &#x3D;&#x3D; null) {          last &#x3D; pred;      } else {          pred.next &#x3D; succ;          succ.prev &#x3D; pred;      }      size +&#x3D; numNew; &#x2F;&#x2F;改变链表大小      modCount++; &#x2F;&#x2F;表示链表已经修改过      return true;  }  &#x2F;&#x2F;返回下标为index的结点  Node&lt;E&gt; node(int index) {      &#x2F;&#x2F; assert isElementIndex(index);            if (index &lt; (size &gt;&gt; 1)) {          Node&lt;E&gt; x &#x3D; first;          for (int i &#x3D; 0; i &lt; index; i++)              x &#x3D; x.next;          return x;      } else {          Node&lt;E&gt; x &#x3D; last;          for (int i &#x3D; size - 1; i &gt; index; i--)              x &#x3D; x.prev;          return x;      }  }\n继续向下看：\n12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;** * 将e插入在链表的开头 *&#x2F;private void linkFirst(E e) {    final Node&lt;E&gt; f &#x3D; first;    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);&#x2F;&#x2F;创建一个新的结点    first &#x3D; newNode;       if (f &#x3D;&#x3D; null)  &#x2F;&#x2F;如果原来的链表是null，表示插入的这个结点是头结点也是尾结点        last &#x3D; newNode;    else        f.prev &#x3D; newNode;    size++;    modCount++;}&#x2F;** * 将e插入在链表的队尾 *&#x2F;void linkLast(E e) {    final Node&lt;E&gt; l &#x3D; last;    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);    last &#x3D; newNode;    if (l &#x3D;&#x3D; null)        first &#x3D; newNode;    else        l.next &#x3D; newNode;    size++;    modCount++;}&#x2F;** * 将e插入在succ结点之前 *&#x2F;void linkBefore(E e, Node&lt;E&gt; succ) {    &#x2F;&#x2F; assert succ !&#x3D; null;    final Node&lt;E&gt; pred &#x3D; succ.prev;    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);    succ.prev &#x3D; newNode;    if (pred &#x3D;&#x3D; null)        first &#x3D; newNode;    else        pred.next &#x3D; newNode;    size++;    modCount++;}\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#x2F;** * 删除第一个结点，默认f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null; *&#x2F;private E unlinkFirst(Node&lt;E&gt; f) {    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;    final E element &#x3D; f.item;   &#x2F;&#x2F;获取出来第一个结点的数据    final Node&lt;E&gt; next &#x3D; f.next;     f.item &#x3D; null;    f.next &#x3D; null; &#x2F;&#x2F; help GC    first &#x3D; next;   &#x2F;&#x2F;将first指向第二个结点    if (next &#x3D;&#x3D; null)        last &#x3D; null;    else        next.prev &#x3D; null;    size--;    modCount++;    return element;}&#x2F;** * 删除最后一个结点 *&#x2F;private E unlinkLast(Node&lt;E&gt; l) {    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;    final E element &#x3D; l.item;    final Node&lt;E&gt; prev &#x3D; l.prev;    l.item &#x3D; null;    l.prev &#x3D; null; &#x2F;&#x2F; help GC    last &#x3D; prev;    if (prev &#x3D;&#x3D; null)        first &#x3D; null;    else        prev.next &#x3D; null;    size--;    modCount++;    return element;}&#x2F;** * 删除结点x *&#x2F;E unlink(Node&lt;E&gt; x) {    &#x2F;&#x2F; assert x !&#x3D; null;    final E element &#x3D; x.item;    final Node&lt;E&gt; next &#x3D; x.next;    final Node&lt;E&gt; prev &#x3D; x.prev;    if (prev &#x3D;&#x3D; null) {        first &#x3D; next;    } else {        prev.next &#x3D; next;        x.prev &#x3D; null;    }    if (next &#x3D;&#x3D; null) {        last &#x3D; prev;    } else {        next.prev &#x3D; prev;        x.next &#x3D; null;    }    x.item &#x3D; null;    size--;    modCount++;    return element;}\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&#x2F;**    * Returns the first element in this list.    * 返回第一个结点值    * @return the first element in this list    * @throws NoSuchElementException if this list is empty    *&#x2F;   public E getFirst() {       final Node&lt;E&gt; f &#x3D; first;       if (f &#x3D;&#x3D; null)           throw new NoSuchElementException();       return f.item;   }   &#x2F;**    * Returns the last element in this list.    * 返回最后一个结点值    * @return the last element in this list    * @throws NoSuchElementException if this list is empty    *&#x2F;   public E getLast() {       final Node&lt;E&gt; l &#x3D; last;       if (l &#x3D;&#x3D; null)           throw new NoSuchElementException();       return l.item;   }   &#x2F;**    * Removes and returns the first element from this list.    * 删除第一个结点    * @return the first element from this list    * @throws NoSuchElementException if this list is empty    *&#x2F;   public E removeFirst() {       final Node&lt;E&gt; f &#x3D; first;       if (f &#x3D;&#x3D; null)           throw new NoSuchElementException();       return unlinkFirst(f);   }   &#x2F;**    * Removes and returns the last element from this list.    * 删除最后一个结点    * @return the last element from this list    * @throws NoSuchElementException if this list is empty    *&#x2F;   public E removeLast() {       final Node&lt;E&gt; l &#x3D; last;       if (l &#x3D;&#x3D; null)           throw new NoSuchElementException();       return unlinkLast(l);   }   &#x2F;**    * Inserts the specified element at the beginning of this list.    * 添加元素到第一个结点    * @param e the element to add    *&#x2F;   public void addFirst(E e) {       linkFirst(e);   }   &#x2F;**    * Appends the specified element to the end of this list.    * 添加元素到最后一个结点    * &lt;p&gt;This method is equivalent to {@link #add}.    *    * @param e the element to add    *&#x2F;   public void addLast(E e) {       linkLast(e);   }   &#x2F;**    * Returns {@code true} if this list contains the specified element.    * More formally, returns {@code true} if and only if this list contains    * at least one element {@code e} such that    * &lt;tt&gt;(o&#x3D;&#x3D;null&amp;nbsp;?&amp;nbsp;e&#x3D;&#x3D;null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;&#x2F;tt&gt;.    * 判断o是否存在LinkedList中    * @param o element whose presence in this list is to be tested    * @return {@code true} if this list contains the specified element    *&#x2F;   public boolean contains(Object o) {       return indexOf(o) !&#x3D; -1;   }      public int indexOf(Object o) {       int index &#x3D; 0;       if (o &#x3D;&#x3D; null) {  &#x2F;&#x2F;如果o是null，也要找链表里面是否存在null值           for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) {               if (x.item &#x3D;&#x3D; null)                   return index;               index++;           }       } else {           for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) {               if (o.equals(x.item))                   return index;               index++;           }       }       return -1;   }   &#x2F;**    * Returns the number of elements in this list.    *    * @return the number of elements in this list    *&#x2F;   public int size() {       return size;   }   &#x2F;**    * Appends the specified element to the end of this list.    *    * &lt;p&gt;This method is equivalent to {@link #addLast}.    *    * @param e element to be appended to this list    * @return {@code true} (as specified by {@link Collection#add})    *&#x2F;   public boolean add(E e) {       linkLast(e);       return true;   }","url":"/2018/12/28/201812/Java源码分析LinkedList/","link":"","plink":"http://example.com/2018/12/28/201812/Java%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LinkedList/"},{"title":"MySQL学习--MySQL优化思路与三范式","content":"MySQL 优化的思路\n1、表的设计要合理，符合三范式\n2、添加适当索引（index）：普通索引、主键索引、唯一索引 unique、全文索引（有时候加上：空间索引）\n3、分表技术（水平分割、垂直分割）\n4、读写（写：updata/dalete/add）分离\n5、存储过程（不建议）[模块化编程，不用编译，提高速度]\n6、对 MySQL 文件修改配置文件（my.ini: max_connections = 100,可以调整到 1000 左右）\n7、MySQL 服务器硬件升级\n8、定时清除不需要的数据，定时进行碎片整理（MyISAM）\n\n3NF(范式)第一范式有主关键字、主键不能为空、主键不能重复，、字段不可以再分\n\n\n\nid\nname\nsex\ncontact\n\n\n\n1\njohn\nmale\nemail:&#x6b;&#x6b;&#107;&#107;&#64;&#x78;&#120;&#46;&#99;&#111;&#109;,phone:222456\n\n\n2\nmary\nfamale\nemail:&#107;&#107;&#x6b;&#64;&#x78;&#x78;&#46;&#99;&#x6f;&#x6d; phone:123455\n\n\n上面这个不符和一范式，因为 contact 字段可以再分，改为下面即可符合一范式：\n\n\n\n\n\n\n\n\nid\nname\nsex\nemail\nphone\n\n\n\n1\njohn\nmale\n&#107;&#x6b;&#107;&#x6b;&#x40;&#120;&#120;&#x2e;&#99;&#111;&#x6d;\n222456\n\n\n2\nmary\nfamale\n&#x6b;&#107;&#107;&#64;&#x78;&#120;&#46;&#99;&#x6f;&#x6d;\n123455\n\n\n第二范式\n是表必须有一个主键；\n二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。也就是说消除了传递依赖\n\n\n\n\n学生 id\n院系 id\n姓名\n院系名\n院系地址\n学生手机号\n\n\n\n1\n003\n张三\n计科系\nxxx 路\n123456\n\n\n2\n004\n李四\n数学系\naaa 路\n222222\n\n\n上面这个也是不符和二范式的，因为存在传递依赖。院系名和院系地址依赖院系 id，而院系 id 依赖学生 id，因此不符合二范式\n\n\n\n\n\n\n\n\n\n\n学生 id\n院系 id\n姓名\n学生手机号\n\n\n\n1\n003\n张三\n123456\n\n\n2\n004\n李四\n222222\n\n\n\n\n\n院系 id\n院系名\n院系地址\n\n\n\n003\n计科系\nxxx 路\n\n\n004\n数学系\naaa 路\n\n\n这样消除了传递依赖，符合二范式。\n\n\n\n\n三范式任何非主键字段不能依赖于其他非主键字段\n\n\n\n学生 id\n课程 id\n课程名称\n学生名称\n学生成绩\n课程学分\n\n\n\n1\n003\n计算机导论\n张三\n98\n3\n\n\n2\n004\n数据结构\n李四\n99\n4\n\n\n上面的表结构是符合二范式的，由学生 id 和课程 id 组成的联合主键，因此不存在依赖传递，但不符合三范式\n\n\n\n\n\n\n\n学生表：\n\n\n\n\n\n\n\n\n\n\n学生 id\n学生名称\n\n\n\n1\n张三\n\n\n2\n李四\n\n\n课程表：\n\n\n\n\n\n\n课程 id\n课程名称\n课程学分\n\n\n\n003\n计算机导论\n3\n\n\n004\n数据结构\n4\n\n\n学生-课程 成绩表：\n\n\n\n\n\n\n\n学生 id\n课程 id\n学生成绩\n\n\n\n1\n003\n98\n\n\n2\n004\n99\n\n\n这样就符合三范式。\n反范式以前数据库设计都是用时间换空间，现在出现了用空间换时间，通过一些冗余设计，来达到快速响应的目的","url":"/2018/12/29/201812/MySQL学习MySQL优化思路与三范式/","link":"","plink":"http://example.com/2018/12/29/201812/MySQL%E5%AD%A6%E4%B9%A0MySQL%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E4%B8%8E%E4%B8%89%E8%8C%83%E5%BC%8F/"},{"title":"MySQL学习--慢查询","content":"通过show status 了解SQL执行频率1mysql&gt; show status like &#39;Com_%&#39;;\n123456789101112131415161718192021222324252627282930+----------------------------+-------+| Variable_name              | Value |+----------------------------+-------+| Com_admin_commands         | 0     || Com_alter_db               | 0     || Com_alter_db_upgrade       | 0     || Com_alter_event            | 0     || Com_alter_function         | 0     || Com_alter_procedure        | 0     || Com_alter_server           | 0     || Com_alter_table            | 0     || Com_alter_tablespace       | 0     || Com_analyze                | 0     || Com_assign_to_keycache     | 0     || Com_begin                  | 0     || Com_binlog                 | 0     || Com_call_procedure         | 0     || Com_change_db              | 0     || Com_change_master          | 0     || Com_check                  | 0     || Com_checksum               | 0     || Com_commit                 | 0     || Com_compound_sql           | 0     || Com_create_db              | 0     || Com_create_event           | 0     || Com_create_function        | 0     || Com_create_index           | 0     || Com_create_procedure       | 0     || Com_create_role            | 0     |……\nCom_xxx表示每个xxx语句执行了多少次。通常只关心：\n1234Com_select: 执行select的次数，一次查询累加1Com_insert: 执行insert的次数，批量插入只累加1Com_update: 执行update操作次数Com_delect: 执行delect的次数\n上面参数对于所有存储引擎表的操作都会累计\n1show status like &quot;Innodb_rows_%&quot;;\n1234Innodb_rows_readInnodb_rows_insertedInnodb_rows_updatedInnodb_rows_delected\n12345678910MariaDB [xxxx]&gt; show status like &quot;Innodb_rows_%&quot;;+----------------------+-------+| Variable_name        | Value |+----------------------+-------+| Innodb_rows_deleted  | 0     || Innodb_rows_inserted | 21335 || Innodb_rows_read     | 41566 || Innodb_rows_updated  | 0     |+----------------------+-------+4 rows in set (0.00 sec)\n常用：\n1234show status like &#39;uptime&#39;; &#x2F;&#x2F;mysql运行时间show status like &#39;connections&#39;;&#x2F;&#x2F;mysql连接数show status like &#39;slow_queries&#39;; &#x2F;&#x2F;显示慢查询次数show [session|global] status like ...;  &#x2F;&#x2F;默认是session，也就是当前窗口发生的，可以是用global，统计mysql启动后所有的统计信息。\n\n定位执行效率低的SQL语句通过两种方式：1、通过慢查询日志定位执行效率低的SQL语句。使用show variables like ‘long_query_time’;查看当前慢查询的时间，可以看到现在是10秒。(也就是说执行时间超过10秒的查询，才会被认为是慢查询，需要修改。)\n1234567MariaDB [(none)]&gt; show variables like &#39;long_query_time&#39;;+-----------------+-----------+| Variable_name   | Value     |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.00 sec)\n使用set long_query_time=1 ;设置慢查询时间为1秒。\n12MariaDB [(none)]&gt; set long_query_time&#x3D;1 ;Query OK, 0 rows affected (0.00 sec)\n重新查询，发现慢查询时间已经改为1秒\n1234567MariaDB [(none)]&gt; show variables like &#39;long_query_time&#39;;+-----------------+----------+| Variable_name   | Value    |+-----------------+----------+| long_query_time | 1.000000 |+-----------------+----------+1 row in set (0.00 sec)\n查看慢查询日志是否打开\n12345678MariaDB [(none)]&gt; show variables like &#39;slow_query%&#39;;+---------------------+-------------------+| Variable_name       | Value             |+---------------------+-------------------+| slow_query_log      | OFF               || slow_query_log_file | Gavin-PC-slow.log |+---------------------+-------------------+2 rows in set (0.00 sec)\nslow_query_log的值是OFF，未打开\n1set global slow_query_log&#x3D;&#39;ON&#39;;  &#x2F;&#x2F;打开慢查询日志 \nmy.ini中，记录了慢查询日志的位置：\n1datadir &#x3D; &quot;E:&#x2F;mysql&#x2F;data&quot;\n2、show processlist;查看当前MYSQL在进行的线程，包括线程的状态，是否锁表等等，可以实时查看SQL的执行情况\n参考资料：《深入浅出MySQL–数据库开发、优化和管理维护》（第2版）","url":"/2018/12/30/201812/MySQL学习慢查询/","link":"","plink":"http://example.com/2018/12/30/201812/MySQL%E5%AD%A6%E4%B9%A0%E6%85%A2%E6%9F%A5%E8%AF%A2/"},{"title":"深入理解Java虚拟机--HotSpot对象创建过程","content":"对象创建对象创建过程虚拟机遇到new指令，先去检查这个指令的参数是否在常量池中定位到一个类的符号引用并检查这个符号引用的类是否已经被加载、解析和初始化过。\n\n检查常量池中是否有将要创建对象所属类的符号引用\n常量池中没有类的符号引用，说明这个类还未定义，报ClassNotFoundException;\n\n\n检查这个符号引用的类是否已经被JVM加载\n类未加载，找打类的class文件，加载到方法区；\n类已经被JVM加载，则准备为对象分配内存\n\n\n对象所需的内存大小在类加载完成后便完全确定（类的所有对象的内存大小相同），把一块确定大小的内存在Java堆中划分出来。\n内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零（不包括对象头）。\n设置对象头中的信息\n完成创建，可以调用对象的构造函数初始化。分配内存的两种方式用哪种方式由Java堆是否完整和gc收集器决定\n指针碰撞。（如果内存是规整的，用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就是将指针向空闲区域移动一段与对象相同的距离。）\n空闲列表，（已使用的内存和空闲的内存相互交错，虚拟机必须维护一个表，记录哪块内存是可用的，分配内存的时候就可以在列表中找到一块足够大的空间划分给对象。）\n\n对象在虚拟机中的创建是非常频繁的行为，修改指针指向位置在并发下并不是线程安全的，虚拟机采用CAS来保证更新操作的原子性。\n对象的内存布局对象在内存中存储的布局可以分为3块区域：\n\n对象头（Header）\n实例数据（Instance Data）\n对齐填充（Padding）\n\n对象头对象头分为两部分，第一部分是存储对象自身运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。第二部分是对象所属类型指针，虚拟机通过这个指针来确定这个对象时哪个类的实例。如果对象时一个Java数组，那么在对象头中还必须有一块用于记录数组长度的数据。\n实例数据实例数据就是对象真正存储的有效信息，包括父类的成员变量和本类的成员变量。\n对齐填充起占位符的作用，HotSpotVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\n对象的访问定位主流访问方式有：使用句柄和直接指针两种。\n\n句柄访问方式（堆中需要有一块叫做“句柄池”的内存空间，用于存放所有对象的地址和所有对象所属类的类信息。引用类型的变量存放的是该对象在句柄池中的地址。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址再访问对象。）\n直接指针访问方式（引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间中需要额外的策略存储对象所属的类信息的地址。）\n\n两种方式各有优势，使用句柄访问最大好处是reference中存储的是稳定的句柄地址，对象移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。直接指针方式最大的好处是速度更快，节省了一次指针定位的时间开销，对象访问在Java中非常频繁，因此这类开销积少成多后是一项非常可观的执行成本。","url":"/2018/12/31/201812/深入理解Java虚拟机HotSpot对象创建过程/","link":"","plink":"http://example.com/2018/12/31/201812/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BAHotSpot%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"title":"深入理解Java虚拟机--Java内存模型","content":"简介Java虚拟机管理的内存包括下面五个运行时数据区域：\n\n程序计数器\nJava虚拟机栈\n本地方法栈\n堆\n方法区\n\n程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，可以看做当前所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，也就是下一条字节码指令的地址。\n\n线程私有（多线程并发执行时每个线程必须有自己的程序计数器，用来记录自己执行字节码的位置，方便CPU时间片轮询切换后继续执行）。\n如果执行的是Native方法（指本地方法：一般使用C/C++在另外文件中编写）,这个计数器值记为空。\n此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域（程序计数器存放当前线程下一条指令所在的位置，可以预见其大小，所以不会内存溢出）。\n\nJava虚拟机栈Java虚拟机栈是线程私有，生命周期与线程相同。\n\n栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量表、操作数栈、动态链接、方法出口等)\n\nJVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)\n\n栈属于线程私有，不能实现线程间的共享!\n\n栈的存储特性是“先进后出，后进先出”（每一个方法从调用直到执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。）\n\n局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。而且，局部变量表的大小在编译时期就确定下来了，在创建的时候只需分配事先规定好的大小即可。此外，在方法运行的过程中局部变量表的大小是不会发生改变的。\n\nJava虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError。\n\nStackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 \nOutOfMemoryError：若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。\n\n本地方法栈\n本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。\n\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n\n方法执行完毕后相应的栈帧也会出栈并释放内存空间。\n\n也会抛出StackOverFlowError和OutOfMemoryError异常。\nJava堆\n堆用于存储创建好的对象和数组(数组也是对象)\n\nJVM只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个的。\n\n所有的线程都访问同一个堆，进行对象内存的分配均需要进行加锁，所以new对象操作开销比较大\n\n在虚拟机启动时创建\n\n垃圾回收的主要场所。\n\n可以进一步细分为：新生代、老年代。 \n\n新生代又可被分为：Eden、From Survior、To Survior。 \n\n不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。\n\n堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OutOfMemoryError。 \n\n\n方法区\nJVM只有一个方法区，被所有线程共享!\n方法区实际也是堆（堆的一个逻辑部分），只是用于存储类、常量相关的信息!\n用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等)线程共享 \n永久代 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。\n内存回收效率低 方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。 \n对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。\nJava虚拟机规范对方法区的要求比较宽松。和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。 运行时常量池\n运行时常量池是方法区的一部分\n方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码。其中常量存储在运行时常量池中。\n我们一般在一个类中通过public static final来声明一个常量。这个类被编译后便生成Class文件，这个类的所有信息都存储在这个class文件中。\n当这个类被Java虚拟机加载后，class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如：String类的intern()方法就能在运行期间向常量池中添加字符串常量。\n当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。","url":"/2018/12/29/201812/深入理解Java虚拟机Java内存模型/","link":"","plink":"http://example.com/2018/12/29/201812/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BAJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"title":"Java基础之注解","content":"注解什么是注解注解也叫Annotation，从JDK5.0开始引入。\n\nAnnotation不是程序，但是可以对程序作出解释\n可以被其他程序读取\n\n内置注解@Override定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。\n1234   @Overridepublic String toString (){\treturn &quot;&quot;;}\n在阿里巴巴Java开发手册中强制要求所有重写方法必须加@Override，防止重写方法名称写错。@Deprecated定义在java.lang.Deprecated中，此注释可用于修辞方法、属性、类，表示不建议使用这样的元素，通常被遗弃。@SuppressWarnings定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息。  \n自定义注解先了解一下元注解：元注解的作用就是负责注解其他注解。 Java定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。这些类型和它们所支持的类在java.lang.annotation包中可以找到  \n\n@Target 用于描述注解的使用范围\n\n1234567891011121314151617181920212223@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target {    ElementType[] value();}&#x2F;&#x2F;其中ElementType是枚举package java.lang.annotation;public enum ElementType {    TYPE,  &#x2F;&#x2F;修饰：类、接口、枚举、Annotation类型    FIELD, &#x2F;&#x2F;用于描述域    METHOD, &#x2F;&#x2F;用于描述方法    PARAMETER,  &#x2F;&#x2F;用于描述参数    CONSTRUCTOR,    &#x2F;&#x2F;用于描述构造器    LOCAL_VARIABLE, &#x2F;&#x2F;用于描述局部参数    ANNOTATION_TYPE,    &#x2F;&#x2F;注解A对注解B进行声明，@Target就是用的这个    PACKAGE,    &#x2F;&#x2F;package包    &#x2F;&#x2F;java8新增两个注解    TYPE_PARAMETER,    TYPE_USE}\n\n@Retention 表示需要在什么级别保存该注释信息，用于描述注解的生命周期\n1234567891011121314151617181920package java.lang.annotation;@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention {    RetentionPolicy value();}&#x2F;&#x2F;RetentionPolicy也是枚举package java.lang.annotation;public enum RetentionPolicy {    SOURCE, &#x2F;&#x2F;在源文件中有效（用于编译器和加载器）    CLASS, &#x2F;&#x2F;在class文件中有效（用于编译器和加载器）        RUNTIME &#x2F;&#x2F;在运行时有效。为Runtime可以被反射机制读取}\n下面的两个不常用：  \n\n@Documented 给类方法添加注释\n\n@Inherited  修饰某个被标注的类型是被继承的\n1、首先创建一个Annotation,使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口\n12345678910111213141516package fun.gwt;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(value&#x3D;{ElementType.METHOD,ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation {\tString value() default &quot;&quot;;\tint id() default 0;}\n注解元素必须要有值。我们定义注解元素时，经常使用空字符串、0作为默认值。也经常使用负数(比如：-1)表示不存在的含义\n\n如果只有一个参数成员，一般参数名为value\n\n\n注解实战ORM对象关系映射（英语：(Object Relational Mapping，简称ORM，或O/RM，或O/Rmapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。这里使用注解和反射技术，来实现ORM，将对象转换成SQL语句1、首先创建一个Student对象，如下代码所示，我们需要创建两个注解，第一个注解将Student类转换成sql的表名，第二个注解将属性赋值上长度，类型和名称等属性。\n12345678910111213141516171819202122232425package fun.gwt.annotation;class Student {\tint id;\tint age;\tString sName;\tpublic int getId() {\t\treturn id;\t}\tpublic void setId(int id) {\t\tthis.id &#x3D; id;\t}\tpublic int getAge() {\t\treturn age;\t}\tpublic void setAge(int age) {\t\tthis.age &#x3D; age;\t}\tpublic String getsName() {\t\treturn sName;\t}\tpublic void setsName(String sName) {\t\tthis.sName &#x3D; sName;\t}}\n2、为对象名注解表名\n1234567891011121314package fun.gwt.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(value&#x3D;{ElementType.TYPE})public @interface Table {\t&#x2F;&#x2F;如果只有一个参数成员，一般参数名为value\tString value();}\n3、给属性赋值上长度，类型和名称等属性\n123456789101112131415package fun.gwt.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(value&#x3D;{ElementType.FIELD})public @interface Field {\tString columnName();\tString type();\tint length();\t\t}\n4、接下来需要重新修改Student类，将类名和属性名加上注解\n123456789101112131415161718192021222324252627282930package fun.gwt.annotation;@Table(&quot;db_student&quot;)class Student {\t@Field(columnName&#x3D;&quot;id&quot;,type&#x3D;&quot;int&quot;,length&#x3D;10)\tint id;\t@Field(columnName&#x3D;&quot;id&quot;,type&#x3D;&quot;int&quot;,length&#x3D;3)\tint age;\t@Field(columnName&#x3D;&quot;sname&quot;,type&#x3D;&quot;varchar&quot;,length&#x3D;10)\tString sName;\tpublic int getId() {\t\treturn id;\t}\tpublic void setId(int id) {\t\tthis.id &#x3D; id;\t}\tpublic int getAge() {\t\treturn age;\t}\tpublic void setAge(int age) {\t\tthis.age &#x3D; age;\t}\tpublic String getsName() {\t\treturn sName;\t}\tpublic void setsName(String sName) {\t\tthis.sName &#x3D; sName;\t}}\n5、使用反射来获取信息\n1234567891011121314151617181920212223package fun.gwt.annotation;import java.lang.annotation.Annotation;import java.lang.reflect.Field;public class Test {\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException {\t\tClass cla &#x3D; Class.forName(&quot;fun.gwt.annotation.Student&quot;);\t\t&#x2F;&#x2F;获取类的所有有效注解\t\tAnnotation[] annotations &#x3D; cla.getAnnotations();\t\tfor (Annotation a : annotations) {\t\t\tSystem.out.println(a);&#x2F;&#x2F;@fun.gwt.annotation.Table(value&#x3D;db_student)\t\t}\t\t&#x2F;&#x2F;获取类的指定注解\t\tTable t &#x3D; (Table)cla.getAnnotation(Table.class);\t\tSystem.out.println(t.value()); &#x2F;&#x2F;db_student\t\t&#x2F;&#x2F;获取类的属性注解\t\tField f &#x3D; cla.getDeclaredField(&quot;sName&quot;);\t\tGwtField gwtField &#x3D; f.getAnnotation(GwtField.class);\t\tSystem.out.println(gwtField.columnName()+&quot;--&quot;+gwtField.type()+&quot;--&quot;+gwtField.length());&#x2F;&#x2F;sname--varchar--10\t\t&#x2F;&#x2F;接下来就是拼接sql语句\t}}","url":"/2019/01/29/201901/Java基础之注解/","link":"","plink":"http://example.com/2019/01/29/201901/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/"},{"title":"Java源码分析--Object详解","content":"简介Object类在java.lang包中，是所有类的父类，所有类都间接或者直接继承Object类。Object类中主要有registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait()和finalize()等方法。其中getClass()、notify()、notifyAll()和wait()等方法使用final关键字修饰，因此子类不能覆盖。\n源代码registerNatives()方法12345private static native void registerNatives();&#x2F;&#x2F;在类加载时就执行这个方法static {    registerNatives();}\nregisterNatives()方法是注册一些本地方法，具体实现在本地的代码中，所以我也不清楚里面干了什么。学Java还是有必要学习一下JNI的，等我找到工作要好好研究一下。在Java中，静态代码的调用顺序：父类静态–&gt;子类静态–&gt;父类非静态–&gt;父类构造–&gt;子类非静态–&gt;子类构造\ngetClass()方法1public final native Class&lt;?&gt; getClass();\n返回运行时的类\nhashCode()方法1public native int hashCode();\n返回对象的哈希码，在HashMap中，就是通过hashCode来提高查找哈希表的速度。\nequals()方法123public boolean equals(Object obj) {    return (this &#x3D;&#x3D; obj);}\n这里判断的是对象，对象的地址相同，返回true，如果两个对象完全一样，但是地址不相同，也会返回false。\n在Java中，8种基本数据类型变量存储的是值，可以直接使用==来比较，而引用类型数据变量需要使用equals(),也可以重写该方法。\n\n数值型－ byte(1字节)、 short(2字节)、int(4字节)、 long(8字节)、float(4字节)、 double(8字节)\n字符型－ char (2字节)\n布尔型－boolean (1位)\n引用数据类型 —— class，interface，数组   (4个字节)\n\nclone()方法实现拷贝必须实现Cloneable接口，并重写clone()方法。  \n1protected native Object clone() throws CloneNotSupportedException;\nclone分为浅拷贝和深拷贝：\n12浅拷贝：拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间。深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。\n浅拷贝1234567891011121314151617181920212223public class Professor {    private String name;    private int age;    &#x2F;&#x2F;省略get和set方法}public class Student implements Cloneable {    private String name;    private int age;    private Professor professor;    &#x2F;&#x2F;省略get和set方法    public Professor getProfessor() {        return professor;    }    public void setProfessor(Professor professor) {        this.professor &#x3D; professor;    }    &#x2F;&#x2F;对对象Studentclone    @Override    public Object clone() throws CloneNotSupportedException{        return super.clone();    }}\n1234567Professor p1 &#x3D; new Professor();&#x2F;&#x2F;省略赋值Student s1 &#x3D; new Student();&#x2F;&#x2F;省略赋值Student s2 &#x3D; (Student) s1.clone();Professor p2 &#x3D; s2.getProfessor();&#x2F;&#x2F;省略修改\n在这里s2浅拷贝s1，如果现在对p2进行修改，那么s1中的Professor也会变化。因为p2只是引用了p1的地址，对p2的任何操作和操作p1是一样的。\n深拷贝代码修改为：\n1234567891011121314151617181920212223242526272829public class Professor {    private String name;    private int age;    &#x2F;&#x2F;省略get和set方法    @Override    public Object clone() throws CloneNotSupportedException{    \treturn super.clone();    }}public class Student implements Cloneable {    private String name;    private int age;    private Professor professor;    &#x2F;&#x2F;省略get和set方法    public Professor getProfessor() {        return professor;    }    public void setProfessor(Professor professor) {        this.professor &#x3D; professor;    }    &#x2F;&#x2F;对对象Studentclone    @Override    public Object clone() throws CloneNotSupportedException{        Student newStudent &#x3D; (Student) super.clone();        newStudent.professor &#x3D; (Professor) professor.clone();        return newStudent;    }}\n这样就实现了深拷贝，对p2的任何操作都不会影响p1。\ntoString()方法123public String toString() {    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());}\ntoString()方法在子类中都会被重写，这里显示的是类名+”@”+对象哈希码的十六进制数\nnotify()和notifyAll()方法12public final native void notify();public final native void notifyAll();\nnotify()方法会唤醒一个处于等待状态的线程，notifyAll()方法会唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程先调度。\nwait()方法1234567891011121314151617181920212223&#x2F;&#x2F;timeout是等待时间，毫秒。public final native void wait(long timeout) throws InterruptedException;&#x2F;&#x2F;nanos是纳秒。多加一个nanos参数是为了比wait(long timeout)更好的控制时间，其中1毫秒(ms)&#x3D;1000000纳秒(ns)public final void wait(long timeout, int nanos) throws InterruptedException {    if (timeout &lt; 0) {        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);    }    if (nanos &lt; 0 || nanos &gt; 999999) {        throw new IllegalArgumentException(                            &quot;nanosecond timeout value out of range&quot;);    }    if (nanos &gt; 0) {        timeout++;    }    wait(timeout);}&#x2F;&#x2F;不唤醒就一直等待public final void wait() throws InterruptedException {    wait(0);}\nfinalize()方法1protected void finalize() throws Throwable { }\n当垃圾回收器将要回收对象所占内存之前被调用。\n参考资料Java的clone()：深复制与浅复制","url":"/2019/01/28/201901/Java源码分析Object详解/","link":"","plink":"http://example.com/2019/01/28/201901/Java%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Object%E8%AF%A6%E8%A7%A3/"},{"title":"Java源码分析--Stack","content":"介绍Stack是一种先进后出的数据结构，继承于Vector，所以Stack是通过数组实现。\n源码分析继承12publicclass Stack&lt;E&gt; extends Vector&lt;E&gt; {}\n构造函数Stack只有一个默认的构造函数，创建一个空的栈。\n12public Stack() {}\n所有API12345             boolean       empty()synchronized E             peek()synchronized E             pop()             E             push(E object)synchronized int           search(Object o)\nStack只是在Vector的基础上添加了几个方法。\n123456&#x2F;&#x2F;push 将数据存放在数组的最后public E push(E item) {    addElement(item);    return item;}\n12345678910&#x2F;&#x2F;弹出数据操作public synchronized E pop() {    E       obj;    int     len &#x3D; size();  &#x2F;&#x2F;先获取栈的大小    obj &#x3D; peek();  &#x2F;&#x2F;取出来栈中最上面的数据，也就是数组中最后一个数据    removeElementAt(len - 1);&#x2F;&#x2F;将最后一个删除掉    return obj;}\n12345678&#x2F;&#x2F;查看栈顶元素，但是不移除public synchronized E peek() {    int     len &#x3D; size();  &#x2F;&#x2F;获取栈的大小    if (len &#x3D;&#x3D; 0)  &#x2F;&#x2F;判断是否为空栈        throw new EmptyStackException();    return elementAt(len - 1); &#x2F;&#x2F;elementAt是根据索引查出来数据}\n1234&#x2F;&#x2F;判断是否为空栈public boolean empty() {    return size() &#x3D;&#x3D; 0;}\n123456789&#x2F;&#x2F;搜索元素0在栈中的位置，从1开始，距离栈底的大小。public synchronized int search(Object o) {    int i &#x3D; lastIndexOf(o);    if (i &gt;&#x3D; 0) {        return size() - i;    }    return -1;}","url":"/2019/01/18/201901/Java源码分析Stack/","link":"","plink":"http://example.com/2019/01/18/201901/Java%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Stack/"},{"title":"Java源码分析--Vector","content":"介绍Vector和ArrayList一样，内部都是通过数组实现。Vector是线程安全的，但是由于使用了synchronized方法，性能上比ArrayList差。\n源码分析继承1234public class Vector&lt;E&gt;    extends AbstractList&lt;E&gt;    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{}\nVector继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。\n成员变量1234protected Object[] elementData;  &#x2F;&#x2F;存放数据的对象数组protected int elementCount;     &#x2F;&#x2F;记录存了多少个元素protected int capacityIncrement;  &#x2F;&#x2F;当向量溢出时增加的数量private static final long serialVersionUID &#x3D; -2767605614048989439L;\n构造函数123456789101112131415161718192021222324252627282930 &#x2F;&#x2F;传入两个参数initialCapacity和capacityIncrement，initialCapacity是Vector初始化的容量，capacityIncrement是当Vector溢出时增加的数量 public Vector(int initialCapacity, int capacityIncrement) {     super();     if (initialCapacity &lt; 0)           throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                            initialCapacity);     this.elementData &#x3D; new Object[initialCapacity];     this.capacityIncrement &#x3D; capacityIncrement; } public Vector(int initialCapacity) {     this(initialCapacity, 0); }&#x2F;&#x2F;如果不规定向量大小，就默认为10 public Vector() {     this(10); } &#x2F;&#x2F;将Collection转化为了数组 public Vector(Collection&lt;? extends E&gt; c) {     elementData &#x3D; c.toArray();     elementCount &#x3D; elementData.length;     &#x2F;&#x2F; c.toArray might (incorrectly) not return Object[] (see 6260652)     &#x2F;&#x2F;返回若不是Object[]将调用Arrays.copyOf方法将其转为Object[]     if (elementData.getClass() !&#x3D; Object[].class)         elementData &#x3D; Arrays.copyOf(elementData, elementCount, Object[].class); }\naddadd函数和Arraylist差不多，ArrayList是扩容空间1.5倍，Vector是扩容了2倍。\n1234567891011121314151617181920212223242526272829303132333435public synchronized boolean add(E e) {    modCount++;    ensureCapacityHelper(elementCount + 1);  &#x2F;&#x2F;判断空间是否够用    elementData[elementCount++] &#x3D; e;    return true;}&#x2F;&#x2F;minCapacity是需要最小空间的容量，低于这个值就存不进去数据private void ensureCapacityHelper(int minCapacity) {       &#x2F;&#x2F; overflow-conscious code    if (minCapacity - elementData.length &gt; 0) &#x2F;&#x2F;判断增加的大小是否在对象数组大小的范围内        grow(minCapacity);   &#x2F;&#x2F;如果空间不足，就需要扩容了}private static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;private void grow(int minCapacity) {    &#x2F;&#x2F; overflow-conscious code    int oldCapacity &#x3D; elementData.length;  &#x2F;&#x2F;当前容器的大小    &#x2F;&#x2F;如果增量capacityIncrement&gt;0,就将容器增加capacityIncrement    &#x2F;&#x2F;否则，容器增加一倍    int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ?                                     capacityIncrement : oldCapacity);    &#x2F;&#x2F;如果空间还是不够用，直接扩容到需要的空间。    if (newCapacity - minCapacity &lt; 0)        newCapacity &#x3D; minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity &#x3D; hugeCapacity(minCapacity);    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);}private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}\n其他其余的方法也不介绍了，因为和ArrayList差不多。Vector的所有方法都是用synchronized修饰，从而保证了访问vector的所有方法都必须获得对象的锁。虽然vector内部实现了同步，但是外部调用时，如果一些线程连续调用两个或者两个以上的同步方法，也会引起混乱。因此，在使用vector时，连续调用两个或两个以上的同步方法仍然需要进行同步处理。","url":"/2019/01/05/201901/Java源码分析Vector/","link":"","plink":"http://example.com/2019/01/05/201901/Java%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Vector/"},{"title":"Java基础之序列化与反序列化","content":"简介在Java运行过程中创建的对象，随着JVM的的停止，对象也会消失。为了将对象保存在本地硬盘或者是进行网络传输，需要将对象序列化，在需要的时候重新获取对象状态。Java为对象序列化和反序列化提供了两个接口：\n12java.io.Serializablejava.io.Externalizable\n下面通过例子来演示两个接口的作用和区别。\nSerializable实现对象的序列化，必须实现Serializable接口。首先实现要序列化的对象：\n1234567891011121314151617181920212223242526272829303132333435363738import java.io.Serializable;public class Student implements Serializable{\tprivate static final long serialVersionUID = 1195127496667537096L;\tprivate String name;\tprivate int age;\tprivate String sex;\tprivate int id;\tpublic String getName() {\t\treturn name;\t}\tpublic void setName(String name) {\t\tthis.name = name;\t}\tpublic int getAge() {\t\treturn age;\t}\tpublic void setAge(int age) {\t\tthis.age = age;\t}\tpublic String getSex() {\t\treturn sex;\t}\tpublic void setSex(String sex) {\t\tthis.sex = sex;\t}\tpublic int getId() {\t\treturn id;\t}\tpublic void setId(int id) {\t\tthis.id = id;\t}\t//重写toString方法，方便输出信息\t@Override\tpublic String toString(){\t\treturn &quot;姓名是：&quot;+name+&quot;,年龄是&quot;+age+&quot;，性别是：&quot;+sex+&quot;,学号是:&quot;+id;\t\t\t}}\n演示怎么样序列化和反序列化：\n123456789101112131415161718192021222324252627282930313233343536373839package fun.gwt.base;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class SerializableDemos {\tpublic static void main(String[] args) throws Exception {\t\t//初始化对象\t\tStudent stu = new Student();\t\tstu.setName(&quot;Gavin&quot;);\t\tstu.setAge(24);\t\tstu.setSex(&quot;男&quot;);\t\tstu.setId(123456);\t\tSystem.out.println(stu);\t\t\t\t//创建对象输出流\t\tObjectOutputStream oos = new ObjectOutputStream(new \t\t//将对象保存在了本地文件中\t\tFileOutputStream(&quot;studentObject&quot;));\t\toos.writeObject(stu);\t\toos.close();\t\t\t\t//读出来对象\t\tFile file = new File(&quot;studentObject&quot;);\t\t//读取文件内容\t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));\t\tStudent stu1 = (Student) ois.readObject();\t\tSystem.out.println(stu1);\t\tois.close();\t}}/*姓名是：Gavin,年龄是24，性别是：男,学号是:123456姓名是：Gavin,年龄是24，性别是：男,学号是:123456*/\nExternalizable将上面的代码修改为实现Externalizable接口的Demo，需要在类中添加writeExternal()和readExternal()方法，下面是修改好的：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package fun.gwt.base;import java.io.Externalizable;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectOutput;public class Student implements Externalizable{\t&#x2F;**\t * \t *&#x2F;\tprivate static final long serialVersionUID &#x3D; 1195127496667537096L;\tprivate String name;\tprivate int age;\tprivate String sex;\tprivate int id;\tpublic String getName() {\t\treturn name;\t}\tpublic void setName(String name) {\t\tthis.name &#x3D; name;\t}\tpublic int getAge() {\t\treturn age;\t}\tpublic void setAge(int age) {\t\tthis.age &#x3D; age;\t}\tpublic String getSex() {\t\treturn sex;\t}\tpublic void setSex(String sex) {\t\tthis.sex &#x3D; sex;\t}\tpublic int getId() {\t\treturn id;\t}\tpublic void setId(int id) {\t\tthis.id &#x3D; id;\t}\t@Override\tpublic String toString(){\t\treturn &quot;姓名是：&quot;+name+&quot;,年龄是&quot;+age+&quot;，性别是：&quot;+sex+&quot;,学号是:&quot;+id;\t}\t@Override\tpublic void writeExternal(ObjectOutput out) throws IOException {\t\t\t}\t@Override\tpublic void readExternal(ObjectInput in) throws IOException,\t\t\tClassNotFoundException {\t\t\t}}\n序列化和反序列化的main方法不需要修改，直接执行：\n12姓名是：Gavin,年龄是24，性别是：男,学号是:123456姓名是：null,年龄是0，性别是：null,学号是:0\n输出结果发现对象序列化了，但是对象的状态并没有序列化成功，里面的值都变成了默认值。Externalizable继承Serializable类，并且增加了writeExternal()和readExternal()方法，用户必须自己实现这两个方法。现在修改代码为：\n12345678910111213@Overridepublic void writeExternal(ObjectOutput out) throws IOException {\tout.writeObject(name);\tout.writeInt(id);\tout.writeObject(sex);}@Overridepublic void readExternal(ObjectInput in) throws IOException,\t\tClassNotFoundException {\tname &#x3D; (String)in.readObject();\tid &#x3D; in.readInt();\tsex &#x3D; (String)in.readObject();}\n这里只穿进去3个值，输出结果为:\n12姓名是：Gavin,年龄是24，性别是：男,学号是:123456姓名是：Gavin,年龄是0，性别是：男,学号是:123456\n可以看到，年龄没有序列化，这就是Externalizable类和Serializable类的区别。\nserialVersionUIDserialVersionUID主要是判断类是否发生改变。主要分为两种情况：\n\n没有指定serialVersionUID的值\n指定了serialVersionUID的值  \n\n1、没有指定serialVersionUID的值，JVM为自动为类创建一个serialVersionUID，对类的任何修改都会使JVM改变serialVersionUID的值。如果对象反序列化之前改变了类，那么在反序列化时，JVM会对比serialVersionUID的值，修改了类，serialVersionUID的值不相同，会反序列化失败。2、如果指定serialVersionUID的值，在对象反序列化之前修改了类，如果不影响反序列化，那么在反序列化时，对比serialVersionUID值相同，还是可以进行反序列化操作。\ntransient对于一些成员变量不需要进行序列化，因此可以使用transient关键字修饰该成员变量，反序列化后该成员变量为默认值。","url":"/2019/02/14/201902/Java基础之序列化与反序列化/","link":"","plink":"http://example.com/2019/02/14/201902/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"Java基础之线程池","content":"简介线程池可以重用存在的线程，减少对象创建、消亡的开销，性能好。并且可以控制最大并发线程数，提高系统资源利用率，同时避免过多资源竞争，避免阻塞。\njava.uitl.concurrent.ThreadPoolExecutorThreadPoolExecutor提供了四个构造函数：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ThreadPoolExecutor(int corePoolSize,                             int maximumPoolSize,                             long keepAliveTime,                             TimeUnit unit,                             BlockingQueue&lt;Runnable&gt; workQueue) {       this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,            Executors.defaultThreadFactory(), defaultHandler);   }   public ThreadPoolExecutor(int corePoolSize,                             int maximumPoolSize,                             long keepAliveTime,                             TimeUnit unit,                             BlockingQueue&lt;Runnable&gt; workQueue,                             ThreadFactory threadFactory) {       this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,            threadFactory, defaultHandler);   }   public ThreadPoolExecutor(int corePoolSize,                             int maximumPoolSize,                             long keepAliveTime,                             TimeUnit unit,                             BlockingQueue&lt;Runnable&gt; workQueue,                             RejectedExecutionHandler handler) {       this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,            Executors.defaultThreadFactory(), handler);   }   public ThreadPoolExecutor(int corePoolSize,                             int maximumPoolSize,                             long keepAliveTime,                             TimeUnit unit,                             BlockingQueue&lt;Runnable&gt; workQueue,                             ThreadFactory threadFactory,                             RejectedExecutionHandler handler) {       if (corePoolSize &lt; 0 ||           maximumPoolSize &lt;&#x3D; 0 ||           maximumPoolSize &lt; corePoolSize ||           keepAliveTime &lt; 0)           throw new IllegalArgumentException();       if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)           throw new NullPointerException();       this.acc &#x3D; System.getSecurityManager() &#x3D;&#x3D; null ?               null :               AccessController.getContext();       this.corePoolSize &#x3D; corePoolSize;       this.maximumPoolSize &#x3D; maximumPoolSize;       this.workQueue &#x3D; workQueue;       this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);       this.threadFactory &#x3D; threadFactory;       this.handler &#x3D; handler;   }\n\ncorePoolSize  //核心线程数量；只有任务来到才会创建线程。\nmaximumPoolSize //线程最大线程数量\nworkQueue //阻塞队列，存储等待执行的任务  \nkeepAliveTime //线程中没有任务时，线程最多保持多久就销毁\nunit //的时间单位\nthreadFactory //线程工厂，用来创建线程\nrejectHandler //如果阻塞队列满了，并且没有空闲线程，根据这个参数执行拒绝处理任务的策略\n\n1、如果系统中线程数量小于corePoolSize，直接创建新的线程来执行任务（不管是否存在空闲线程）；如果线程数量大于corePoolSize，但是小于maximumPoolSize，只有workQueue满了才会创建新的线程；如果系统中线程数量等于maximumPoolSize,maximumPoolSize和corePoolSize相同，workQueue不满，则线程进入workQueue，否则指定策略执行任务。    \n2、workQueue 是阻塞队列（BlockingQueue）\n12345ArrayBlockingQueue   &#x2F;&#x2F;可以限定队列长度DelayQueue          &#x2F;&#x2F;队内元素必须实现Delayed接口，队列中有元素入队时，只有到达指定延时时间，才会执行任务。LinkedBlockingQueue  &#x2F;&#x2F;阻塞的线程进入队列中，但这个队列没有最大值，因此设置maximumPoolSize会失效。PriorityBlockingQueue  &#x2F;&#x2F;优先级阻塞队列SynchronousQueue  &#x2F;&#x2F;SynchronousQueue是没有缓存的阻塞队列，接收到任务会直接提交给线程处理，如果没有空闲线程，将创建一个，一般使用时将maximumPoolSize设置为Integer.MAX_VALUE\n核心参数\nexecute()  //提交任务，交给线程池使用\nsubmit()  //提交任务，能够返回执行结果 execute + Future\nshutdown()  // 关闭线程池，等所有任务都执行完\nshutdownNow()  //关闭线程池，不等待任务执行完\ngetTaskCount()  //线程池已执行和未执行的任务总数\ngetCompletedTaskCount()  //已完成任务数量\ngetPoolSize()  //线程池当前线程数量\ngetActiveCount()  //当前线程池中正在执行任务的线程数量\n\n线程池原理线程池状态 \n\nRUNNING 运行状态，能接受新提交的任务，也能处理阻塞队列中的任务 \nSHUTDOWN 关闭状态，不能接受新提交的任务，但是可以处理阻塞队列中的任务\nSTOP 不能接受新的任务，也不能处理阻塞队列中的任务\nTIDYING 工作线程为0时进入这个状态\n\n线程池种类\nExecutors.newCachedThreadPool\nExecutors.newFixedThreadPool\nExecutors.newSingleThreadExecutor\nExecutors.newScheduleThreadPool\n\nnewCachedThreadPool创建一个可缓存的线程池，任务增加时则创建线程执行任务，线程空闲60秒则回收线程。\n12345public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}\n可以看到最大线程数量是Integer.MAX_VALUE，使用的是SynchronousQueue，因此有任务时不会存在阻塞队列中，会直接创建线程执行。\nnewFixedThreadPool12345public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}\n定长线程池，使用的是LinkedBlockingQueue阻塞队列，有任务则创建线程，如果达到固定的数量，则存放到阻塞队列中。\nnewSingleThreadExecutor创建一个单线程线程池，可以保证线程池中永远有一个线程在工作，保证了任务的顺序性\n123456public static ExecutorService newSingleThreadExecutor() {    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));}\n可以看到，调用了ThreadPoolExecutor，只允许一个线程运行。使用方法:\n1ExecutorService mSingleThreadPool &#x3D; Executors.newSingleThreadPool();\nnewScheduleThreadPool1234567public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {    return new ScheduledThreadPoolExecutor(corePoolSize);}public ScheduledThreadPoolExecutor(int corePoolSize) {    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          new DelayedWorkQueue());}\n创建一个大小无限，可以定时执行的线程池。","url":"/2019/02/23/201902/Java基础之线程池/","link":"","plink":"http://example.com/2019/02/23/201902/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"title":"Java基础之自动拆箱装箱","content":"介绍Java为每种基本数据类型提供了对应的包装类型，比如int对应的包装类型是Integer，创建一个Integer对象需要使用new关键字，在JDK5之后提供了自动装箱拆箱，可以自动将基本数据类型直接转换为包装类型，也可以直接将包装类型自动转成基本数据类型，这就叫做自动装箱拆箱。\n12Integer i = 100;    //自动装箱int j = i;          //自动拆箱\nInteger中的实现Integer自动装箱拆箱是基于valueOf()和intValue方法实现。当我们执行\n1Integer i &#x3D; 100; \n其实就是执行了：\n1Integer i &#x3D; Integer.valueOf(100);\n当执行：\n1int j &#x3D; i;  \n就是执行了：\n1int j &#x3D; i.intValue();\nvalueOf()这是valueOf的实现代码：\n12345public static Integer valueOf(int i) {    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}\n当获取到值i后，首先判断i是否存在IntegerCache中，这里IntegerCache是Integer的缓存，如果i在缓存中，直接返回缓存中的数据。注意只有在自动装箱中才用到缓存，使用new Integer中不会用到。看一下IntegerCache的源码：\n123456789101112131415161718192021222324252627282930313233private static class IntegerCache {    static final int low &#x3D; -128;  &#x2F;&#x2F;默认缓存最小值是-128    static final int high;  &#x2F;&#x2F;最大值不是固定的，可以修改    static final Integer cache[]; &#x2F;&#x2F;存放缓存的数组    static {        &#x2F;&#x2F; high value may be configured by property        int h &#x3D; 127; &#x2F;&#x2F;默认最大值是127        String integerCacheHighPropValue &#x3D;            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); &#x2F;&#x2F;使用JVM参数设置最大值        if (integerCacheHighPropValue !&#x3D; null) {            try {                int i &#x3D; parseInt(integerCacheHighPropValue);                i &#x3D; Math.max(i, 127); &#x2F;&#x2F;如果设置的最大值小于默认最大值127，就使用127                &#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE                h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);&#x2F;&#x2F;最大值的范围            } catch( NumberFormatException nfe) {                &#x2F;&#x2F; If the property cannot be parsed into an int, ignore it.            }        }        high &#x3D; h;        cache &#x3D; new Integer[(high - low) + 1];        int j &#x3D; low;        for(int k &#x3D; 0; k &lt; cache.length; k++)            cache[k] &#x3D; new Integer(j++);        &#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)        assert IntegerCache.high &gt;&#x3D; 127;    }    private IntegerCache() {}}\n总结一下，IntegerCache缓存的最小值是-128，最大值默认是127，可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改，最大值的范围是127到Integer.MAX_VALUE - (-low) -1。cache数组中下标0存的是-128，下标1存-127，依次类推，因此i的缓存是i + (-IntegerCache.low)举个例子：\n1234567Integer a &#x3D; 127;Integer b &#x3D; 127;Integer c &#x3D; 128;Integer d &#x3D; 128;System.out.println(a&#x3D;&#x3D;b); &#x2F;&#x2F;trueSystem.out.println(c&#x3D;&#x3D;d);&#x2F;&#x2F;falseSystem.out.println(c.equals(d));&#x2F;&#x2F;true\n上面的代码中，a和b使用的是缓存，所以a和b的地址都相同，而c和d是新建的对象，所以地址不相同。\n123456public boolean equals(Object obj) {    if (obj instanceof Integer) {        return value &#x3D;&#x3D; ((Integer)obj).intValue();    }    return false;}\nInteger中重写的equals方法是直接对比value的值，不是对比的对象地址，所以c.equals(d)为true。\nintValue()intValue中直接返回value的值。\n123public int intValue() {    return value;}\n其他包装类Java中提供了八种包装类Integer（int）、Long（long）、Double（double）、Short（short）、Float（float）、Byte(byte)、Character（char）、Boolean(boolean)八种包装类中，xxxValue基本一样，都是返回value值，我们重点看一下valueOf方法：\nLong1234567public static Long valueOf(long l) {    final int offset &#x3D; 128;    if (l &gt;&#x3D; -128 &amp;&amp; l &lt;&#x3D; 127) { &#x2F;&#x2F; will cache        return LongCache.cache[(int)l + offset];    }    return new Long(l);}\nLong并没有提供可以更改的缓存最大值，直接默认为127，并且不能更改。\nDouble123public static Double valueOf(double d) {    return new Double(d);}\nDouble的valueOf()方法没有使用缓存，道理很简单，以为小数位没法缓存，同理，Float一样。\nShort12345678public static Short valueOf(short s) {    final int offset &#x3D; 128;    int sAsInt &#x3D; s;    if (sAsInt &gt;&#x3D; -128 &amp;&amp; sAsInt &lt;&#x3D; 127) { &#x2F;&#x2F; must cache        return ShortCache.cache[sAsInt + offset];    }    return new Short(s);}\nShort包装类也是直接缓存-128到127。\nByte1234public static Byte valueOf(byte b) {    final int offset &#x3D; 128;    return ByteCache.cache[(int)b + offset];}\nbyte的取值范围是-128~127，因此byte不用判断上下界\nCharacter123456public static Character valueOf(char c) {    if (c &lt;&#x3D; 127) { &#x2F;&#x2F; must cache        return CharacterCache.cache[(int)c];    }    return new Character(c);}\nchar的最小值是0，所以没有判断最小值，缓存的最大值设置为127.\nBoolean123public static Boolean valueOf(boolean b) {    return (b ? TRUE : FALSE);}\n注意这里如果用“==”对比Boolean的包装类，都会返回true，例如：\n123456  Boolean a &#x3D; true;Boolean b &#x3D; true;Boolean c &#x3D; false;Boolean d &#x3D; false;System.out.println(a&#x3D;&#x3D;b); \t&#x2F;&#x2F;trueSystem.out.println(c&#x3D;&#x3D;d);\t&#x2F;&#x2F;true\n最后12345678910Integer a &#x3D; 1;Integer b &#x3D; 2;Integer c &#x3D; 3;Long d &#x3D; 2L;Long e &#x3D; 3L;System.out.println(c&#x3D;&#x3D;(a+b)); \t   &#x2F;&#x2F;trueSystem.out.println(c.equals(a+b));\t&#x2F;&#x2F;trueSystem.out.println(e&#x3D;&#x3D;(a+b));\t\t&#x2F;&#x2F;trueSystem.out.println(e.equals(a+b));\t&#x2F;&#x2F;falseSystem.out.println(e.equals(a+d));\t&#x2F;&#x2F;true\n\nc==(a+b) 中，a+b会触发自动拆箱和装箱，再和c比较，所以是true\nc.equals(a+b)，a+b触发自动拆箱和装箱，对比结果也是true\ne==(a+b)，a+b自动拆箱装箱变为3，e也自动拆箱变成3，所以返回true\ne.equals(a+b)，a+b自动拆箱装箱变成Integer类型的3，而e是Long类型，equals方法会先判断obj instanceof Long，如果传入的不是Long类型，会返回false\ne.equals(a+d) ，a和d自动拆箱后，因为d是Long类型，会自动转换成Long类型，再触发装箱变成Long类型，对比后为true。","url":"/2019/02/10/201902/Java基础之自动拆箱装箱/","link":"","plink":"http://example.com/2019/02/10/201902/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E8%A3%85%E7%AE%B1/"},{"title":"从线程安全角度看单例模式","content":"单例模式是一次只创建一个实例，不允许多个存在。所以让类自身保存它的唯一实例。这个类保证没有其他实例可以被创建，并提供一个其他类访问的方法。先前在设计模式-单例模式中简单了介绍一下，现在开始填这个坑，比较几种单例模式的线程安全问题。\n懒汉模式懒汉模式就是在对象第一次使用时创建对象，下面这种方式，是非线程安全的，因为当多个线程同时判断成功instance == null，就会创建多个对象。\n12345678910111213141516171819&#x2F;** * @author Gavin * 懒汉模式，单例实例在第一次使用时创建对象 *&#x2F;public class SingletonExample1 {\t&#x2F;&#x2F;私有构造函数\tprivate SingletonExample1() {\t\t\t}\t&#x2F;&#x2F;单例对象\tprivate static SingletonExample1 instance &#x3D; null;\t&#x2F;&#x2F;静态工厂方法\tpublic static SingletonExample1 getInstance(){\t\tif (instance &#x3D;&#x3D; null) {\t\t\tinstance &#x3D; new SingletonExample1();\t\t}\t\treturn instance;\t}}\n为了保证线程安全，如下面代码所示，我们对getInstance()添加synchronized关键字，保证同一时间只有一个线程访问getInstance()方法。这种方法一次只能允许一个线程访问，会造成严重的性能问题，虽然是线程安全，但是不推荐使用。\n123456789101112131415161718192021&#x2F;** *  * @author Gavin * 懒汉模式，单例实例在第一次使用时创建对象 *&#x2F;public class SingletonExample1 {\t&#x2F;&#x2F;私有构造函数\tprivate SingletonExample1() {\t\t\t}\t&#x2F;&#x2F;单例对象\tprivate static SingletonExample1 instance &#x3D; null;\t&#x2F;&#x2F;静态工厂方法\tpublic static synchronized SingletonExample1 getInstance(){\t\tif (instance &#x3D;&#x3D; null) {\t\t\tinstance &#x3D; new SingletonExample1();\t\t}\t\treturn instance;\t}\t}\n为了解决性能问题，我们使用双重同步锁单例模式，如下面代码所示，在进入锁之前，判断一次instance是否为空，获取锁之后，再判断一次，提高了程序的性能。但是，这真的是线程安全吗？  答案是否定的， 因为会发生CPU指令的重排序问题。当执行instance = new SingletonExample1()时，会进行3步操作：\n\n1.memory = allocate()   //分配对象内存空间\n2.ctorInstance()   //初始化对象\n3.instance = memory //设置instance指向刚分配的内存\n\n当JVM和CPU发生指令重排时，假如上面2和3步骤发生交换，当一个线程将instance指向刚分配的内存，另一个线程使用了返回的instance，但是这时还没有初始化对象，就会发生错误，这种错误发生的几率很小，但也是非线程安全的。\n12345678910111213141516171819202122232425&#x2F;** *  * @author Gavin * 懒汉模式，单例实例在第一次使用时创建对象 *&#x2F;public class SingletonExample1 {\t&#x2F;&#x2F;私有构造函数\tprivate SingletonExample1() {\t\t\t}\t&#x2F;&#x2F;单例对象\tprivate static SingletonExample1 instance &#x3D; null;\t&#x2F;&#x2F;静态工厂方法\tpublic static SingletonExample1 getInstance(){\t\tif (instance &#x3D;&#x3D; null) {\t\t\tsynchronized (SingletonExample1.class) {\t\t\t\tif(instance &#x3D;&#x3D; null){\t\t\t\t\tinstance &#x3D; new SingletonExample1();\t\t\t\t}\t\t\t}\t\t\t\t\t}\t\treturn instance;\t}}\n为了解决上面可能会出现的错误问题，需要用volatile修饰instance变量，防止指令重排序。如下面所示代码，为线程安全，并且推荐使用的方式。\n12345678910111213141516171819202122232425&#x2F;** *  * @author Gavin * 懒汉模式，单例实例在第一次使用时创建对象 *&#x2F;public class SingletonExample1 {\t&#x2F;&#x2F;私有构造函数\tprivate SingletonExample1() {\t\t\t}\t&#x2F;&#x2F;单例对象\tprivate static volatile SingletonExample1 instance &#x3D; null;\t&#x2F;&#x2F;静态工厂方法\tpublic static SingletonExample1 getInstance(){\t\tif (instance &#x3D;&#x3D; null) {\t\t\tsynchronized (SingletonExample1.class) {\t\t\t\tif(instance &#x3D;&#x3D; null){\t\t\t\t\tinstance &#x3D; new SingletonExample1();\t\t\t\t}\t\t\t}\t\t\t\t\t}\t\treturn instance;\t}}\n\n饿汉模式饿汉模式是在类装载时进行创建。下面这个类，是线程安全的，如果instance未被调用，会浪费资源。如果构造函数中包含过多处理，会导致加载非常慢。\n1234567891011121314151617&#x2F;** *  * @author Gavin * 饿汉模式   类装载时创建 *&#x2F;public class SingletonExample2 {\t&#x2F;&#x2F;私有构造函数\tprivate SingletonExample2() {\t\t\t}\t&#x2F;&#x2F;单例对象\tprivate static SingletonExample2 instance &#x3D; new SingletonExample2();\t&#x2F;&#x2F;静态工厂方法\tpublic static SingletonExample2 getInstance(){\t\treturn instance;\t}}\n除了上面直接创建对象，还有一种方法，可以将对象的创建放在静态代码块中，如下代码所示：\n12345678910111213141516171819202122&#x2F;** *  * @author Gavin * 饿汉模式   类装载时创建 *&#x2F;public class SingletonExample2 {\t&#x2F;&#x2F;私有构造函数\tprivate SingletonExample2() {\t\t\t}\t&#x2F;&#x2F;单例对象\tprivate static SingletonExample2 instance &#x3D; null;\t\tstatic {\t\tinstance &#x3D; new SingletonExample2();\t}\t&#x2F;&#x2F;静态工厂方法\tpublic static SingletonExample2 getInstance(){\t\treturn instance;\t}}\n枚举单例枚举单例模式，和懒汉模式相比，更容易保证线程安全；和饿汉模式相比，只有在实际调用时才初始化，保证了性能。因此推荐使用枚举模式。\n1234567891011121314151617181920212223242526272829303132package fun.gwt.base;&#x2F;** *  * @author Gavin * 线程安全 *&#x2F;public class SingletonExample3 {\t&#x2F;&#x2F;私有构造函数\tprivate SingletonExample3() {\t\t\t}\t&#x2F;&#x2F;静态工厂方法\tpublic static SingletonExample3 getInstance(){\t\treturn Singleton.INSTANCE.getInstance();\t}\t\tprivate enum Singleton {\t\tINSTANCE;\t\t\t\tprivate SingletonExample3 singleton;\t\t&#x2F;&#x2F;jvm保证这个方法绝对只调用一次\t\tSingleton() {\t\t\tsingleton &#x3D; new SingletonExample3();\t\t}\t\tpublic SingletonExample3 getInstance() {\t\t\treturn singleton;\t\t}\t}}","url":"/2019/02/14/201902/从线程安全角度看单例模式/","link":"","plink":"http://example.com/2019/02/14/201902/%E4%BB%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E8%A7%92%E5%BA%A6%E7%9C%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"动态规划","content":"动态规划的本质是递归加缓存解决动态规划的四个步骤：\n\n设计暴力算法，找到冗余\n设计并存储状态（一维，二维，三维数组，甚至用Map）\n递归式（状态转移方程）\n自底向上计算最优解（编程方式：把递归改为迭代）  \n\n（递归是自顶向下，循环是自底向上）Leetcode198题\n12345678910111213141516你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。示例 1:输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。示例 2:输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。\n从题目中可以看出，不能投相同的两间屋子，首先用DFS解决。下图中，根结点是0，表示从0号开始，决定偷还是不偷，如果决定偷0，那么1不能偷，只能偷2；如果不偷0，那么可以偷1. \n12345678910111213class Solution {    public int rob(int[] nums) {        return dfs(0,nums);    }    public int dfs(int idex, int[] nums) {        if(idex &gt;&#x3D; nums.length) {            return 0;        }        int a &#x3D; nums[idex] + dfs(idex + 2, nums);  &#x2F;&#x2F;从左边开始        int b &#x3D; 0 + dfs(idex + 1, nums);  &#x2F;&#x2F;从右边开始        return Math.max(a,b);    }}\n上面的代码可以解决问题，但是超出了时间限制，看上面的图，（2，n）和（3，n）出现了多次，所以在这个程序中有些结点计算了多次，那么可以使用缓存来保存这些节点，在需要的时候取出来。\n123456789101112131415161718192021class Solution {    Map&lt;Integer,Integer&gt; cache &#x3D; new HashMap&lt;Integer,Integer&gt;();    public int rob(int[] nums) {        return dfs(0,nums);    }    public int dfs(int idx, int[] nums) {        if(idx &gt;&#x3D; nums.length) {            return 0;        }        &#x2F;&#x2F;取之前先判断一下缓存中是否存在值        if(cache.containsKey(idx)) {            return cache.get(idx);        }        int a &#x3D; nums[idx] + dfs(idx + 2, nums);  &#x2F;&#x2F;从左边开始        int b &#x3D; 0 + dfs(idx + 1, nums);  &#x2F;&#x2F;从右边开始        int c &#x3D; Math.max(a,b);        &#x2F;&#x2F;将每次的值保存在缓存中        cache.put(idx,c);        return c;    }}\n递归调用会占用许多空间，下面改为迭代的方式，自底向上来解决问题：\n123456789101112131415161718class Solution {    Map&lt;Integer,Integer&gt; cache &#x3D; new HashMap&lt;Integer,Integer&gt;();    public int rob(int[] nums) {        if(nums.length &#x3D;&#x3D; 0) {            return 0;        }        int n &#x3D; nums.length;        cache.put(n - 1,nums[n - 1]); &#x2F;&#x2F;最后一个保存进去        for(int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) {            int a &#x3D; nums[i] + (cache.containsKey(i + 2) ? cache.get(i + 2) : 0);  &#x2F;&#x2F;从左边开始            int b &#x3D; 0 + (cache.containsKey(i + 1) ? cache.get(i + 1) : 0);  &#x2F;&#x2F;从右边开始            cache.put(i,Math.max(a,b));        }                return cache.get(0);    }}\n也可以使用数组来替换map，这样可以更节省空间:\n123456789101112131415161718class Solution {    int[] cache &#x3D; new int[100];    public int rob(int[] nums) {        if(nums.length &#x3D;&#x3D; 0) {            return 0;        }        if(nums.length &#x3D;&#x3D; 1) {            return nums[0];        }        int n &#x3D; nums.length;        cache[n - 1] &#x3D; nums[n - 1]; &#x2F;&#x2F;最后一个保存进去        cache[n - 2] &#x3D; Math.max(nums[n - 1],nums[n - 2]);        for(int i &#x3D; n - 3; i &gt;&#x3D; 0; i--) {            cache[i] &#x3D; Math.max(nums[i] + cache[i + 2],cache[i + 1]);        }        return cache[0];    }}","url":"/2019/02/15/201902/动态规划/","link":"","plink":"http://example.com/2019/02/15/201902/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"深入理解Java虚拟机--垃圾收集器与GC参数","content":"简介程序计数器、虚拟机栈和本地方法栈的生存周期就是线程的生存周期，因此不需要考虑垃圾回收。Java中，GC的对象是堆空间和永久区。\n怎么判断一个对象是否需要回收？引用计数法引用计数法就是给对象中添加一个引用计数器，当有对象引用时，计数器数值加1，引用失效时，计数器数值减1，当计数器数值为0，就通知GC回收对象。图片中的B对象引用了D对象，如果B对象不再引用D对象，D对象的计数器数值就置为0，这样GC也会收回D对象。如果对象之间存在循环引用，就会出现无法回收的对象。如下图所示：图中BCD循环引用，根对象已经不引用B对象，也就是说BCD对象应该被GC，但因为BCD计数器数值都不为0，因此引用计数法无法通知GC来回收对象。就是存在这种问题，Java虚拟机中没有选用引用计数法来判断对象是否存活。\n可达性分析算法在Java和C#等主流商用程序语言中，都是使用可达性分析算法来判断对象是否存活。算法思路是从一系列的“GC Roots”的对象最为起始点，从这些节点向下搜索，走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连，就说明此对象不可用。如下图所示：设A为根对象，如果A和B之间没有引用链相连，那么可以判定BCD不可达，需要GC来回收。GC Roots对象包括：\n\n虚拟机栈中引用的对象\n方法区中类静态属性引用的对象\n方法区中常量引用的对象\n本地方法栈中JNI引用的对象\n\n对象：我是不是还能拯救一下对象GC之前，至少要经过两次标记。如果对象在可达性分析算法之后，没有引用链与GC Roots相连，就会被第一次标记，如果对象没有覆盖finalize()方法或者已经调用过一次finalize()方法（finalize()方法只能被调用一次），就将这个对象回收。如果对象已经覆盖finalize()方法，并且未被调用finalize()方法，就将这个对象放在F-Queue的队列中，由Finalizer线程执行finalize()方法，但不承诺等待运行结束，如果对象未能在执行finalize()方法时自救成功，将会被GC第二次标记，并回收。finalize()方法中，对象重新和引用链中任何一个对象关联上，例如this指向某个类变量或者对象的成员变量，那这个对象就不会被回收。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546package fun.gwt.jvm;public class GC {\tpublic static GC SAVE_HOOK &#x3D; null;\tpublic void isAlive(){\t\tSystem.out.println(&quot;我还活着！&quot;);\t}\t@Override\tprotected void finalize() throws Throwable{\t\tsuper.finalize();\t\tSystem.out.println(&quot;执行finalize()方法！&quot;);\t\tGC.SAVE_HOOK &#x3D; this;\t}\tpublic static void main(String[] args) throws InterruptedException {\t\tSAVE_HOOK &#x3D; new GC();\t\t&#x2F;&#x2F;第一次拯救自己\t\tSystem.out.println(&quot;开始第一次拯救自己.....&quot;);\t\tSAVE_HOOK &#x3D; null;\t\tSystem.gc();\t\tThread.sleep(1000);\t\tif (SAVE_HOOK !&#x3D; null){\t\t\tSAVE_HOOK.isAlive();\t\t}else{\t\t\tSystem.out.println(&quot;我死了！&quot;);\t\t}\t\t\t\t&#x2F;&#x2F;第二次拯救自己\t\tSystem.out.println(&quot;开始第二次拯救自己.....&quot;);\t\tSAVE_HOOK &#x3D; null;\t\tSystem.gc();\t\tThread.sleep(1000);\t\tif (SAVE_HOOK !&#x3D; null){\t\t\tSAVE_HOOK.isAlive();\t\t}else{\t\t\tSystem.out.println(&quot;我死了！&quot;);\t\t}\t\t\t}}&#x2F;*开始第一次拯救自己.....执行finalize()方法！我还活着！开始第二次拯救自己.....我死了！*&#x2F;\n垃圾收集算法标记-清除算法标记清楚算法将垃圾回收分为两个阶段：标记阶段和清除阶段。标记阶段首先根据根结点，标记所有从根结点可达的对象，未被标记的对象就是垃圾对象。在清除阶段，清除所有未被标记的对象。可以看到，该算法有两个不足：一是效率问题，标记和清除的效率都不高；二是空间问题，标记清楚之后产生大量不连续的碎片。以上图为例，如果需要一块大小为4的连续空间，整理后的空间就无法分配。如果无法分配，将提前触发下一次垃圾收集动作。\n复制算法与标记-清除算法相比，复制算法是一种相对高效的回收方法，但是不适合像老年代这种存活对象较多的场合。存活对象较多，复制算法效率降低。复制算法将内存分为两个大小相同的部分，每次只用一块空间，垃圾收集时，将正在使用空间中的存活的对象复制到未使用的空间中，然后清除正在使用的空间，并交换两个内存的角色，完成垃圾回收。 \n标记-整理/压缩算法标记-整理算法适合存活对象较多的场合，比如老年代。标记-整理算法将所有对象做标记后，将存活的对象整理到内存的一段，然后清理边界外的所有空间。 \n总结虚拟机采用这种方法回收新生代，将新生代中的内存分为三部分，一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor空间。回收时将Eden和Survivor中存活的对象复制到另一块Survivor空间中，然后清理Eden和Survivor空间。Eden和两块Survivor空间的默认大小是8：1：1，每次都有10%的空间浪费。如果Survivor空间不足时将放到老年代中。具体详见：深入理解Java虚拟机–内存分代策略及常用参数配置下面的图实现了一次垃圾收集过程内存变化情况：新生代Eden中的大对象，如果Eden和Survivor中都无法存储，将直接存放到老年代中，Survivor中的老年对象进入老年代。最后Eden区和一块Survivor空间空闲。\n \n垃圾收集器Serial收集器(串行收集器)Serial收集器是最古老，最稳定的收集器，但是在执行垃圾回收时会暂停其他所有线程，直到它收集结束。虚拟机运行在Client模式下的默认新生代收集器，比其他收集器简单高效。\n1-XX:+UseSerialGC    &#x2F;&#x2F;新生代老年代使用串行回收\n该收集器在新生代和老年代使用串行回收；其中新生代使用复制算法，老年代使用标记-整理算法\nParNew收集器ParNew收集器是Serial收集器的多线程版本，新生代可以并行收集，老年代还是串行收集，所以只影响新生代。使用参数：\n12-XX:+UseParNewGC     &#x2F;&#x2F;使用ParNew收集器-XX:ParallelGCThreads &#x2F;&#x2F;限制线程数量\nParallel收集器Parallel 收集器和ParNew类似，新生代使用复制算法，老年代使用标记-整理算法。这个收集器更加关注吞吐量。  \n12345-XX:+UseParallelGC      &#x2F;&#x2F;使用Parallel收集器+ 老年代串行-XX:+UseParallelOldGC   &#x2F;&#x2F;使用Parallel收集器+ 并行老年代&#x2F;&#x2F;下面两个参数矛盾，因为停顿时间和吞吐量不能同时兼顾-XX:MaxGCPauseMills &#x2F;&#x2F;最大停顿时间，单位毫秒,GC尽力保证回收时间不超过设定值-XX:GCTimeRatio &#x2F;&#x2F;0-100的取值范围,垃圾收集时间占总时间的比,默认99，即最大允许1%时间做GC\nCMS收集器CMS（Concurrent Mark Sweep ）并发标记清除收集器是一种以获取最短回收停顿时间作为目标的收集器。CMS收集器使用的是标记-清除算法，并发阶段会降低吞吐量。CMS收集器是老年代收集器，新生代使用ParNew收集器。\n1-XX:+UseConcMarkSweepGC   &#x2F;&#x2F;启用CMS收集器\nCMS的标记过程分为四个阶段：\n1234初始标记并发标记重新标记并发清除\n如下图所示,初始标记和重新标记阶段需要“Stop The World”，整个过程中最耗时的并发标记和并发清除是和用户线程一起执行，所以是一种并发低停顿收集器。在JDK1.5默认设置，CMS收集器在老年代使用68%空间就会被激活，因为和用户线程一起运行，不能在空间快满时再清理,如果内存预留不够，会引起concurrent mode failure  \n1-XX:CMSInitiatingOccupancyFraction  &#x2F;&#x2F;设置触发GC的阈值\n虽然CMS收集器尽可能降低了停顿，但是会影响系统整体性能，在用户线程运行过程中，分一半CPU去执行GC，反应速度就下降一半。另外在清理阶段，用户线程还在运行，会产生新的垃圾，无法清理，导致清理不彻底。CMS使用的是标记-清理算法，因此会产生大量碎片，可以通过以下参数来整理碎片：\n1234-XX:+ UseCMSCompactAtFullCollection &#x2F;&#x2F;Full GC后，进行一次整理,整理过程是独占的，会引起停顿时间变长-XX:+CMSFullGCsBeforeCompaction &#x2F;&#x2F;设置进行几次Full GC后，进行一次碎片整理-XX:ParallelCMSThreads &#x2F;&#x2F;设定CMS的线程数量\nG1收集器G1收集器是JDK1.7中引入，在Java9中为JVM默认垃圾收集器。G1垃圾收集器主要应用在多CPU和大内存的服务器环境中，可以极大减少垃圾收集器的停顿时间，提升服务器性能，可以解决CMS中Concurrent Mode Failed问题，并逐步替换掉CMS.G1垃圾收集器不再将内存分为新生代和老年代，直接将堆空间划分为大小相同的子空间（Region），JVM可以设置这些Region空间的大小（每个子空间大小范围为1MB~32MB[必须是2的幂],最多可以设置2048个区域，最大支持32MB*2048=64G内存），每个Region标记为E、S、O和H，分别表示Eden、Survivor、Old、Humongous。其中E、S属于年轻代，O与H属于老年代。与CMS的标记-整理算法不同，G1从整体来看是基于标记-整理算法实现，从两个Region之间来看是基于复制算法实现。\nG1跟踪每个Region里面垃圾堆积的价值大小（回收所获空间大小以及回收所需时间的经验值），后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，从而保证G1收集器在有限的时间内获得更高的效率。\nGC参数123456789101112131415-XX:+UseSerialGC：在新生代和老年代使用串行收集器-XX:SurvivorRatio：设置eden区大小和survivior区大小的比例-XX:NewRatio:新生代和老年代的比-XX:+UseParNewGC：在新生代使用并行收集器-XX:+UseParallelGC ：新生代使用并行回收收集器-XX:+UseParallelOldGC：老年代使用并行回收收集器-XX:ParallelGCThreads：设置用于垃圾回收的线程数-XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器-XX:ParallelCMSThreads：设定CMS的线程数量-XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发-XX:+UseCMSCompactAtFullCollection：设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理-XX:CMSFullGCsBeforeCompaction：设定进行多少次CMS垃圾回收后，进行一次内存压缩-XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收-XX:CMSInitiatingPermOccupancyFraction：当永久区占用率达到这一百分比时，启动CMS回收-XX:UseCMSInitiatingOccupancyOnly：表示只在到达阀值的时候，才进行CMS回收\n参考资料1.周志明. 深入理解Java虚拟机[M]. 机械工业出版社, 2013.2G1从入门到放弃（一）","url":"/2019/02/12/201902/深入理解Java虚拟机垃圾收集器与GC参数/","link":"","plink":"http://example.com/2019/02/12/201902/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8EGC%E5%8F%82%E6%95%B0/"},{"title":"Servlet总结","content":"Servlet第一个Servlet项目1、创建MyServlet类，继承HttpServlet，并重写service方法\n12345678910111213141516package fun.gwt.www;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyServlet extends HttpServlet{\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp)\t\t\tthrows ServletException, IOException {\t\tresp.getWriter().write(&quot;&lt;h1&gt;Hello Servlet&lt;&#x2F;h1&gt;&quot;);\t}}\n2、修改web.xml文件）（在WebRoot/WEB-INF文件夹下）\n123456789101112131415&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot; id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;3.0&quot;&gt;\t&lt;!-- 配置Servlet --&gt;\t\t&lt;!-- 配置servlet类路径 --&gt;\t\t&lt;servlet&gt;\t\t\t&lt;servlet-name&gt;hello&lt;&#x2F;servlet-name&gt;\t\t\t&lt;servlet-class&gt;fun.gwt.www.MyServlet&lt;&#x2F;servlet-class&gt;\t\t&lt;&#x2F;servlet&gt;\t\t\t\t&lt;!-- 配置访问方式 --&gt;\t\t&lt;servlet-mapping&gt;\t\t\t&lt;servlet-name&gt;hello&lt;&#x2F;servlet-name&gt;\t\t\t&lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;\t\t&lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt;\n3、运行网站，浏览器中访问即可看到效果\n1http:&#x2F;&#x2F;localhost:8080&#x2F;ServletTest&#x2F;hello \nServlet生命周期修改MyServlet类，重写init()和destroy()方法。init()是Servlet第一次被加载时才会调用，其余时间不会再被调用。destroy()在Servlet被销毁时才会调用，一般是指Tomcat服务器关闭时才会调用。\n12345678910111213141516public class MyServlet extends HttpServlet{\t@Override\tpublic void init() throws ServletException {\t\tSystem.out.println(&quot;MyServlet 开始被加载！&quot;);\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp)\t\t\tthrows ServletException, IOException {\t\tresp.getWriter().write(&quot;&lt;h1&gt;Hello Servlet&lt;&#x2F;h1&gt;&quot;);\t\tSystem.out.println(&quot;处理请求中……&quot;);\t}\t@Override\tpublic void destroy() {\t\tSystem.out.println(&quot;MyServlet 被销毁！&quot;);\t}}\n下面的信息展示了四次请求Servlet的过程，只有第一次调用了init()方法，停止服务器时调用了destroy()方法。\n12345678910111213信息: Server startup in 440 msMyServlet 开始被加载！处理请求中……处理请求中……处理请求中……处理请求中……二月 23, 2019 11:04:36 下午 org.apache.coyote.http11.Http11Protocol pause信息: Pausing Coyote HTTP&#x2F;1.1 on http-8080二月 23, 2019 11:04:37 下午 org.apache.catalina.core.StandardService stop信息: Stopping service CatalinaMyServlet 被销毁！二月 23, 2019 11:04:38 下午 org.apache.coyote.http11.Http11Protocol destroy信息: Stopping Coyote HTTP&#x2F;1.1 on http-8080\n上面是在第一次访问Servlet时才执行init()方法，如果在web.xml中添加1，就会在服务器启动时调用init()方法。\nservice()、doGet()和doPost()方法1234567891011121314151617public class MyServlet extends HttpServlet{\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp)\t\t\tthrows ServletException, IOException {\t\tresp.getWriter().write(&quot;&lt;h1&gt;Hello service&lt;&#x2F;h1&gt;&quot;);\t}\t@Override\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\t\t\tthrows ServletException, IOException {\t\tresp.getWriter().write(&quot;&lt;h1&gt;Hello doGet&lt;&#x2F;h1&gt;&quot;);\t}\t@Override\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp)\t\t\tthrows ServletException, IOException {\t\tresp.getWriter().write(&quot;&lt;h1&gt;Hello doPost&lt;&#x2F;h1&gt;&quot;);\t}}\ndoGet()是接收get请求，doPost()接收post请求。在上面的代码中，service()、doGet()和doPost()同时存在，这时无论浏览器是get请求还是post请求，Servlet都会调用service()方法，而不去调用doGet()或doPost()方法。值得注意的是：service()中如果存在super.service(req, resp);那么Servlet会调用完service()方法后再调用一次doGet()或doPost()方法，但是Servlet中要存在你重写的doGet或doPost方法，如果不存在则报405错误（父类会调用子类的doGet()或doPost()方法,如果子类中不存在，就调用父类的doGet()或doPost()方法，父类的doGet()或doPost()方法中自定义了405状态码，所以返回405）。 \nHttpServletRequest服务器接收到浏览器请求后，会创建一个Request对象，对象中存储了请求的数据。可以获取到请求头数据、请求行数据和用户数据。获取请求头数据：\n1234567891011121314151617@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp)\t\t\tthrows ServletException, IOException {\t\t&#x2F;&#x2F;获取请求头数据\t\t\t&#x2F;&#x2F;获取请求方式\t\t\tString method &#x3D; req.getMethod();\t\t\tSystem.out.println(&quot;method is &quot;+ method);\t\t\t&#x2F;&#x2F;获取请求url\t\t\tStringBuffer url &#x3D; req.getRequestURL();\t\t\tSystem.out.println(&quot;URL is &quot;+url);\t\t\t&#x2F;&#x2F;获取uri\t\t\tString uri &#x3D; req.getRequestURI();\t\t\tSystem.out.println(&quot;uri is &quot;+ uri);\t\t\t&#x2F;&#x2F;获取协议\t\t\tString sch &#x3D; req.getScheme();\t\t\tSystem.out.println(&quot;Scheme is &quot;+sch);\t}\n输出数据为：\n1234method is GETURL is http:&#x2F;&#x2F;localhost:8080&#x2F;ServletTest&#x2F;hellouri is &#x2F;ServletTest&#x2F;helloScheme is http\n获取请求行数据：  \n1234567891011@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp)\t\t\tthrows ServletException, IOException {\t\t&#x2F;&#x2F;获取请求行数据\t\tEnumeration e &#x3D; req.getHeaderNames();\t\twhile (e.hasMoreElements()){\t\t\tString headName &#x3D; (String) e.nextElement();\t\t\tString value &#x3D; req.getHeader(headName);\t\t\tSystem.out.println(headName + &quot; is &quot; + value);\t\t}\t}\n输出数据为：\n123456789host is localhost:8080connection is keep-alivecache-control is max-age&#x3D;0upgrade-insecure-requests is 1user-agent is Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;70.0.3538.110 Safari&#x2F;537.36accept is text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8accept-encoding is gzip, deflate, braccept-language is zh-CN,zh;q&#x3D;0.9\n获取用户数据（如果数据不存在，不会报错，返回null数据）：\n12String name &#x3D; req.getParameter(&quot;name&quot;);String name &#x3D; req.getParameter(&quot;password&quot;);\nHttpServletResponseResponse对象用来响应数据，将结果返回到浏览器显示。\n12345678910111213141516171819@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp)\t\t\tthrows ServletException, IOException {\t\t&#x2F;&#x2F;设置响应头\t\tresp.setHeader(&quot;key&quot;, &quot;value&quot;);  \t&#x2F;&#x2F;注意，使用setHeader会覆盖掉相同的key\t\tresp.addHeader(&quot;key&quot;, &quot;value&quot;);\t\t&#x2F;&#x2F;使用addHeader只会追加数据，不会覆盖重复\t\t&#x2F;&#x2F;设置响应状态码\t\t&#x2F;&#x2F;resp.sendError(405,&quot;禁止访问！&quot;);   &#x2F;&#x2F;设置后网页访问会出现405禁止访问！\t\t&#x2F;&#x2F;设置响应编码格式\t\t&#x2F;&#x2F;resp.setHeader(&quot;content-type&quot;, &quot;text&#x2F;html;charset&#x3D;utf-8&quot;);\t\t&#x2F;&#x2F;resp.setContentType(&quot;text&#x2F;plain;charset&#x3D;utf-8&quot;);  &#x2F;&#x2F;html标签直接出书\t\t&#x2F;&#x2F;resp.setContentType(&quot;text&#x2F;xml;charset&#x3D;utf-8&quot;);\t\tresp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);   &#x2F;&#x2F;输出html标签的效果\t\t&#x2F;&#x2F;设置响应状态吗\t\t&#x2F;&#x2F;resp.sendError(404, &quot;this Method is not supported&quot;);\t\t&#x2F;&#x2F;设置响应实体\t\tresp.getWriter().write(&quot;&lt;h1&gt;Hello Servlet&lt;&#x2F;h1&gt;&quot;);\t}\n请求转发1req.getRequestDispatcher(&quot;hi&quot;).forward(req, resp);\n在一个Servlet跳转到另一个Servlet，其中hi是另一个Servlet的url地址，也就是/hi，注意这里地址栏不会变，例如我请求/hello，如果hello的Servlet请求转发到/hi。虽然请求了hi，但是地址还是/hello\n重定向1resp.sendRedirect(&quot;hi&quot;);\nCookie123Cookie c &#x3D; new Cookie(&quot;key&quot;, &quot;value&quot;);resp.addCookie(c);resp.getWriter().write(&quot;设置Cookie&quot;);\n添加完Cookie之后，在Cookie还有效的情况下，每次请求浏览器都会带着Cookie请求。当重新启动浏览器后，Cookie就消失了，因为这个临时Cookie存在浏览器的内存中。通过setMaxAge参数为Cookie设置存活时间，当重启浏览器后Cookie还有效。\n1234Cookie c &#x3D; new Cookie(&quot;key&quot;, &quot;value&quot;);c.setMaxAge(3 * 24 * 3600);  &#x2F;&#x2F;设置参数为秒，这里设置了3天resp.addCookie(c);resp.getWriter().write(&quot;设置Cookie&quot;);\n还可以设置Cookie的有效路径：\n1c.setPath(&quot;&#x2F;ServletTest&#x2F;hi&quot;);   &#x2F;&#x2F;只有在&#x2F;ServletTest&#x2F;hi&quot;路径才会由浏览器携带到服务器\n取出来Cookie也是非常简单：\n123456   Cookie[] cks &#x3D; req.getCookies();for (Cookie cookie : cks) {\tString key &#x3D; cookie.getName();\tString value &#x3D; cookie.getValue();\tSystem.out.println(key+&quot; : &quot;+value);}\nSession1HttpSession hs &#x3D; req.getSession();\n如果请求中有Session的标识符：JSESSIONID，那么直接返回Session。如果没有JSESSIONID，那么将会创建新的Session对象，并将JSESSIONID作为Cookie返回到浏览器中。注意：关闭浏览器后Cookie中的JSESSIONID就会失效，HttpSession自动进行Cookie操作，为了将JSESSIONID保存时间更长，可以获取到SessionID，自己保存到Cookie中，这样就能将  JSESSIONID保存在硬盘中。   \n还可以设置Session过期时间：\n1hs.setMaxInactiveInterval(1000); &#x2F;&#x2F;1000秒过期\n设置Session强制失效：\n1hs.invalidate();\n存储数据到Session中：\n1hs.setAttribute(String,Object);\n获取出来Session数据：\n1hs.getAttribute(String);\nServletContextServletContext对象解决了不同用户的数据共享问题，由服务器创建，一个项目只有一个对象。\n123   ServletContext sc1 &#x3D; this.getServletContext();ServletContext sc2 &#x3D; this.getServletConfig().getServletContext();ServletContext sc3 &#x3D; req.getSession().getServletContext();\n上面三种创建方式，获取的都是同一个ServletContext对象。存储数据：\n1sc1.setAttribute(String, Object);\n获取数据：\n1sc1.getAttribute(String);   &#x2F;&#x2F;获取出来的是对象\n还可以获取web.xml文件中的键值对,在web.xml中添加：\n1234&lt;context-param&gt;\t&lt;param-name&gt;aaa&lt;&#x2F;param-name&gt;\t&lt;param-value&gt;hello&lt;&#x2F;param-value&gt;&lt;&#x2F;context-param&gt;\n可以看到name为aaa，value为hello，可以使用：\n12sc1.getInitParameter(&quot;aaa&quot;); &#x2F;&#x2F;返回单个namesc1.getInitParameterNames(); &#x2F;&#x2F;返回多个键值对key的枚举\n获取根目录下静态资源的绝对路径:\n1String str &#x3D; sc1.getRealPath(&quot;&#x2F;a.txt&quot;);\t\n获取根目录下静态资源的流对象：\n1InputStream is &#x3D; sc1.getResourceAsStream(&quot;&#x2F;a.txt&quot;);\nServletConfig对象ServletConfig对象是Servlet的配置对象，每个Servlet都有一个ServletConfig对象，可以获取web.xml中的配置信息。首先在xml的Servlet中配置，然后设置键值对。\n12345678   &lt;servlet&gt;\t&lt;servlet-name&gt;hello&lt;&#x2F;servlet-name&gt;\t&lt;servlet-class&gt;fun.gwt.www.MyServlet&lt;&#x2F;servlet-class&gt;\t&lt;init-param&gt;\t\t&lt;param-name&gt;config&lt;&#x2F;param-name&gt;\t\t&lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;\t&lt;&#x2F;init-param&gt;&lt;&#x2F;servlet&gt;\n在Servlet中获取方式:\n12   ServletConfig sc &#x3D; this.getServletConfig();String config &#x3D; sc.getInitParameter(&quot;config&quot;);","url":"/2019/11/30/201911/Servlet总结/","link":"","plink":"http://example.com/2019/11/30/201911/Servlet%E6%80%BB%E7%BB%93/"},{"title":"Redis高级应用--主从复制","content":"简介高并发互联网架构追求高并发，高性能和高可用。其中高并发指允许大量用户同时访问，高可用指服务器宕机时间少。业界高可用目标为5个9，即可用性达到99.999%，也就是说服务器年宕机时长低于315秒，计算公式为：（31536000-宕机时间）/ 31536000 * 100%   （31536000 = 365 * 24* 60 * 60=1年）\n主从复制作用1、读写分离：master写，slave读，提高服务器的读写负载能力2、负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，由slave提供服务，实现快速的故障恢复3、故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复4、数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式5、高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案    \n主从复制工作流程主从复制可分为三个阶段：\n\n建立连接阶段\n数据同步阶段\n命令传播阶段\n\n建立连接阶段工作流程\n\n\nmaster\nslave\n\n\n\n/\n1、发送指令：slaveof ip port\n\n\n2、接收指令，响应slave\n/\n\n\n/\n3、保存master 的ip和端口\n\n\n/\n4、根据保存的信息创建连接master的socket\n\n\n/\n5、周期性发送命令：ping\n\n\n6、响应pong\n/\n\n\n/\n7、发送指令：auth password\n\n\n8、验证授权\n/\n\n\n/\n9、发送指令：replconflistening-port \n\n\n10、保存slave的端口号\n/\n\n\n主从连接指令（slave使用）方式一：客户端发送命令\n1slaveof &lt;masterip&gt; &lt;masterport&gt;\n方式二：启动slave服务器时加参数\n1redis-server -slaveof  &lt;masterip&gt; &lt;masterport&gt;\n方式三：服务器配置(保存在conf文件中)\n1slaveof &lt;masterip&gt; &lt;masterport&gt;\n主从断开连接（slave使用）slave客户端发送命令：\n1slaveof no one\n数据同步阶段工作流程\n\n\nmaster\nslave\n\n\n\n/\n1、发送指令：psync2\n\n\n2、执行bgsave\n/\n\n\n3、第一个slave连接时，创建复制缓冲区（复制缓存区中保存生成RDB文件时master服务器执行的命令）\n/\n\n\n4、生成RDB文件，通过socket发送给slave\n/\n\n\n/\n5、接收RDB文件，清空数据，执行RDB文件恢复过程\n\n\n/\n6、发送命令告知RDB恢复已经完成\n\n\n7、发送复制缓冲区数据\n/\n\n\n/\n8、接收信息，执行bgrewriteaof,恢复数据\n\n\n数据同步阶段，1-5称为全量复制，使用RDB方式同步；6-8称为部分复制，使用AOF方式同步。这是因为全量复制时，还会有master服务器还会执行指令，因此需要保存这些指令，待全量复制后，同步这一部分数据。\n部分复制阶段短时间断网，可以使用部分复制来实现同步，而不必全量复制。使用部分数据需要三个要素：\n\n服务器运行id（run id）；\n主服务器的复制积压缓冲区\n主从服务器的复制偏移量\n\n服务器运行id\n服务器运行id是每台服务器运行时的身份识别码，一台服务器运行多次可以生成多个运行id\n运行id由40位字符组成，是随机十六进制字符\n用于服务器之间传输，识别身份\n\n复制缓冲区\n复制缓冲区又叫复制积压缓冲区，是一个先进先出的队列，用于存储服务器执行过的命令，每次传播命令，master将命令记下来，存储在复制缓冲区。例如下面命令：1set name gavin\n保存为AOF格式为：123456$3 \\r\\n  #3表示指令的大小set \\r\\n$4 \\r\\nname \\r\\n$5 \\r\\ngavin \\r\\n\n然后将上面的数据保存在复制缓冲区中，复制缓冲区由偏移量和字节值组成,字节值表示上面指令，偏移量表示每个字节值代表的递增编号：\n\n\n\n\n偏移量\n9041\n9042\n9043\n9044\n9045\n9046\n9047\n9048\n9049\n9050\n9051\n9052\n9053\n9054\n\n\n\n字节值\n…\n$\n3\n\\r\n\\n\ns\ne\nt\n\\r\n\\n\n$\n4\n\\r\n…\n\n\n偏移量\n偏移量是一个数字，描述缓冲区中指令字节位置\nmaster端每发送一次指令记录一次，slave端接收一次指令记录一次\nslave断线后对比master和slave的差异，然后恢复数据\n\n\n\n\nmaster\nslave\n\n\n\n/\n1、发送指令： psync2 runid offset\n\n\n2、执行bgsave生成RDB文件，记录当前复制偏移量offset\n/\n\n\n3、发送+FULLRESYNC runid offset 发送RDB文件给slave\n/\n\n\n/\n4、收到+FULLRESYNC 保存master的runid和offset，清空全部数据，接收RDB文件，恢复RDB数据\n\n\n/\n5、发送命令：psync2 runid offset\n\n\n6、接收命令，判断runid是否匹配，判断offset是否在复制缓冲区中\n/\n\n\n7、如果runid或offset有一个不满足，执行全量复制\n/\n\n\n7、如果runid或offset校验通过，offset与offset相同，忽略，不用执行同步\n/\n\n\n7、如果runid或offset校验通过，offset与offset不同，发送+ CONTINUE offset ，发送复制缓冲区中两个offset之间的数据\n/\n\n\n/\n8、收到+CONTINUE 保存master的offset接收 信息后，执行bgrewriteaof，恢复数据\n\n\n命令传播阶段工作流程心跳机制\nmaster心跳：\n指令：PING\n周期：由repl-ping-slave-period决定，默认10秒\n作用：判断slave是否在线\n查询：INFO replication (获取slave最后一次连接时间间隔，lag维持在0或者1视为正常)\n\n\nslave心跳\n指令：REPLCONF ACK {offset}\n周期：1秒\n作用：汇报slave自己的复制偏移量，获取追星数据变更指令，判断master是否在线\n\n\n\n12min-slaves-to-write 2  min-slaves-max-lag 8\nslave数量少于2个，或者所有slave的延迟都大于等于8时，此时master只能读，不能写，同时关闭数据同步功能。\n命令传播\n\n\nmaster\nslave\n\n\n\n1、发送命令：ping\n1、发送命令：replconf ack offset\n\n\n2、接收命令，判断offset是否在复制缓冲区中\n/\n\n\n3、offset不在缓冲区，执行全量复制\n/\n\n\n3、如果offset在缓冲区，master的offset与slave的offset相同，忽略，不用执行同步\n/\n\n\n3、如果offset在缓冲区，master的offset与slave的offset不同，发送+ CONTINUE offset ，发送复制缓冲区中两个offset之间的数据\n/\n\n\n/\n4、收到+CONTINUE 保存master的offset接收 信息后，执行bgrewriteaof，恢复数据\n\n\n数据同步说明1、复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失情况，必须进行第二次全量复制，导致slave陷入死循环，因此可以设置复制缓冲区大小：\n1repl-backlog-size 1mb\n2、master单机内存占用主机内存比例不应过大，建议使用50%70%的内存，留下30%50%的内存用于执行bgsave命令和创建复制缓冲区。3、为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务\n1slave-serve-stale-data yes|no","url":"/2019/12/17/201912/Redis高级应用主从复制/","link":"","plink":"http://example.com/2019/12/17/201912/Redis%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"},{"title":"Redis高级应用--事务和分布式锁","content":"简单用法Redis使用MULTI、EXEC、DISCARD和WATCH等命令实现事务。下面是Redis事务的用法，使用MULTI命令开始后，Redis会判断输入的命令是否是MULTI、EXEC、DISCARD和WATCH中的一个，如果是，则执行命令，否则会将命令保存在队列中，最后执行EXEC命令提交事务。Redis执行事务期间，服务器不会去执行其他命令，等事务中所有命令执行完毕才会处理其他请求。\n123456789127.0.0.1:6379&gt; MULTI  # 事务开始OK127.0.0.1:6379&gt; SET name &quot;11231&quot; #命令入队QUEUED127.0.0.1:6379&gt; GET name  #命令入队QUEUED127.0.0.1:6379&gt; EXEC  #事务执行1) OK2) &quot;11231&quot;\nRedis提供DISCARD命令取消事务：\n123456789101112127.0.0.1:6379&gt; SET name &quot;123&quot;OK127.0.0.1:6379&gt; GET name&quot;123&quot;127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; DEL nameQUEUED127.0.0.1:6379&gt; DISCARD   # 取消事务OK127.0.0.1:6379&gt; GET name&quot;123&quot;\n如果输入的命令语法错误，会直接报错.但是Redis无法判断输入的指令是否存在逻辑错误。例如下面的例子，Redis在事务执行前可以判断出来”XPUSH”是不合法的命令，但是无法判断”name”是字符串类型，而不是列表型，只有执行后才报错。\n12345678910111213141516171819127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; XPUSH 123 123(error) ERR unknown command &#39;XPUSH&#39;127.0.0.1:6379&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; del name(integer) 1127.0.0.1:6379&gt; SET name 123  # name是字符串类型OK127.0.0.1:6379&gt; GET name&quot;123&quot;127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; LPUSH name 123 321  # 将name作为列表型保存QUEUED127.0.0.1:6379&gt; EXEC1) (error) WRONGTYPE Operation against a key holding the wrong kind of value\nWATCH命令WATCH命令是一个乐观锁，它可以在EXEC命令执行之前，监视任意数量的key，并在EXEC命令执行时，检查被监视的键是否至少有一个已经修改，如果是的话，服务器拒绝执行事务，并返回空恢复。\n123456789101112131415161718127.0.0.1:6379&gt; WATCH name  # 开始监视name键OK127.0.0.1:6379&gt; SET name 321 # 这个命令修改了name的值，这里模拟的是其他客户端修改name得值OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; SET haha 321  # 这里可以执行任意指令，因为watch监视的键，和事务中操作的键没有关联。QUEUED127.0.0.1:6379&gt; EXEC # EXEC命令执行前，name的值已经被修改，所以返回nil(nil)127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; SET name 321QUEUED127.0.0.1:6379&gt; EXEC # 第二次执行事务，WATCH的监视已经消失，虽然前面name已经被修改，这里还可以操作name1) OK127.0.0.1:6379&gt; GET name&quot;321&quot;\n还可以使用UNWATCH命令取消所有键的监视。\n回滚Redis的事务和关系型数据库事务最大的区别是没有事务失败后的回滚操作。如下例子，如果事务执行失败，在失败命令之前的命令都会执行，并且无法回滚，需要手动回滚。\n1234567891011121314151617127.0.0.1:6379&gt; KEYS *(empty list or set)127.0.0.1:6379&gt; SET name gavin # name是字符串类型OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; SET age 1 QUEUED127.0.0.1:6379&gt; LPUSH name 123 321 # name是字符串型，这里当成数组使用，会报错QUEUED127.0.0.1:6379&gt; EXEC1) OK  2) (error) WRONGTYPE Operation against a key holding the wrong kind of value127.0.0.1:6379&gt; KEYS *  #事务执行后，虽然报错，但是age已经被添加进去，没有回滚1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt;\n分布式锁分布式使用SETNX（set if not exists）设置公共锁。SETNX命令，可以判断key是否有值，有值返回设置失败，无值则返回设置成功。\n1SETNX key value\n\n对于返回设置成功的，拥有控制权，进行下一步的业务操作\n对于返回设置失败的，不具有控制权，则排队或者等待\n\n死锁Redis分布式锁中，使用SETNX命令进行简单的上锁，如果上锁的机器因为一些原因掉线，将会一直占用锁，造成死锁，因此需要一些特殊处理。参考资料中Redisson给出了一个很好的解决办法：首先使用正常的方式加锁，再为myLock设置30秒的生存时间，避免发生死锁。\n1234SETNX myLock 客户端id #设置客户端id，这样客户端在下次进入时判断哪个客户端占用锁，实现可重入锁pexpire myLock 30000.....     # 执行业务操作del myLock   # 执行完毕删除锁\n然后客户端通过一个线程每10s就去判断客户端是否释放锁，如果客户端还持有锁，然后就延长锁的生存时间。这样就保证了客户端存活时一直占有锁，掉线时则自动过期，让别的客户端取占有锁。当然真实业务中不可能持有锁30秒，一般使用如下规则：\n\n例如：持有锁的操作最长执行时间127ms，最短执行时间7ms\n测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时\n锁时间设定推荐：最大耗时 * 120% + 平均网络延迟* 110%\n如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可\n\n参考资料Redis分布式锁","url":"/2019/12/12/201912/Redis高级应用事务和分布式锁/","link":"","plink":"http://example.com/2019/12/12/201912/Redis%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"title":"Redis高级应用--对象的实现原理","content":"对象的类型Redis有5中基本数据类型，使用TYPE命令，即可查看对象类型:\n1234127.0.0.1:6379&gt; SET name gavinOK127.0.0.1:6379&gt; TYPE namestring\n\n\n\n对象\nTYPE类型输出\n\n\n\n字符串对象\n“string”\n\n\n列表对象\n“list”\n\n\n哈希对象\n“hash”\n\n\n集合对象\n“set”\n\n\n有序集合对象\n“zset”\n\n\n对象的编码Redis使用OBJECT ENCODING命令查看对象内部实现数据结构：\n12345678127.0.0.1:6379&gt; SET name gavinOK127.0.0.1:6379&gt; SET age 10OK127.0.0.1:6379&gt; OBJECT ENCODING name&quot;embstr&quot;127.0.0.1:6379&gt; OBJECT ENCODING age&quot;int&quot;\n\n\n\n对象底层数据结构\nOBJECT ENCODING命令输出\n\n\n\n整数\nint\n\n\nembstr编码的简单动态字符串\nembstr\n\n\n简单动态字符串\nraw\n\n\n字典\nhashtable\n\n\n双端链表\nlinkedlist\n\n\n压缩列表\nziplist\n\n\n整数集合\nintset\n\n\n跳跃表和字典\nskiplist\n\n\n快速列表\nquicklist\n\n\n字符串对象字符串对象编码有三种int、embstr和raw\nint如果字符串保存的是整数，长度小于等于20字节，并且能转为整形，则编码为int\n12345678910111213141516171819202122232425262728len &#x3D; sdslen(s);&#x2F;&#x2F;判断字符串长度是否小于20，并且s为long类型if (len &lt;&#x3D; 20 &amp;&amp; string2l(s,len,&amp;value)) {    &#x2F;* This object is encodable as a long. Try to use a shared object.     * Note that we avoid using shared integers when maxmemory is used     * because every object needs to have a private LRU field for the LRU     * algorithm to work well. *&#x2F;    if ((server.maxmemory &#x3D;&#x3D; 0 ||        !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;        value &gt;&#x3D; 0 &amp;&amp;        value &lt; OBJ_SHARED_INTEGERS)      {        decrRefCount(o);        incrRefCount(shared.integers[value]);&#x2F;&#x2F; 如果数字在0到10000之间，使用大小为10000的共享数组        return shared.integers[value];  &#x2F;&#x2F;直接返回共享数组中的地址    } else {        if (o-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_RAW) {            sdsfree(o-&gt;ptr);            o-&gt;encoding &#x3D; OBJ_ENCODING_INT;            o-&gt;ptr &#x3D; (void*) value;            return o;        } else if (o-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_EMBSTR) {            decrRefCount(o);            return createStringObjectFromLongLongForValue(value);        }    }}\n12345678910111213141516171819&#x2F;&#x2F; 用到的其他定义#define OBJ_SHARED_INTEGERS 10000extern struct sharedObjectsStruct shared;struct sharedObjectsStruct {    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,    *colon, *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],    *emptyarray, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,    *rpop, *lpop, *lpush, *rpoplpush, *zpopmin, *zpopmax, *emptyscan,    *multi, *exec,    *select[PROTO_SHARED_SELECT_CMDS],    *integers[OBJ_SHARED_INTEGERS],   &#x2F;&#x2F;定义大小为10000的数组    *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], &#x2F;* &quot;*&lt;value&gt;\\r\\n&quot; *&#x2F;    *bulkhdr[OBJ_SHARED_BULKHDR_LEN];  &#x2F;* &quot;$&lt;value&gt;\\r\\n&quot; *&#x2F;    sds minstring, maxstring;};\n\n\nembstr和rawembstr和raw的分界线是44字节，如果大于44字节，使用raw，小于等于44字节使用embstr编码\n1234567#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44     robj *createStringObject(const char *ptr, size_t len) {    if (len &lt;&#x3D; OBJ_ENCODING_EMBSTR_SIZE_LIMIT)    &#x2F;&#x2F;  字符串长度小于44，使用EmbeddedString         return createEmbeddedStringObject(ptr,len);    else        return createRawStringObject(ptr,len);   &#x2F;&#x2F;字符串大于44，使用Raw}\n\n\n列表对象列表对象在3.2版本之前使用ziplist和linkedlist两种编码，在3.2版本之后使用quicklist编码。\nquicklist1234127.0.0.1:6379&gt; LPUSH list 1 2 3(integer) 3127.0.0.1:6379&gt; OBJECT ENCODING list&quot;quicklist&quot;\n\n\n哈希对象哈希对象编码使用ziplist和hashtable\n\n哈希对象保存的键值对的键和值得字符串长度都小于64字节使用ziplist\n哈希对象的键值对数量小于512个使用ziplist\n\n1234567891011121314151617181920127.0.0.1:6379&gt; hset book name 1234567890123456789012345678901234567890123456789012345678901234(integer) 0127.0.0.1:6379&gt; OBJECT ENCODING book&quot;ziplist&quot;127.0.0.1:6379&gt; hset book name 12345678901234567890123456789012345678901234567890123456789012345(integer) 0127.0.0.1:6379&gt; OBJECT ENCODING book&quot;hashtable&quot;127.0.0.1:6379&gt; EVAL &quot;for i&#x3D;1, 512 do redis.call(&#39;HSET&#39;, KEYS[1], i, i)end&quot; 1 &quot;numbers&quot;(nil)127.0.0.1:6379&gt; HLEN numbers(integer) 512127.0.0.1:6379&gt; OBJECT ENCODING numbers&quot;ziplist&quot;127.0.0.1:6379&gt; HMSET numbers &quot;key&quot; &quot;value&quot;OK127.0.0.1:6379&gt; HLEN numbers(integer) 513127.0.0.1:6379&gt; OBJECT ENCODING numbers&quot;hashtable&quot;\n\n\n集合对象集合对象编码使用intset和hashtable两种\n\n集合对象保存的都是整数，但是不超过512个，使用intset编码\n\n123456789101112131415161718127.0.0.1:6379&gt; sadd numbers 1 2 3 4 5(integer) 5127.0.0.1:6379&gt; OBJECT ENCODING numbers&quot;intset&quot;127.0.0.1:6379&gt; sadd name &quot;h&quot; &quot;gavin&quot;(integer) 2127.0.0.1:6379&gt; OBJECT ENCODING name&quot;hashtable&quot;127.0.0.1:6379&gt; EVAL &quot;for i&#x3D;1, 512 do redis.call(&#39;SADD&#39;, KEYS[1], i)end&quot; 1 &quot;numbers&quot;(nil)127.0.0.1:6379&gt; SCARD numbers(integer) 512127.0.0.1:6379&gt; OBJECT ENCODING numbers&quot;intset&quot;127.0.0.1:6379&gt; SADD numbers 12312(integer) 1127.0.0.1:6379&gt; OBJECT ENCODING numbers&quot;hashtable&quot;\n\n\n有序集合对象有序集合对象编码使用ziplist和skiplist\n\n有序集合保存元素数量小于128个使用ziplist\n有序集合保存元素成员长度小于64字节使用ziplist\n\n12345127.0.0.1:6379&gt; ZADD price 1  apple123456789012345678901234567890123456789012345678901234567890(integer) 1127.0.0.1:6379&gt; OBJECT ENCODING price&quot;skiplist&quot;","url":"/2019/12/25/201912/Redis高级应用对象的实现原理/","link":"","plink":"http://example.com/2019/12/25/201912/Redis%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"title":"Redis高级应用--阻塞的原因","content":"简介Redis是单线程架构，如果该线程出现阻塞，将导致Redis不能提供服务。导致阻塞问题的场景大致分为两种原因：\n\n内在原因：不合理使用API或数据库、CPU饱和、持久化阻塞\n外在原因：CPU竞争、内存交换和网络问题等内在原因API或数据结构使用不合理Redis可以使用慢查询功能获取慢查询命令，默认超过10毫秒的命令都记录到定长队列（默认128）中。如果命令执行时间是毫秒级，实际OPS只有1000多，因此需要找到慢的查询指令，并进行优化。Redis两个和慢查询日志相关的选项：1234slowlog-log-slower-than    1 # 指定超过1毫秒的命令会被记录到日志上slowlog-max-len 128 # 设置保存128条日志（先进先出，超过128条会丢掉前面的日志）slowlog get {n}     # 获取n条慢查询命令，不适用n则获取全部慢查询日志\n发现慢查询后，可以对命令及时调整：\n修改为低时间复杂度的命令，禁用keys、sort等命令\n调整大对象：将大对象拆分为多个小对象\n\nCPU饱和Redis使用单线程，CPU饱和是指Redis将CPU跑到接近100%，其他命令就无法执行，从而造成阻塞。使用top命令，可以看到Redis线程使用CPU达到92.3%。\n123PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND 28 gavin     20   0  582064 537320   1660 R  92.3  6.5   0:39.32 redis-server 44 gavin     20   0   20840   1372   1000 S   0.0  0.0   0:00.03 redis-cli\n持久化阻塞持久化阻塞操作有：fork阻塞、AOF刷盘阻塞和HugePage写操作阻塞三种。\nfork阻塞Redis做RDB和AOF重写和持久化时，需要执行fork操作创建子进程（bgsave操作），子进程不拷贝父进程物理内存空间，但是会复制父进程的空间内存页表（10g的Redis进程，需要复制20MB的内存页表）。因此如果fork操作本身耗时过长，也会导致主线程的阻塞。\nAOF刷盘阻塞开启AOF持久化时，文件刷盘一般每秒一次，后台线程每秒对AOF文件做fsync操作。硬盘压力过大时，fsync操作需要等待，直到写入完成。如果主线程发现距离上次的fsync成功超过两秒，为了数据安全性会阻塞到后台线程fsync操作完成。\nHugePage写操作阻塞子进程在执行重写期间利用Linux写时复制降低内存开销，因此只有写操作是Redis才会复制要修改的内存页。如果开启Transparent HugePage，每次写入命令引起的复制内存页单位由4K变为2MB，放大512倍，拖慢写操作的执行时间。\n外在原因CPU竞争\n进程竞争如果其他进程过度消耗CPU，会严重影响Redis的吞吐量。\n绑定CPU部署Redis时，可以将Redis绑定在CPU上，但是一些情况下会出现问题。当Redis父进程创建子进程执行RDB/AOF持久化时，如果绑定了CPU，子进程和父进程有可能会共享一个CPU，影响Redis稳定性。内存交换内存交换是指操作系统将Redis使用的部分内存换到硬盘上去，造成Redis性能急剧下降。因此需要保证机器有充足的内存，防止内存交换。123redis-cli info server | grep process_id        #获取Redis进程号cat &#x2F;proc&#x2F;4476&#x2F;smaps | grep Swap 87            #根据进程号查询内存交换信息\n网络问题网络问题经常是引起Redis阻塞的问题。常见网络问题有：连接拒接、网络延迟、网卡软中断等","url":"/2019/12/26/201912/Redis高级应用阻塞的原因/","link":"","plink":"http://example.com/2019/12/26/201912/Redis%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8E%9F%E5%9B%A0/"},{"title":"我的书单","content":"图书\n        简介\n    \n    \n        \n        \n        书名：《深入理解Java虚拟机》\n        作者：周志明 \n        状态：已读完  \n        次数：1遍\n        豆瓣：8.9分   点击查看\n    \n    \n        \n        \n        书名：《Redis设计与实现》\n        作者：黄健宏 \n        状态：已读完  \n        次数：1遍\n        豆瓣：8.5分   点击查看\n    \n    \n        \n        \n        书名：《第一本Docker书》\n        作者：李兆海 / 刘斌 / 巨震 \n        状态：已读完  \n        次数：1遍\n        豆瓣：7.3分   点击查看\n    \n    \n        \n        \n        书名：《Java并发编程实战》\n        作者： Brian Goetz / Tim Peierls / Joshua Bloch 等，译者: 童云兰 \n        状态：已读完  \n        次数：1遍\n        豆瓣：9.1分   点击查看\n    \n    \n        \n        \n        书名：《Java TCP/IP Socket编程》\n        作者： Kenneth L. Calvert / Michael J. Donahoo \n        状态：已读完  \n        次数：1遍\n        豆瓣：8.1分   点击查看\n    \n    \n        \n        \n        书名：《大型网站技术架构：核心原理与案例分析》\n        作者： 李智慧 \n        状态：已读完  \n        次数：1遍\n        豆瓣：7.9分   点击查看\n    \n    \n        \n        \n        书名：《Redis实战》\n        作者： Josiah L. Carlson / 译：黄健宏 \n        状态：已读完  \n        次数：1遍\n        豆瓣：8.3分   点击查看\n    \n    \n        \n        \n        书名：《淘宝技术这十年》\n        作者： 子柳\n        状态：已读完  \n        次数：1遍\n        豆瓣：7.4分   点击查看\n    \n    \n        \n        \n        书名：《Java核心技术・卷1》（原书第10版）\n        作者：[美]凯·S·霍斯特曼 &nbsp; 译者：周立新\n        状态：已读完  \n        次数：1遍\n        豆瓣：7.9分   点击查看\n    \n    \n        \n        \n        书名：《大话设计模式》\n        作者：程杰\n        状态：已读完  \n        次数：1遍\n        豆瓣：8.2分   点击查看\n    \n    \n        \n        \n        书名：《构建高性能web站点》\n        作者：郭欣\n        状态：已读完 \n        次数：1遍\n        豆瓣：8.6分   点击查看","url":"/2019/12/28/201912/我的书单/","link":"","plink":"http://example.com/2019/12/28/201912/%E6%88%91%E7%9A%84%E4%B9%A6%E5%8D%95/"},{"title":"idea运行项目正常，debug模式编译时卡住的解决方法","content":"如下图所示，在调试项目时，编译时卡在\n1HHH000397: Using ASTQueryTranslatorFactory\n后来查询资料才发现原来是项目断点太多，导致debug模式卡住。点击下图查看项目中所有断点位置，然后去掉断点就可以使用debug模式了。","url":"/2020/02/20/202002/idea运行项目正常debug模式编译时卡住的解决方法/","link":"","plink":"http://example.com/2020/02/20/202002/idea%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%AD%A3%E5%B8%B8debug%E6%A8%A1%E5%BC%8F%E7%BC%96%E8%AF%91%E6%97%B6%E5%8D%A1%E4%BD%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"javax.validation.constraints常用注解用法","content":"@NotNull被修饰的元素不能为 null\n@NotEmpty不能是 null不能是空字符串集合元素不能是空\n@NotBlank只能判断字符串，不能是空","url":"/2020/02/20/202002/javax.validation.constraints常用注解用法/","link":"","plink":"http://example.com/2020/02/20/202002/javax.validation.constraints%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E7%94%A8%E6%B3%95/"},{"title":"Maven中dependencyManagement标签","content":"Maven 使用 dependencyManagement 元素提供一种管理依赖版本号的方式，通常在项目最顶层的父 POM 文件中看到 dependencyManagement 元素。使用 dependencyManagement 元素能让所有在子项目中引用一个依赖而不显式的列出版本号。子项目中的 Maven 会沿着父层次向上走，直到找到一个拥有 dependencyManagement 元素的项目，然后会使用这个 dependencyManagement 元素中指定的版本号。这样就可以控制整个项目的版本号，如果要升级某个依赖的版本号，只需要在 dependencyManagement 里面声明要升级的版本号，而不用每个子项目都去升级。\n123456789101112&lt;dependencyManagement&gt;  &lt;dependencies&gt;    &lt;!-- SpringCloud alibaba 2.1.0.RELEASE --&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;      &lt;version&gt;2.1.0.RELEASE&lt;&#x2F;version&gt;      &lt;type&gt;pom&lt;&#x2F;type&gt;      &lt;scope&gt;import&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;  &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt;\n子项目中可以：\n1234567&lt;dependencies&gt;      &lt;!-- SpringCloud alibaba 2.1.0.RELEASE --&gt;      &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;      &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;\n不过要注意的是，dependencyManagement 只是声明依赖，并不会为子项目引入依赖，子项目需要显式的声明要使用的依赖。","url":"/2020/03/08/202003/Maven中dependencyManagement标签/","link":"","plink":"http://example.com/2020/03/08/202003/Maven%E4%B8%ADdependencyManagement%E6%A0%87%E7%AD%BE/"},{"title":"SpringBoot基础--配置详解","content":"简介SpringBoot 使用约定大于配置的开发原则，减少人为配置，直接使用默认配置就能开发。SpringBoot 使用全局的配置文件，开发过程中可以修改配置文件来修改 SpringBoot 自动配置的默认值。在 SpringBoot 中配置文件名是固定的：\n\napplication.properties\napplication.yml\n\n简单用法普通值k:value 形式，字符串默认不用加引号。\n12&quot;&quot; 双引号；不会转移特殊字符,\\n会表示换行&#39;&#39; 单引号；转移特殊字符,\\n转义为字符\n对象123friends:\tname: xxx\tage: 21\n1friends:{name:xxx, age:20}\n数组1234student:\t- a\t- b\t- c\n1student:[a,b,c]\n配置文件注入@ConfigurationProperties123456@Component@ConfigurationProperties(prefix &#x3D; &quot;student&quot;)public class Student {    private String name;    private Integer age;}\n123student:  name: gavin  age: 20\n\n@ConfigurationProperties 将类中的每一个属性与配置文件中的配置进行关联\nprefix = “student” 表示配置文件中哪一个字段下面的属性\n必须加@Component，表示是容器中的组件\n\n显示 Spring Boot Configutation annotation processor not found in classpath,可以添加下面的依赖，可以提示配置：\n12345&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\t&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n@Value\n@Value(“#{}”) 可以使用 SpEL 表达式\n@Value(“${}”)可以从配置文件中获取值，只可以获取单个值。\n\n12345678@Data@Componentpublic class Student {    @Value(&quot;${student.name}&quot;)    private String name;    @Value(&quot;#{20}&quot;)    private Integer age;}\n12student:  name: gavin\n区别\n\n\n\n@ConfigurationProperties\n@Value\n\n\n\n功能\n批量注入属性\n单个属性指定\n\n\n松散语法\n支持\n不支持\n\n\nSpEL\n不支持\n支持\n\n\nJSR303 数据校验\n支持\n不支持\n\n\n复杂类型封装\n支持\n不支持\n\n\n\n松散语法是指：支持 frist-name,FristName,frist_name 等变量表示。@Value 只能和配置文件中的参数完全相等。\n\n@PropertySource@ConfigurationProperties(prefix = “student”)默认从全局配置文件中读取配置信息，也可以使用@PropertySource 指定 properties 文件来获取配置信息，注意@PropertySource 注解只能读取 properties 文件，不能读取 yml 文件。\n123456@PropertySource(value &#x3D; {&quot;classpath:default.properties&quot;})@Component@ConfigurationProperties(prefix &#x3D; &quot;student&quot;)public class Student {    private String name;}\n12&#x2F;&#x2F;default.propertie文件student.name: default\n@ImportResourceSpringBoot 没有 Spring 配置文件，可以使用@ImportResource 注解加载 Spring 配置文件。\n1@ImportResource(locations &#x3D; {&quot;classpath:beans.xml&quot;})\nProfile配置文件名字可以是 application-{profile}.properties/yml。默认使用 application.properties/yml 的配置。可以在主配置文件中使用下面语句激活指定 profile 来切换生产环境和开发环境。\n1spring.profiles.active&#x3D;dev  \n配置文件加载位置SpringBoot 启动会依次扫描下面位置的 application.properties 或 application.yml 文件作为 SpringBoot 的配置文件。\n1234-file:.&#x2F;config&#x2F;          &#x2F;&#x2F;file：项目根目录-file:.&#x2F;-classpath:&#x2F;config&#x2F;-classpath:&#x2F;\n优先级由高到底，高优先级的配置会覆盖低优先级的配置。SpringBoot 从这四个位置全部加载配置文件，并互补配置。","url":"/2020/03/07/202003/SpringBoot基础配置详解/","link":"","plink":"http://example.com/2020/03/07/202003/SpringBoot%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"title":"Zookeeper基础--简单用法","content":"概述Zookeeper 是一个分布式协调服务的框架，用来解决分布式集群中的一致性问题。Zookeeper 本质上是一个分布式小文件存储系统，提供类似于目录树的方式存储数据，通过对数据状态变化的监控，实现基于数据的集群管理。Zookeeper 有一下应用场景：\n\n维护配置信息\n分布式锁服务\n集群管理\n生成分布式唯一 ID\n\n数据模型Zookeeper 数据节点是树状结构，树中的节点称为 znode，一个 znode 有多个子节点，变现为树状。可以使用路径来定位某个 znode，比如/xxx1/xxx2/xxx3 其中 xxx1 为根节点，xxx2 为 2 级节点，xxx3 为 3 级节点，依次类推。znode 兼具文件和目录两种特点，即像文件一样维护数据、元信息、ACL、时间戳等数据结构，又像目录一样作为路径标识的一部分。znode 大体分为三部分：\n\n节点数据：节点 path，节点 data\n节点的子节点 children\n节点的状态：描述当前节点创建和修改记录\n\n节点信息12345678910111213[zk: localhost:2181(CONNECTED) 3] get &#x2F;test0000000000123cZxid &#x3D; 0x2ctime &#x3D; Fri Mar 20 15:53:30 UTC 2020mZxid &#x3D; 0x2mtime &#x3D; Fri Mar 20 15:53:30 UTC 2020pZxid &#x3D; 0x2cversion &#x3D; 0dataVersion &#x3D; 0aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 3numChildren &#x3D; 0\n查看 test0000000000 节点，第一行展示的是节点的数据。\n\ncZxid：数据节点创建时的事务 ID\nctime：数据节点创建时的时间\nmZxid：数据节点左后一次更新时的事务 ID\nmtime：数据节点最后一次更新时的时间\npZxid：数据节点的子节点最后一次被修改时的事务 ID\ncversion：子节点的更改次数\ndataVersion：节点数据的更改次数\naclVersion：节点的 ACL 的更改次数\nephemeralOwner：如果节点是临时节点，则表示创建节点的会话的 SessionID;如果创建的节点是持久节点，则该属性值为 0.\ndataLength：数据内容的长度\nnumChildren：数据节点当前的子节点个数\n\n节点类型Zookeeper 中的节点有两种，分别是临时节点和永久节点。节点的类型在创建时即被确定，不能改变。\n\n临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话结束，临时节点将被自动删除，也可以手动删除。Zookeeper 的临时节点不允许拥有子节点。\n持久化节点：该节点的生命周期不依赖于会话，并且只有在客户端执行删除操作的时候，它们才会被删除。\n\n安装安装 JDKZookeeper 依赖 JDK，因此需要先安装 JDK.\n123456789101112131415&#x2F;&#x2F;解压JDK文件tar -xzvf jdk-8u231-linux-x64.tar.gz&#x2F;&#x2F;打开.bash_profile文件vim ~&#x2F;.bash_profile&#x2F;&#x2F;编辑以下内容，&#x2F;data&#x2F;app&#x2F;jdk1.8.0_231为刚刚解压的文件夹。JAVA_HOME&#x3D;&#x2F;data&#x2F;app&#x2F;jdk1.8.0_231export JAVA_HOMEPATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHexport PATH&#x2F;&#x2F;保存退出后，使用以下命令使bash_profile文件生效source ~&#x2F;.bash_profile\n12345&#x2F;&#x2F; 查看Java是否安装成功root@master:&#x2F;data&#x2F;app# java -versionjava version &quot;1.8.0_231&quot;Java(TM) SE Runtime Environment (build 1.8.0_231-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode)\n安装 Zookeeper1234567&#x2F;&#x2F;解压Zookeeper压缩包tar -xzvf zookeeper-3.4.9.tar.gz&#x2F;&#x2F;进入Zookeeper配置文件夹cd zookeeper-3.4.9&#x2F;conf&#x2F;&#x2F;Zookeeper复制官方配置文件示例cp zoo_sample.cfg zoo.cfg\nzoo.cfg 配置文件如下所示：\n123456789101112131415161718192021222324# CS通信心跳时间，单位是毫秒，默认是2000毫秒。tickTime主要是客户端与服务器端或者是服务器与服务器端之间维持心跳。tickTime&#x3D;2000# 集群中的follower服务器与leader服务器之间初始连接时能容忍的最多心跳数initLimit&#x3D;10# 集群中flower服务器和leader服务器之间的请求和应答最多能容忍的心跳数syncLimit&#x3D;5# 此路径存储Zookeeper数据的内存快照以及事务日志文件，因此需要修改，这里修改到Zookeeper文件夹的data文件夹中dataDir&#x3D;&#x2F;data&#x2F;app&#x2F;zookeeper-3.4.9&#x2F;data# the port at which the clients will connectclientPort&#x3D;2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns&#x3D;60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount&#x3D;3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval&#x3D;1\n12345678&#x2F;&#x2F;进入zookeeper的bin文件夹中cd bin&#x2F;&#x2F;&#x2F; 启动.&#x2F;zkServer.sh start&#x2F;&#x2F; 停止.&#x2F;zkServer.sh stop&#x2F;&#x2F; 查看状态.&#x2F;zkServer.sh status\nZookeeper 常用 Shell 命令新增节点1create [-s] [-e] path data # -s为有序节点， -e为临时节点\n节点可以分为 4 小类，分别是：\n\n持久化节点\n\n12[zk: localhost:2181(CONNECTED) 0] create &#x2F;hadoop &quot;123456&quot;Created &#x2F;hadoop\n\n持久化有序节点创建持久化有序节点，创建的节点名为指定节点名 + 自增序号\n\n1234[zk: localhost:2181(CONNECTED) 0] create -s &#x2F;a &quot;aaa&quot;Created &#x2F;a0000000002[zk: localhost:2181(CONNECTED) 0] create -s &#x2F;b &quot;bbb&quot;Created &#x2F;b0000000003\n\n临时节点创建临时节点，临时节点会在会话过期后删除\n\n12[zk: localhost:2181(CONNECTED) 0] create -e &#x2F;tmp &quot;tmp&quot;Created &#x2F;tmp\n\n临时有序节点\n\n12[zk: localhost:2181(CONNECTED) 0] create -s -e &#x2F;aa &#39;aaa&#39;Created &#x2F;aa0000000005\n更新节点1set path [version]\n12345678910111213141516171819202122232425[zk: localhost:2181(CONNECTED) 0] get &#x2F;hadoop123456cZxid &#x3D; 0x5ctime &#x3D; Sat Mar 21 03:26:13 UTC 2020mZxid &#x3D; 0x5mtime &#x3D; Sat Mar 21 03:26:13 UTC 2020pZxid &#x3D; 0x5cversion &#x3D; 0dataVersion &#x3D; 0aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 6numChildren &#x3D; 0[zk: localhost:2181(CONNECTED) 1] set &#x2F;hadoop &quot;654321&quot;cZxid &#x3D; 0x5ctime &#x3D; Sat Mar 21 03:26:13 UTC 2020mZxid &#x3D; 0x16mtime &#x3D; Sat Mar 21 03:47:22 UTC 2020pZxid &#x3D; 0x5cversion &#x3D; 0dataVersion &#x3D; 1aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 6numChildren &#x3D; 0\ndataVersion 参数记录数据的版本号，每次修改数据之后，版本号也发生变化。set 命令也可以加入版本号，如果版本号不匹配，Zookeeper 会拒绝更新数据，类似于乐观锁机制。\n123456789101112131415161718192021222324252627[zk: localhost:2181(CONNECTED) 0] get &#x2F;hadoop654321cZxid &#x3D; 0x5ctime &#x3D; Sat Mar 21 03:26:13 UTC 2020mZxid &#x3D; 0x16mtime &#x3D; Sat Mar 21 03:47:22 UTC 2020pZxid &#x3D; 0x5cversion &#x3D; 0dataVersion &#x3D; 1aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 6numChildren &#x3D; 0[zk: localhost:2181(CONNECTED) 1] set &#x2F;hadoop &quot;111&quot; 0version No is not valid : &#x2F;hadoop[zk: localhost:2181(CONNECTED) 2] set &#x2F;hadoop &quot;111&quot; 1cZxid &#x3D; 0x5ctime &#x3D; Sat Mar 21 03:26:13 UTC 2020mZxid &#x3D; 0x1amtime &#x3D; Sat Mar 21 03:49:37 UTC 2020pZxid &#x3D; 0x5cversion &#x3D; 0dataVersion &#x3D; 2aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 3numChildren &#x3D; 0\n删除节点1delete path [version]\n和更新节点一样，delete 命令可以添加版本号，如果版本号不一致，不允许删除。\n123456789101112131415161718[zk: localhost:2181(CONNECTED) 0] get &#x2F;hadoop111cZxid &#x3D; 0x5ctime &#x3D; Sat Mar 21 03:26:13 UTC 2020mZxid &#x3D; 0x1amtime &#x3D; Sat Mar 21 03:49:37 UTC 2020pZxid &#x3D; 0x5cversion &#x3D; 0dataVersion &#x3D; 2aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 3numChildren &#x3D; 0[zk: localhost:2181(CONNECTED) 1] delete &#x2F;hadoop 1version No is not valid : &#x2F;hadoop[zk: localhost:2181(CONNECTED) 2] delete &#x2F;hadoop 2[zk: localhost:2181(CONNECTED) 3] get &#x2F;hadoopNode does not exist: &#x2F;hadoop\n要删除节点和后代节点，可以使用递归删除：\n1rmr path\n查看节点和查看节点状态使用 get 命令可以看到节点的数据和状态。stat 命令只能查看状态，不能查看数据。\n12345678910111213141516171819202122232425[zk: localhost:2181(CONNECTED) 2] get &#x2F;hadoop321cZxid &#x3D; 0x21ctime &#x3D; Sat Mar 21 03:54:30 UTC 2020mZxid &#x3D; 0x22mtime &#x3D; Sat Mar 21 03:54:41 UTC 2020pZxid &#x3D; 0x21cversion &#x3D; 0dataVersion &#x3D; 1aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 3numChildren &#x3D; 0[zk: localhost:2181(CONNECTED) 3] stat &#x2F;hadoopcZxid &#x3D; 0x21ctime &#x3D; Sat Mar 21 03:54:30 UTC 2020mZxid &#x3D; 0x22mtime &#x3D; Sat Mar 21 03:54:41 UTC 2020pZxid &#x3D; 0x21cversion &#x3D; 0dataVersion &#x3D; 1aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 3numChildren &#x3D; 0\n查看节点列表12ls pathls2 path\n使用 ls 和 ls2 命令可以查看某个节点下的所有子节点。ls2 可以返回当前节点的状态。\n12345678910111213141516171819[zk: localhost:2181(CONNECTED) 6] create &#x2F;hadoop&#x2F;node1 &quot;123&quot;Created &#x2F;hadoop&#x2F;node1[zk: localhost:2181(CONNECTED) 8] create &#x2F;hadoop&#x2F;node2 &quot;321&quot;Created &#x2F;hadoop&#x2F;node2[zk: localhost:2181(CONNECTED) 9] ls &#x2F;hadoop[node2, node1][zk: localhost:2181(CONNECTED) 0] ls2 &#x2F;hadoop[node2, node1]cZxid &#x3D; 0x21ctime &#x3D; Sat Mar 21 03:54:30 UTC 2020mZxid &#x3D; 0x22mtime &#x3D; Sat Mar 21 03:54:41 UTC 2020pZxid &#x3D; 0x27cversion &#x3D; 2dataVersion &#x3D; 1aclVersion &#x3D; 0ephemeralOwner &#x3D; 0x0dataLength &#x3D; 3numChildren &#x3D; 2\n监听器123get path [watch]stat path [watch]ls\\ls2 path [watch]\n\nget path watch 注册的监听器能够在节点内容发生改变时，向客户端发送通知。Zookeeper 的触发器是一次性的，触发一次后就失效。\nstat path [watch]注册的监听器能够在节点状态发生改变时，向客户端发出通知。\nls\\ls2 path [watch]监听器能够监听该节点下所有子节点的增加和删除操作。\n\nACL 权限控制ACL 权限控制，使用 scheme：id：permission 来标识，其中：\n\n权限模式（scheme）：授权的策略\n授权对象（id）：授权的对象\n权限（permission 来标识）：授权的权限\n\n1setAcl &#x2F;test ip:192.168.1.1:crwda  #设置&#x2F;test节点的权限到IP地址为192.168.1.1的客户端，授予增、删、改、查、管理权限。\nZookeeper 基于每个节点来设置权限，需要多每个节点设置权限。每个 znode 支持设置多种权限控制方案和多个权限。子节点不会继承父节点权限，客户端可能无权访问某个节点，但是可以访问子节点。\n授权模式\n\n\n模式\n描述\n\n\n\nworld\n只有一个用户：anyone\n\n\nip\n对客户端使用 ip 地址认证\n\n\nauth\n使用已添加认证的用户认证\n\n\ndigest\n使用“用户：密码”的方式认证\n\n\n授予权限\n\n\n权限\nACL 缩写\n描述\n\n\n\ncreate\nc\n可以创建子节点\n\n\ndelete\nd\n可以删除子节点\n\n\nread\nr\n可以读取节点数据以及显示子节点列表\n\n\nwrite\nw\n可以设置节点数据\n\n\nadmin\na\n可以设置节点访问控制列表权限\n\n\n授权相关命令\n\n\n命令\n使用方式\n描述\n\n\n\ngetAcl\ngetAcl [path]\n读取 ACL 权限\n\n\nsetAcl\nsetAcl [path] [acl]\n设置 ACL 权限\n\n\naddauth\naddauth [scheme] [auth]\n添加认证用户","url":"/2020/03/21/202003/Zookeeper基础简单用法/","link":"","plink":"http://example.com/2020/03/21/202003/Zookeeper%E5%9F%BA%E7%A1%80%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"},{"title":"Kubernetes基础--Pod控制器","content":"ReplicationControllerReplicationController 可以保证它的 Pod 始终保持在运行状态。ReplicationController 的工作是确保 Pod 的数量始终与其标签选择器匹配，如果不匹配，ReplicationController 会采取适当的操作来协调 Pod 的数量。一个 ReplicationController 有三部分：\n\nlabel selector（标签选择器），用于确定 ReplicationController 作用域有哪些 Pod\nreplica count(副本个数)，指定应运行的 pod 数量\npod template（pod 模板）。用于创建新的 pod 副本ReplicationController 的副本个数、标签选择器，甚至是 pod 模板都能随时修改，但只有副本数量变更才会影响现有 pod。\n\nReplicationController 操作首先创建 YAML 文件，replicas 表示创建 2 个 pod，selector 表示标签选择器选择的标签。\n123456789101112131415161718apiVersion: v1kind: ReplicationControllermetadata:    name: kubiaspec:    replicas: 2    selector:        app: kubia    template:        metadata:            labels:                app: kubia        spec:            containers:            - name: kubia              image: tutum&#x2F;hello-world              ports:              - containerPort: 80\n然后使用已有命令创建 rc\n1kubectl create -f kubia-rc.yaml\n查看 Pod，发现已经存在两个 Pod,此时删除一个 Pod，RC 会创建一个新的 Pod。\n12345678910master@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get podsNAME          READY   STATUS    RESTARTS   AGEkubia-98g42   1&#x2F;1     Running   0          3m5skubia-9ppzm   1&#x2F;1     Running   0          3m5smaster@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl delete po kubia-98g42pod &quot;kubia-98g42&quot; deletedmaster@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get podsNAME          READY   STATUS              RESTARTS   AGEkubia-9ppzm   1&#x2F;1     Running             0          6m44skubia-xvhqd   0&#x2F;1     ContainerCreating   0          5s\n查看 k8s 中所有 rc\n123master@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get rcNAME    DESIRED   CURRENT   READY   AGEkubia   2         2         2       8m2s\nReplicationController 和 Pod 的关系Pod 并没有绑定到 ReplicationController，ReplicationController 只管理与标签选择器匹配的 Pod。通过修改 Pod 的标签，可以将 Pod 从 ReplicationController 作用域中添加或删除。如果更改了一个 Pod 的标签，不在与 ReplicationController 的标签选择器匹配，那该 Pod 和其他手动创建的 Pod 相同，如果该 Pod 终止，也不会重新调度。ReplicationController 发现 Pod 丢失后，会启动新的 Pod 替代它。还可以使用一下命令修改当前 ReplicationController 的配置。\n1kubectl edit rc kubia\n该命令会在默认文本编辑器中打开 ReplicationController 的 YAML 配置文件，修改保存后，会自动更新。\nReplicationController 的删除使用 kubectl delete 命令会删除 ReplicationController 和管理的 Pod，可以通过添加–cascade=false 参数避免删除 Pod\n1234567master@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl delete rc kubia --cascade&#x3D;falsereplicationcontroller &quot;kubia&quot; deletedmaster@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get podsNAME          READY   STATUS    RESTARTS   AGEkubia-9ppzm   1&#x2F;1     Running   0          21mkubia-xvhqd   1&#x2F;1     Running   0          15m\nReplicaSetReplicaSet 是替换 ReplicationController 的调度组件。ReplicaSet 和 ReplicationController 完全相同，但是 ReplicaSet 的 Pod 选择器表达能力更强，ReplicaSet 允许匹配缺少某个标签的 Pod，包含特定标签名的 Pod。\nReplicaSet 操作新建 ReplicaSet 的 YAML 文件\n123456789101112131415161718apiVersion: apps&#x2F;v1kind: ReplicaSetmetadata:    name: kubiaspec:    replicas: 2    selector:        matchLabels:            app: kubia    template:        metadata:            labels:                app: kubia        spec:            containers:            - name: kubia              image: tutum&#x2F;hello-world\nDaemonSet一个 DaemonSet 对象能确保其创建的 Pod 在集群中的每一台（或指定）Node 上都运行一个副本。如果集群中动态加入了新的 Node，DaemonSet 中的 Pod 也会被添加在新加入 Node 上运行。删除一个 DaemonSet 也会级联删除所有其创建的 Pod。\nDaemonSet 操作123456789101112131415161718apiVersion: apps&#x2F;v1kind: DaemonSetmetadata:    name: ssd-monitorspec:    selector:        matchLabels:            app: ssd-monitor    template:        metadata:            labels:                app: ssd-monitor        spec:            nodeSelector:                disk: ssd            containers:            - name: main              image: tutum&#x2F;hello-world\n创建 DaemonSet\n12master@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl create -f daemonset.yamldaemonset.apps&#x2F;ssd-monitor created\n此时查看 DaemonSet，会发现创建了 0 个 Pod，此时查看 Pod 的数量也是 0。因为 DaemonSet 会检测所有的节点，如果节点的标签是 ssd，那就会把 Pod 部署上去。\n12345master@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get dsNAME          DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGEssd-monitor   0         0         0       0            0           disk&#x3D;ssd        15smaster@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get podsNo resources found in default namespace.\n向节点上添加标签：\n1234567891011master@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get nodeNAME       STATUS   ROLES    AGE     VERSIONminikube   Ready    master   5d13h   v1.18.0master@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl label node minikube disk&#x3D;ssdnode&#x2F;minikube labeledmaster@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get podsNAME                READY   STATUS    RESTARTS   AGEssd-monitor-m59rf   1&#x2F;1     Running   0          11smaster@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get dsNAME          DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGEssd-monitor   1         1         1       1            1           disk&#x3D;ssd        12m\n从节点上删除/修改标签，DaemonSet 也会删除该节点上的 Pod\n1234567master@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl label node minikube disk&#x3D;hdd --overwritenode&#x2F;minikube labeledmaster@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get podsNo resources found in default namespace.master@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get dsNAME          DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGEssd-monitor   0         0         0       0            0           disk&#x3D;ssd        14m","url":"/2020/04/25/202004/Kubernetes基础Pod控制器/","link":"","plink":"http://example.com/2020/04/25/202004/Kubernetes%E5%9F%BA%E7%A1%80Pod%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"title":"Kubernetes基础--Pod用法","content":"Pod 是 Kubernetes 调度的最小单元。一个 Pod 可以包含一个或多个容器，因此它可以被看作是内部容器的逻辑宿主机。Pod 有控制器管理的 Pod 和自主式 Pod 两种用法，本文介绍的是自主式 Pod。自主式 Pod 也就是没有控制器参与的 Pod，删除后无法再次创建。首先下载镜像到本地 Docker 仓库，用来演示创建 Pod 的过程。\n12docker pull tutum&#x2F;hello-world    docker images\ntutum/hello-world是在 dockerHub 上找到的一个镜像，开放 80 端口。编写生成 Pod 的 YAML\n123456789101112master@master:&#x2F;data&#x2F;k8s&#x2F;conf$ cat kubia-manual.yamlapiVersion: v1kind: Podmetadata:    name: kubia-manualspec:    containers:    - image: tutum&#x2F;hello-world      name: hello      ports:      - containerPort: 80        protocol: TCP\n\n\n\n参数名\n字段类型\n说明\n\n\n\napiVersion\nString\nK8S API 的版本，目前是 v1\n\n\nkind\nString\nYAML 文件定义的资源类型和角色，比如：Pod\n\n\nmetadata\nObject\n元数据对象，固定值写 metadata\n\n\nmetadata name\nString\n元数据对象的名字，这里由我们编写，比如命名 Pod 的名字\n\n\nmetadata namespace\nString\n元数据对象的命名空间，有我们自身定义\n\n\nspec\nObject\n详细定义对象，固定值写 Spec\n\n\nspec.containers[]\nlist\n这里是 Spec 对象的容器列表定义，是一个列表\n\n\nspec.containers[].name\nString\n这里定义容器的名字\n\n\nspec.containers[].image\nString\n这里定义要用到的镜像名称\n\n\nspec.containers[].imagePullPolicy\nString\n定义镜像的拉取策略，有 Always、Never、IfNotPresent 三个值。Always：每次都尝试重新拉取镜像；Never 表示仅使用本地镜像；IfNotPresent：本地有镜像就使用本地镜像，默认为 Always\n\n\nspec.containers[].command[]\nList\n指定容器启动命令，因为是数据可以指定多个，不指定则使用镜像打包时使用的启动命令\n\n\nspec.containers[].args[]\nList\n指定容器启动命令参数\n\n\nspec.containers[].workingDir\nString\n指定容器的工作目录\n\n\nspec.containers[].volumeMounts[]\nList\n指定容器内部的存储卷配置\n\n\nspec.containers[].volumeMounts[].name\nString\n指定可以被容器挂载的存储卷的名称\n\n\nspec.containers[].volumeMounts[].mountPath\nString\n指定可以被容器挂载的存储卷的路径\n\n\nspec.containers[].volumeMounts[].readOnly\nString\n设置存储卷路径的读写模式，true 或者 false，默认为读写模式\n\n\nspec.containers[].ports[]\nList\n指定端口名称\n\n\nspec.containers[].ports[].name\nString\n指定端口名称\n\n\nspec.containers[].ports[].containerPort\nString\n指定容器需要监听的端口号\n\n\nspec.containers[].ports[].hostPort\nString\n指定容器所在主机需要监听的端口号，默认跟上面的 containerPort 相同，注意设置了 hostPort 同一台主机无法启动该容器的相同副本，因为端口号相同会冲突\n\n\nspec.containers[].ports[].protocol\nString\n指定端口协议，支持 TCP 和 UDP，默认为 TCP\n\n\nspec.containers[].env[]\nList\n指定容器运行前需设置的环境变量列表\n\n\nspec.containers[].env[].name\nString\n指定环境变量名称\n\n\nspec.containers[].env[].value\nString\n指定环境变量值\n\n\nspec.containers[].resource\nObject\n指定资源限制和资源请求的值\n\n\nspec.containers[].resource.limits\nObject\n指定设置容器运行时资源的运行上限\n\n\nspec.containers[].resource.limits.cpu\nString\n指定 CPU 的限制，单位为 core 数，将用于 docker run –cpu-shares 参数\n\n\nspec.containers[].resource.limits.memory\nString\n指定 MEM 内存的限制，单位为 MlB,GiB\n\n\nspec.containers[].resource.requests\nObject\n指定容器启动和调度时的限制设置\n\n\nspec.containers[].resource.requests.cpu\nString\nCPU 请求，单位为 core 数，容器启动时初始化可用数量\n\n\nspec.containers[].resource.requests.memory\nString\n内存请求，单位为 MlB,GiB，容器启动的初始化可用数量\n\n\nspec.restartPolicy\nString\n定义 Pod 的重启策略，可选值为 Always、OnFailure、Never，默认值为 Always。Always：Pod 一旦终止运行，kubelet 服务都会重启。OnFailure：只有 Pod 以非零退出吗终止时，kubelet 才会重启该容器。如果容器正常结束（退出码为 0），则不会重启。Never：Pod 终止后，kubelet 将退出码报告给 Master，不会重启该 Pod\n\n\nspec.nodeSelector\nObject\n定义 Node 的 Label 过滤标签，以 name:value 格式指定\n\n\nspec.imagePullSecrets\nObject\n定义 pull 镜像时使用 secret 名称，以 name：secretkey 格式指定\n\n\nspec.hostNetWork\nBoolean\n定义是否使用主机网络模式，默认值为 false。设置 true 表示使用宿主机网络，不使用 docker 网桥，同时设置了 true 将无法在同一台宿主机上启动第二个副本\n\n\n常用命令123456789101112# 根据yaml文件创建podkubectl create -f kubia-manual.yaml# 查看kubia-manual的详细yamlkubectl get po kubia-manual -o yaml# 查看k8s中所有podkubectl get pods# 删除podkubectl delete pod kubia-manual# 查看Pod日志kubectl logs kubia-manual# 查看Pod中的hello容器的日志，这里的容器名称为spec.containers[].name定义的名字kubectl logs kubia-manual -c hello\n正常需要通过 Service 和 Pod 通信，也可以直接将配置端口转发到 pod，可以使用 kubectl port-forward 命令转发，下面的指令将本地端口的 8888 转发到 pod 的 80 端口。然后使用 curl 命令即可查看容器返回的消息。\n12kubectl port-forward kubia-manual 8888:80curl localhost:8888\n标签修改 YAML 文件，将 labels 信息加入，此时 pod 多了两个标签。\n1234567891011121314apiVersion: v1kind: Podmetadata:    name: kubia-manual-v1    labels:        creation_method: manual        env: prodspec:    containers:    - image: tutum&#x2F;hello-world      name: hello      ports:      - containerPort: 80        protocol: TCP\n123456789101112131415161718192021222324252627282930313233343536373839404142# 使用 --show-labels参数，可以看到pod中的标签。kubectl get po --show-labelsmaster@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get po --show-labelsNAME              READY   STATUS    RESTARTS   AGE   LABELSkubia-manual      1&#x2F;1     Running   0          14m   &lt;none&gt;kubia-manual-v1   1&#x2F;1     Running   0          49s   creation_method&#x3D;manual,env&#x3D;prod# -L命令可以分别查看标签的两列kubectl get po -L creation_method,envmaster@master:&#x2F;data&#x2F;k8s&#x2F;conf$ kubectl get po -L creation_method,envNAME              READY   STATUS    RESTARTS   AGE    CREATION_METHOD   ENVkubia-manual      1&#x2F;1     Running   0          17mkubia-manual-v1   1&#x2F;1     Running   0          4m1s   manual            prod# kubectl label参数可以修改标签master@master:~$ kubectl label po kubia-manual env&#x3D;devpod&#x2F;kubia-manual labeledmaster@master:~$ kubectl get po -L creation_method,envNAME              READY   STATUS    RESTARTS   AGE     CREATION_METHOD   ENVkubia-manual      1&#x2F;1     Running   0          23m                       devkubia-manual-v1   1&#x2F;1     Running   0          9m16s   manual            prod# 使用-l命令筛选env&#x3D;dev的标签master@master:~$ kubectl get po -l env&#x3D;devNAME           READY   STATUS    RESTARTS   AGEkubia-manual   1&#x2F;1     Running   0          34m# 使用-l命令筛选存在env的标签，不管值多少master@master:~$ kubectl get po -l envNAME              READY   STATUS    RESTARTS   AGEkubia-manual      1&#x2F;1     Running   0          36mkubia-manual-v1   1&#x2F;1     Running   0          22m# 列出不包含creation_method标签的podmaster@master:~$ kubectl get po -l &#39;!creation_method&#39;NAME           READY   STATUS    RESTARTS   AGEkubia-manual   1&#x2F;1     Running   0          37m# 按标签删除Podmaster@master:~$ kubectl delete po -l creation_method&#x3D;manualpod &quot;kubia-manual-v1&quot; deleted","url":"/2020/04/21/202004/Kubernetes基础Pod用法/","link":"","plink":"http://example.com/2020/04/21/202004/Kubernetes%E5%9F%BA%E7%A1%80Pod%E7%94%A8%E6%B3%95/"},{"title":"（一）Java并发-多线程基础","content":"线程的几种状态\n新建状态（New）当线程对象对创建后，即进入了新建状态。\n1Thread t &#x3D; new MyThread();\n就绪状态（Runnable）当调用线程对象的 start()方法\n12Thread t &#x3D; new MyThread();t.start();\n线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待 CPU 调度执行，并不是说执行了 t.start()此线程立即就会执行；\n\n调用 start()方法\n阻塞事件解除，重新进入就绪状态\n调用 yield(),让出 CPU 调度，从运行状态进入就绪状态\nJVM 切换线程\n\n运行状态（Running）当 CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；\n\n处于就绪状态的线程获得 CPU\n\n阻塞状态（Blocked）处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：\n\nsleep() 占用 CPU 资源\nwait()  释放 CPU 资源\njoin()  等其他线程结束后才执行，会释放 CPU 资源\nI/O 操作，read(),write()操作\n\n1.等待阻塞运行状态中的线程执行 wait()方法，使本线程进入到等待阻塞状态；\n2.同步阻塞线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；\n3.其他阻塞通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。\n死亡状态（Dead）线程执行完了或者因异常退出了 run()方法，该线程结束生命周期。\n多线程实现在 Java 中实现多线程，有三种方法。\njava.lang.Thread 类扩展12345678910111213141516171819202122package Thread;&#x2F;&#x2F;重写该类的run方法class testThread extends Thread{\tprivate String name;\tpublic testThread(String name){\t\tthis.name &#x3D; name;\t}\tpublic void run(){\t\tfor(int i &#x3D; 0; i &lt; 5;i++){\t\t\tSystem.out.println(name+&quot;运行：  &quot;+i);\t\t}\t}\t}public class learnThread {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\ttestThread testTh1 &#x3D; new testThread(&quot;A&quot;);\t\ttestThread testTh2 &#x3D; new testThread(&quot;B&quot;);\t\ttestTh1.start();\t\ttestTh2.start();\t}}\n输出的结果每次都不一样。\n12345678910A运行：  0B运行：  0B运行：  1B运行：  2A运行：  1A运行：  2A运行：  3A运行：  4B运行：  3B运行：  4\n.start()调用后，线程并不会直接进入运行态，而是进入就绪态，获得除 CPU 之外的所有资源，等待获得 CPU 资源，一旦获得 CPU 资源即可进入运行态。每次执行多线层程序，得到的结果都不相同。适合线程调度顺序不影响结果的程序。\n1为什么要通过start()方法调用run方法，而不是直接调用run方法？\n查看源代码：\n123456789101112131415161718192021222324252627282930313233public synchronized void start() {    &#x2F;**     * This method is not invoked for the main method thread or &quot;system&quot;     * group threads created&#x2F;set up by the VM. Any new functionality added     * to this method in the future may have to also be added to the VM.     *     * A zero status value corresponds to state &quot;NEW&quot;.     *&#x2F;    if (threadStatus !&#x3D; 0)        throw new IllegalThreadStateException();    &#x2F;* Notify the group that this thread is about to be started     * so that it can be added to the group&#39;s list of threads     * and the group&#39;s unstarted count can be decremented. *&#x2F;    group.add(this);    boolean started &#x3D; false;    try {        start0();        started &#x3D; true;    } finally {        try {            if (!started) {                group.threadStartFailed(this);            }        } catch (Throwable ignore) {            &#x2F;* do nothing. If start0 threw a Throwable then              it will be passed up the call stack *&#x2F;        }    }}private native void start0();\n发现在源代码中，调用了一次 start0()方法，并且 start0()只声明未定义。可以看到 start0()是由 native 声明，native 一般在本地声明，异地用 C 和 C++ 来实现，也就是说 native 是调用的本机的原生系统函数。start0()是由 JVM 虚拟机实现\njava.lang.Runnable 接口实现1234567891011121314151617181920212223package Thread;\tclass testThread1 implements Runnable{\t\tprivate String name;\t\tpublic testThread1(String name){\t\t\tthis.name &#x3D; name;\t\t}\t\t@Override\t\tpublic void run() {\t\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\t\tfor(int i &#x3D; 0; i &lt; 5;i++){\t\t\t\tSystem.out.println(name+&quot;运行：  &quot;+i);\t\t\t}\t\t}\t\t\t}public class learningRunnable {\tpublic static void main(String[] args) {\t\t&#x2F;&#x2F; TODO Auto-generated method stub\t\tnew Thread(new testThread1(&quot;A&quot;)).start();\t\tnew Thread(new testThread1(&quot;B&quot;)).start();\t}}\nmain 方法其实也是一个线程。在 Java 中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到 CPU 的资源。在 Java 中，每次程序运行至少启动 2 个线程。一个是 main 线程，一个是垃圾收集线程。因为每当使用 Java 命令执行一个类的时候，实际上都会启动一个 JVM，每一个 JVM 实习在就是在操作系统中启动了一个进程。实际开发中多线程的操作很少使用 Thread 类，而是通过 Runnable 接口完成。因为实现 Runnable 接口相比继承 Thread 类有如下好处：\n12避免Java单继承的限制，一个类可以继承多个接口。适合多个相同的程序代码的线程去处理同一个资源(适合于资源的共享)\nCallable 接口实现Callable 和 Runnable 区别：\n12两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；\n123456789101112131415161718192021222324252627package Thread;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;class MyThread implements Callable&lt;String&gt;{\t@Override\tpublic String call() throws Exception {\t\tfor (int i &#x3D; 0; i &lt; 20; i++) {\t\t\tSystem.out.println(&quot;买票 ， x &#x3D; &quot; + i);\t\t}\t\treturn &quot;票没了&quot;;\t}}public class learningCallable {\tpublic static void main(String[] args) throws InterruptedException, ExecutionException {\t\tFutureTask&lt;String&gt; task  &#x3D; new FutureTask&lt;String&gt;(new MyThread());\t\tnew Thread(task).start();\t\tSystem.out.println(task.get());\t\t\t}}\n几个常用的函数stop()停止线程不推荐使用\ninterrupt()中断某个线程，这种结束方式比较粗暴，如果 t 线程打开了某个资源还没来得及关闭也就是 run 方法还没有执行完就强制结束线程，会导致资源无法关闭\nyield() 礼让线程yield()暂停线程，直接进入就绪状态，执行其他线程\n123456new Thread(()-&gt;{      for (int i &#x3D; 0; i &lt; 1000; i++){        System.out.println(&quot;01&quot;);        Thread.yield();      }    },&quot;01&quot;).start();   \njoin() 用法Thread.join()把指定线程 Thread 加到当前线程，将两个并发执行的线程合并为顺序执行的线程。例如下面的代码，加 Father 线程中调用了 Son 线程的 join 方法，直到 Son 线程执行完毕后，才会继续执行 Father 线程。\n12345678910111213141516171819202122232425262728293031323334353637383940414243public class JavaTest {\t&#x2F;**\t * \t * @param args\t *&#x2F;\tpublic static void main(String[] args) {\t\tSystem.out.println(&quot;爸爸和儿子买酱油的故事。。。&quot;);\t\tnew Thread(new Father()).start();\t}\t}class Father extends Thread{\tpublic void run(){\t\tSystem.out.println(&quot;酱油没了&quot;);\t\tSystem.out.println(&quot;让儿子打酱油。。。&quot;);\t\tThread t &#x3D; new Thread(new Son());\t\tt.start();\t\ttry {\t\t\tt.join();\t\t\tSystem.out.println(&quot;酱油终于来了&quot;);\t\t} catch (InterruptedException e) {\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t}\t\t\t}}class Son extends Thread{\tpublic void run(){\t\tSystem.out.println(&quot;接过钱、、、、、&quot;);\t\tSystem.out.println(&quot;发现了个游戏厅，玩了一会。。&quot;);\t\tfor (int i &#x3D; 0; i &lt; 10; i++){\t\t\tSystem.out.println(i + &quot;秒过去了。。。。&quot;);\t\t\ttry {\t\t\t\tThread.sleep(1000);\t\t\t} catch (InterruptedException e) {\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t}\t\t}\t\tSystem.out.println(&quot;赶紧打酱油去。。。。&quot;);\t}}\nsetPriority()线程优先级线程优先级是 1 到 10，并是不设置优先级高了，就一定优先执行。设置优先级在线程启动之前。\n\nNORM_PRIORITY 5 默认\nMIN_PRIORITY 1\nMAX_PRIORITY 10\n\n123Thread t &#x3D; new Thread(mp);t.setPriority(Thread.MAX_PRIORITY);t.start();\n守护线程 Deamon守护线程是为用户线程服务的，JVM 停止不用等待守护线程执行完毕。默认线程是用户线程，JVM 等待用户线程执行完毕才会停止。\n123Thread t &#x3D; new Thread(mp);t.setDaemon(true); &#x2F;&#x2F;默认是false;t.start();\n其他方法\n\n\n方法\n功能\n\n\n\nisAlive()\n判断线程是否还活着，即线程是否还未终止\n\n\nsetName()\n给线程起名字\n\n\ngetName()\n获取线程的名字\n\n\ncurrentThread()\n取得当前正在运行的线程对象，也就是获取自己本身\n\n\n线程间通信Java 提供了 3 个方法解决线程之间的通信问题\n\n\n\n方法名\n作用\n\n\n\nfinal void wait()\n表示线程一直等待，直到其他线程通知，与 sleep 不同，会释放锁\n\n\nfinal void wait()\n指定等待的毫秒数\n\n\nfinal void notifiy()\n唤醒一个处于等待状态的线程\n\n\nfinal void notifyAll()\n唤醒同一个对象上所有调用 wait()方法的线程，优先级别高的线程先调度\n\n\n定时任务(TimerTask 和 Timer)123456789101112131415161718192021&#x2F;&#x2F;任务类class  MyTask extends TimerTask{\t@Override\tpublic void run() {\t\tfor(int i&#x3D;0;i&lt;10;i++) {\t\t\tSystem.out.println(&quot;放空大脑休息一会&quot;);\t\t}\t\tSystem.out.println(&quot;------end-------&quot;);\t}\t}public static void main(String[] args) {\tTimer timer &#x3D; new Timer();\t&#x2F;&#x2F;执行安排\t&#x2F;&#x2F;timer.schedule(new MyTask(), 1000);  &#x2F;&#x2F;执行任务一次\t&#x2F;&#x2F;timer.schedule(new MyTask(), 1000,200); &#x2F;&#x2F;执行多次\tCalendar cal &#x3D; new GregorianCalendar(2019,12,31,21,53,54);\ttimer.schedule(new MyTask(), cal.getTime(),200); &#x2F;&#x2F;指定时间}","url":"/2020/10/22/202010/一Java并发多线程基础/","link":"","plink":"http://example.com/2020/10/22/202010/%E4%B8%80Java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"title":"（二）Java并发-可见性、原子性和有序性","content":"缓存问题造成的可见性单核CPU的情况下，多个线程使用同一个CPU,线程1读取共享变量A到CPU缓存，修改后对线程2是可见的，不存在一致性问题。一个线程对共享变量的修改对另一个线程可见称为可见性。多核CPU的情况下，线程1和线程2分别操作不同CPU的缓存，线程1对共享变量A的操作对线程2不可见，出现一致性问题。下面这段代码，使用两个线程对num分别加10000次，启动两个线程，结果应该是20000。但是结果是4537。当线程1读取到num是0，线程2读到的值也是0，线程1修改num为2，保存到内存。此时线程2也修改num为2，保存到内存中。线程1和线程2分别对num做加1操作，但是最终结果是2。\n1234567891011121314private static int num &#x3D; 0;public static void main(String[] args) {    new Thread(()-&gt;{        for (int i &#x3D; 0; i &lt; 10000; i++) {            num++;        }    }).start();    new Thread(()-&gt;{        for (int i &#x3D; 0; i &lt; 10000; i++) {            num++;        }    }).start();    System.out.println(num);}\n原子性原子性就是把事务看成是一个整体，要么完整执行，要么完全不执行，这就是原子性。一般一条语句需要多个CPU指令执行，例如：num++\n\n将num变量从内存加载到CPU寄存器\n在寄存器中将num执行+1操作\n将结果保存到内存中（缓存机制可能造成num保存到CPU缓存而不是内存中）上面步骤中，如果有其他线程操作num，就会造成数据不一致。因此i++ 是非原子性的操作。要保证原子性，Java中可以使用Synchronized或者Lock对i++加锁。\n\n原子性实现原理处理器使用总线锁定和缓存锁定两个机制保存个复杂内存操作的原子性。\n总线锁定总线锁定就是使用处理器提供的LOCK # 信号，当一个处理器在总线上输出信号时，其他处理器的请求将被阻塞，该处理器可以独占共享内存。\n缓存锁定总线锁定期间，其他处理器也无法和内存通信，开销比较大。缓存锁定会锁定共享变量内存区域的缓存并写回到内存，使用缓存一致性机制保证修改的原子性。同时处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存中的数据在总线上保持一致。缓存锁定仅能锁定一个缓存行，对于夸缓存行的数据，需要使用总线锁定。\n有序性有序性就是指代码执行的顺序，编译器为了优化性能，会改变语句的先后顺序。重排序可以分为三种：\n\n编译器优化重排序\n指令级并行的重排序\n内存系统的重排序Java中可以用Synchronized和volatile保证有序性。\n\n为什么会有重排序CPU执行指令的速度远超内存访问速度，CPU为了避免内存访问延迟，将指令管道化，尽量重拍管道内指令达到最大化利用CPU。并且CPU内部包含多个执行单元，可以组合进行算数运算，逻辑条件判断和内存操作。每个单元是并行执行的，指令也是并行执行，执行命令的顺序也增加了不确定性。","url":"/2020/10/15/202010/二Java并发可见性原子性和有序性/","link":"","plink":"http://example.com/2020/10/15/202010/%E4%BA%8CJava%E5%B9%B6%E5%8F%91%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/"},{"title":"（四）Java并发-对象在内存中的布局","content":"对象在内存中的布局Object对象内存布局查看对象在内存中的结构，需要借助Java Object Layout工具，在Maven中引入依赖：\n1234567&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;    &lt;version&gt;0.9&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n创建Object对象和数组对象，并输出内存结构：\n1234567891011121314151617181920212223242526public static void main(String[] args) {    Object o = new Object();    System.out.println(ClassLayout.parseInstance(o).toPrintable());    int[] a = new int[0];    System.out.println(ClassLayout.parseInstance(a).toPrintable());}learn20201010.User object internals: OFFSET  SIZE   TYPE DESCRIPTION                               VALUE      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)      8     4        (object header)                           43 c1 00 20 (01000011 11000001 00000000 00100000) (536920387)     12     4        (loss due to the next object alignment)Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total[I object internals: OFFSET  SIZE   TYPE DESCRIPTION                               VALUE      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)      8     4        (object header)                           6d 01 00 20 (01101101 00000001 00000000 00100000) (536871277)     12     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)     16     0    int [I.&lt;elements&gt;                             N/AInstance size: 16 bytesSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total\n根据上面的输出，重点介绍一下对象内存结构。Java对象在内存中分为三部分：\n1231、 object header（对象头）2、 instance data （实例数据）3、 padding （对齐填充字节）\n上面的Object对象里面没有变量（方法不占空间）因此没有实例数据，只有对象头和对齐填充字段，数组对象也相同。下面来说一下对象这三部分。\nObject Header对象头由一下三部分组成：\n1231、Mark Word2、Class pointer 3、array length（数组长度）\nMark WordMark Word记录对象和锁的信息，在32位JVM中长度是32bit（4字节），64位JVM中长度是64bit（8字节）。\nClass pointerClass pointer指向该对象的Class对象（方法区）。在32位JVM中长度是32bit（4字节），64位JVM中长度是64bit（8字节，可以开启-XX:+UseCompressedClassPointers参数和-XX:+UseCompressedOops参数压缩为4字节）。\narray lengtharray length只有在对象是数组时才出现，占4个字节，对比上面的Object对象和数组对象，数组对象Object header最后多出来的4个字节就是用于保存数组长度。\n实例数据实例数据不包括方法、静态变量和静态常量。\n基本数据类型\n\n\n类型\n占用空间（字节）\n\n\n\nint\n4字节\n\n\nlong\n8字节\n\n\nbyte\n1字节\n\n\nshort\n2字节\n\n\nfloat\n4字节\n\n\ndouble\n8字节\n\n\nchar\n2字节\n\n\nboolean\n1字节\n\n\n对象对象指针在32位JVM中占4字节；在64位JVM中占8字节，开启指针压缩后占4字节（默认开启，-XX:+UseCompressedOops参数）\n对齐填充字节JVM要求Java对象占用内存的大小为8bit的倍数，12字节不是8的倍数，因此补齐4个字节到16字节，这4个字节被称为对齐填充字节。\n扩展对象指针压缩在JVM启动后，-XX:+PrintFlagsFinal参数可以输出所有的JVM参数。其中-XX:+UseCompressedClassPointers参数和-XX:+UseCompressedOops默认开启，这两个参数在64位JVM环境中，可以将对象指针由8字节压缩到4字节。\n\n-XX:+UseCompressedClassPointers 压缩对象头中的Class Pointer\n-XX:+UseCompressedOops 即压缩对象头中的Class Pointer 也压缩普通对象中的对象引用指针。12345C:\\Users\\gavin&gt;java -XX:+PrintCommandLineFlags -version-XX:InitialHeapSize&#x3D;132500864 -XX:MaxHeapSize&#x3D;2120013824 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGCjava version &quot;1.8.0_211&quot;Java(TM) SE Runtime Environment (build 1.8.0_211-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)\nXX:+UseCompressedClassPointers在64位JVM环境中可以压缩Class对象指针，将指针由8字节压缩为4字节。使用：-XX:+UseCompressedClassPointers压缩后，ClassPointers仅占4字节。12345678java.lang.Object object internals: OFFSET  SIZE   TYPE DESCRIPTION                               VALUE      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)      8     4        (object header)                           e5 01 00 20 (11100101 00000001 00000000 00100000) (536871397)     12     4        (loss due to the next object alignment)Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total\n使用-XX:-UseCompressedClassPointers参数，关闭压缩，可以看到Object Header增加了4个字节变为16字节，对象占用内存是8bit的倍数，因此不需要对齐填充字节。12345678java.lang.Object object internals: OFFSET  SIZE   TYPE DESCRIPTION                               VALUE      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)      8     4        (object header)                           00 1c 4f 17 (00000000 00011100 01001111 00010111) (391060480)     12     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)Instance size: 16 bytesSpace losses: 0 bytes internal + 0 bytes external &#x3D; 0 bytes total\nXX:+UseCompressedClassPointers参数只压缩Class对象指针，-XX:+UseCompressedOops既可以压缩Class对象指针，也可以压缩普通对象的指针。编写以下代码，User对象中保存了Object对象的指针，使用-XX:+UseCompressedOops参数，并查看User对象的内存结构。12345678910public class ObjectLayout {    public static void main(String[] args) {        User o &#x3D; new User();        System.out.println(ClassLayout.parseInstance(o).toPrintable());    }}public class User {    Object o &#x3D; new Object();}\n此时可以看到User对象中保存的Object对象引用的大小仅4个字节。User对象的大小达到了8bit的倍数，这里不需要对其填充字段。12345678java20201009.User object internals: OFFSET  SIZE               TYPE DESCRIPTION                               VALUE      0     4                    (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)      4     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)      8     4                    (object header)                           43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)     12     4   java.lang.Object User.o                                    (object)Instance size: 16 bytesSpace losses: 0 bytes internal + 0 bytes external &#x3D; 0 bytes total\n使用-XX:-UseCompressedOops参数，关掉对象指针压缩，可以看到Class对象指针和引用的Object指针的大小都变成了8字节。123456789java20201009.User object internals: OFFSET  SIZE               TYPE DESCRIPTION                               VALUE      0     4                    (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)      4     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)      8     4                    (object header)                           50 35 33 1c (01010000 00110101 00110011 00011100) (473118032)     12     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)     16     8   java.lang.Object User.o                                    (object)Instance size: 24 bytesSpace losses: 0 bytes internal + 0 bytes external &#x3D; 0 bytes total","url":"/2020/10/15/202010/四Java并发对象在内存中的布局/","link":"","plink":"http://example.com/2020/10/15/202010/%E5%9B%9BJava%E5%B9%B6%E5%8F%91%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80/"},{"title":"（三）Java并发-Volatile和CAS","content":"volatile一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，两个含义：\n\n1.volatile 保证了共享变量的可见性；\n2.禁止进行指令重排序。\n\n123456789101112public class ThreadSafeInteger {      private int value;      public synchronized int get() {          return value;      }      public synchronized  void set(int value) {          this.value &#x3D; value;      }  }\n上面的同步和下面的 volatile 修饰变量是等价的。\n123456789101112public class ThreadSafeInteger {       private volatile int value;       public int get() {           return value;       }       public void set(int value) {           this.value &#x3D; value;       }   }\nvolatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。volatile 关键字不会引起线程上下文切换和线程调度，使用 volatile 还能解决重排序问题。\nLOCK 指令用 volatile 关键字修饰的共享变量，编译成字节码后增有 Lock 前缀指令。Lock 前缀的指令在多核处理器下：\n\n将当前处理器的缓存航的数据写回到系统内存\n写回内存的操作会使其他 CPU 里缓存了该内存地址的数据无效。\n处理器使用嗅探技术保证内部缓存、系统缓存和其他处理器的数据在总线上保持一致。\n\nCASvolatile 修饰变量，对共享变量做读取或者赋值操作时，具有原子性；但一个变量赋值给另一个变量是非原子性的。因此 volatile 和 CAS 结合实现原子操作。\n悲观锁和乐观锁悲观锁(Pessimistic Lock)，顾名思义，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持悲观态度。线程每次修改数据之前，都会认为别的线程会修改，所以拿数据之前会先上锁，别的线程要想使用这个数据必须等待线程释放掉锁。synchronized 就是悲观锁的一种，也被成为独占锁。乐观锁(Optimistic Lock)，顾名思义，它认为数据一般情况下不会造成冲突，所以在数据提交更新的时候，会对数据是否冲突进行检测，如果发现冲突则失败并重试，直到成功为止，可以称为自旋。\nCAS 过程乐观锁用到的主要机制就是 CAS。CAS 即(Compare and swap)，也就是比较并替换，CAS 有三个操作数分别为：内存值 V，旧的预期值 A，新的值 B。处理过程为：\n\n1、首先获取内存中的值 A\n2、A 经过自增或其他计算后变为 B\n3、对比当前内存中的 V 和 A 是否相同，相同则 B 替换 AAtomicLong 的自增就是使用这种方式实现：\n\n123456789101112public final long incrementAndGet() {    for (;;) {        long current &#x3D; get();（1）        long next &#x3D; current + 1;（2）        if (compareAndSet(current, next))（3）            return next;    }}public final boolean compareAndSet(long expect, long update) {    return unsafe.compareAndSwapLong(this, valueOffset, expect, update);}\n假如当前值为 1，那么线程 A 和检查 B 同时执行到了（3）时候各自的 next 都是 2，current=1，假如线程 A 先执行了 3，那么这个是原子性操作，会把档期值更新为 2 并且返回 1，if 判断 true 所以 incrementAndGet 返回 2.这时候线程 B 执行 3，因为 current=1 而当前变量实际值为 2,所以 if 判断为 false，继续循环，如果没有其他线程去自增变量的话，这次线程 B 就会更新变量为 3 然后退出。这里使用了无限循环使用 CAS 进行轮询检查，虽然一定程度浪费了 CPU 资源，但是相比锁来说避免的线程上下文切换和调度。\nABA 问题线程 1 获取当前内存值为：A，其他线程讲内存的值改为 B，后又改为 A。此时内存中的 A 已经不是线程 1 获取的 A，这个问题叫做 ABA 问题。\n\n1、ABA 问题无影响的可以不做处理\n2、有影响的可以加版本号，每次修改数据都修改版本号，对比值时也对比版本号即可。\n\nCAS 原理1lock cmpxchg\nCAS 主要是通过 lock cmpxchg 指令实现，单核 CPU 只需要 cmpxchg 指令，多核 CPU 使用 lock 前缀指令。\n学习资料：[1] BrianGoetz, 戈茨， 童云兰。 Java 并发编程实战[M]. 机械工业出版社， 2012.[2] 并发编程网 – ifeve.com  – 高并发编程必备基础","url":"/2020/11/05/202011/三Java并发Volatile和CAS/","link":"","plink":"http://example.com/2020/11/05/202011/%E4%B8%89Java%E5%B9%B6%E5%8F%91Volatile%E5%92%8CCAS/"},{"title":"（五）Java并发-Synchronized","content":"使用当多个线程同时读写一个状态变量，如果没有同步措施，将会出现不可预见的结果。在Java中首要的同步策略是使用Synchronized关键字，它提供了可重入的独占锁。Synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，它还保证共享变量的内存可见性。Java中每一个对象都可以作为锁，当一个线程试图访问同步代码块时，必须先获得对象的锁。\n\nSynchronized加在非静态同步方法，锁是当前实例对象\nSynchronized加在静态同步方法，锁是当前类的class对象\nSynchronized加在同步方法块，锁是括号里面的对象\n\n非静态同步方法　　非静态同步方法用的都是同一把锁——实例对象本身，当一个实例对象的非静态方法获得锁后，其他线程想要获取该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获得锁（如果其他线程访问该实例的非同步方法则不会阻塞）。注意这里是实例对象本身，如果是别的实例则不受影响。\n静态同步方法　　静态同步方法用的也是同一把锁——类对象本身，如果一个静态同步方法获得锁后，其他的静态同步方法都必须等待该方法释放锁，不管是不是同一个实例对象的静态方法还是不同实例对象的静态同步方法，只要是一个类的实例对象。静态同步方法和非静态同步方法没有竞态条件。\n同步代码块123456789101112public class Test {     public void method1()     {         synchronized(this)         {           }     }     public synchronized void method2()     {     } } \n上述代码中， synchronized 代码块中传入的是 this，和同步非静态方法是一样的，当代码块获得锁后，另一个获取 method2 方法的线程必须阻塞，代码块中传入 Test.this 和 this 的作用一样。\n123456789public class Test{       pubic static void method1(){         synchronized(Test.class){         }     }     public static synchronized void method2(){     } } \n12345678910public class Test{     public static Test test;     public Test(){         test&#x3D;this;     }     public static void method1(){         synchronized(test.getClass()){         }     } } \n上面的两段代码和静态同步方法是一样的，不能传入 this，只能使用 Class 对象。\n锁升级过程在JDK1.6之前，synchronized是重量级锁，加锁需要从用户态切换为内核态，会引起线程上下文切换和线程调度，增加系统开销。因此JDK1.6对Synchronized进行优化。优化后的Synchronized分为四种状态：无锁状态-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。\n无锁状态无锁状态mark word中的偏向锁位位0，锁标志位位01. \n偏向锁在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此引入偏向锁。偏向锁在markword上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以偏向锁就是指偏向加锁的第一个线程。如果当前对象的偏向锁标志没有设置，使用CAS竞争锁；如果设置了，尝试使用CAS将偏向锁指向当前线程。hashCode备份在线程栈上线程销毁，锁降级为无锁。\n轻量级锁如果存在多个线程争抢锁，锁升级为轻量级锁。每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁。线程通过CAS争用锁，会浪费CPU，因此线程争抢锁自旋10次，会升级为重量级锁，线程进入阻塞队列中，等待占用锁的线程释放锁，唤醒阻塞队列的线程（唤醒所有阻塞线程，因此Synchronized是非公平锁）。\n自适应自旋锁JDK1.6之后引入自适应自旋锁,意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。\n重量级锁synchronized的重量级锁基于操作系统的Mutex Lock实现，获取和释放锁会带来用户态到内核态的切换，会切换线程上下文。\n锁消除 lock eliminate1234public void add(String str1,String str2){         StringBuffer sb = new StringBuffer();         sb.append(str1).append(str2);}\n我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。\n锁粗化 lock coarsening12345678910public String test(String str){              int i = 0;       StringBuffer sb = new StringBuffer():       while(i &lt; 100){           sb.append(str);           i++;       }       return sb.toString():}\nJVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。\n原理Synchronized是使用管程实现，管程对应的英文是Monitor。在管程的数据模型中，对共享变量和条件变量的操作是封装的，当线程使用共享变量时，会尝试获得锁，每次只允许一个线程获取锁进入管程，其余线程进入同步队列。管程内有条件变量的等待队列，当线程获取锁后，因不满足条件，调用wait()后，会将线程放入等待队列中。\n123while (条件不满足) {    wait();}\n等待条件满足时，调用notifyAll()方法(Synchronized调用notifyAll()方法，是非公平锁)，等待队列中的线程进入同步队列中，并争抢锁。\n123if (条件满足) {    notifyAll();    }\n\n为什么调用wait()方法需要用while()因为调用wait()方法进入等待队列的线程，不需要经过notify()也可以退出等待状态，比如线程结束后自动退出等待状态。另外也可能调用notify()之后，条件又不满足了，还需要再进入等待队列中等待资源。\nnotifyAll()唤醒\nnotify来唤起的线程，先进入wait的线程会先被唤醒\nnotifyAll唤起的线程，默认情况使用LIFO策略，最后进入的会先被唤醒12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class NotifyTest {  private static final Object lock &#x3D; new Object();  public static void main(String[] args) {    for (int i &#x3D; 0; i &lt; 5; i++) {      new Thread(()-&gt; {        synchronized (lock) {          System.out.println(Thread.currentThread().getName()+ &quot;_准备调用wait方法!&quot;);          try {            lock.wait();          } catch (InterruptedException e) {            e.printStackTrace();          }          System.out.println(Thread.currentThread().getName()+ &quot;_收到notify通知，执行后续操作!&quot;);        }      }, &quot;thread_&quot;+i).start();    }    new Thread(()-&gt; {      synchronized (lock) {        System.out.println(Thread.currentThread().getName()+ &quot;_等待7秒后调用notify通知所有等待线程!&quot;);        try {          Thread.sleep(7 *1000);        } catch (InterruptedException e) {          e.printStackTrace();        }        lock.notifyAll();      }    }, &quot;thread_notify&quot;).start();    for (int i &#x3D; 1000; i &lt; 1005; i++) {      new Thread(()-&gt; {        System.out.println(Thread.currentThread().getName() + &quot;_进入同步队列，准备争抢锁！&quot;);        synchronized (lock) {          System.out.println(Thread.currentThread().getName()+ &quot;_同步队列获取锁资源了！&quot;);        }      }, &quot;thread_&quot;+i).start();    }  }}thread_0_准备调用wait方法!thread_3_准备调用wait方法!thread_2_准备调用wait方法!thread_1_准备调用wait方法!thread_4_准备调用wait方法!thread_notify_等待7秒后调用notify通知所有等待线程!thread_1000_进入同步队列，准备争抢锁！thread_1001_进入同步队列，准备争抢锁！thread_1002_进入同步队列，准备争抢锁！thread_1004_进入同步队列，准备争抢锁！thread_1003_进入同步队列，准备争抢锁！thread_4_收到notify通知，执行后续操作!thread_1_收到notify通知，执行后续操作!thread_2_收到notify通知，执行后续操作!thread_3_收到notify通知，执行后续操作!thread_0_收到notify通知，执行后续操作!thread_1003_同步队列获取锁资源了！thread_1004_同步队列获取锁资源了！thread_1002_同步队列获取锁资源了！thread_1000_同步队列获取锁资源了！thread_1001_同步队列获取锁资源了！","url":"/2020/11/05/202011/五Java并发Synchronized/","link":"","plink":"http://example.com/2020/11/05/202011/%E4%BA%94Java%E5%B9%B6%E5%8F%91Synchronized/"},{"title":"深入理解Java虚拟机--内存分代策略及常用参数配置","content":"内存分代策略简介HotSpot中为了提高内存对象内存分配和垃圾回收的效率，将内存分为了新生代（Eden+From Survivor+To Survivor）、老年代（OldGen）和永久代（PermGen）。新创建的对象分配在新生代，多次回收还存活的对象放在老年代，类信息、静态变量和字符串常量等存放在永久代中。新生代中需要频繁执行垃圾回收，老年代中不需要频繁垃圾回收，永久代一般来说不实现垃圾回收。这样对不同的区域实行不同的垃圾回收算法，可以提高垃圾回收效率。在Java7之前，方法区在永久代，永久代和堆隔离，使用的是堆空间，永久代大小在启动JVM时设置一个固定的值，不可变;Java7中将static从永久代移到堆中；Java8中取消永久代，使用元空间（Metaspace）替代，与堆共享物理内存，逻辑上可以认为和堆在一起。元空间使用的是系统内存，因此有足够空间。 \n新生代新生代垃圾回收效率高，Minor GC是新生代的GC，回收速度快，Eden空间不足时会触发Minor GC进行回收操作。新生代分为三块空间，一个Eden和两个Survivor（通常称为To Survivor和From Survivor），当Eden被填满，会执行Minor GC，将存活下来的对象转移到To Survivor，From Survivor中存活的对象，判断年龄阈值（默认15，一轮GC表示增加一岁），如果超过阈值就放到老年代中，没超过的存到To Survivor中，然后将To Survivor 和From Survivor互换，也就是To Survivor在GC之后永远是空的。\n老年代老年代包含长期存活的对象和多次Minor GC后存活下来的对象，通常老年代被占满或者显式调用System.gc()方法才开始垃圾回收，老年代垃圾回收也就叫Full GC/Major GC，\nJVM常用参数配置了解了内存分代策略，下面可以学习一下常用的参数配置，并查看不同内存区域的变化情况。\n怎样设置JVM参数方法很多，可以上网查询，我这里说我使用的Eclipse中设置方式。在运行Java的按钮下面，Run As下面，有一个Run Configurations-&gt;Arguments-&gt;VMarguments \nTrace跟踪参数Trace跟踪参数就是跟踪GC运行的参数。  \n打印GC简要信息12-verbose:gc  -XX:+PrintGC\n-verbose:gc   表示输出虚拟机中GC的情况-XX:+PrintGC  功能和-verbose:gc一样\n1234567   Object obj &#x3D; new byte[1*1024*1024];obj &#x3D; null;System.gc();&#x2F;* 输出：[GC (System.gc())  3020K-&gt;704K(125952K), 0.0008022 secs]   [Full GC (System.gc())  704K-&gt;514K(125952K), 0.0049984 secs]*&#x2F;\n上面的代码，将obj设置为null，让GC回收创建的BYTE数组，是属于新生代的Minor GC。调用System.gc()，是Full GC\n打印GC详细信息12-XX:+PrintGCDetails     &#x2F;&#x2F;打印GC详细信息-XX:+PrintGCTimeStamps  &#x2F;&#x2F;打印GC发生的时间戳 \n12345678910-XX:+PrintGCDetails的输出：Heap PSYoungGen      total 38400K, used 3686K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)  eden space 33280K, 11% used [0x00000000d5f00000,0x00000000d6299b30,0x00000000d7f80000)  from space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)  to   space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000) ParOldGen       total 87552K, used 0K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)  object space 87552K, 0% used [0x0000000081c00000,0x0000000081c00000,0x0000000087180000) Metaspace       used 2633K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 280K, capacity 386K, committed 512K, reserved 1048576K\n下面我简单介绍一下里面的参数：\n1PSYoungGen      total 38400K, used 3686K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)\n第一行的PSYoungGen表示新生代；total 38400K表示总大小为38400K；used 3686K表示已经使用了3686K；[0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)分别表示当前区域在内存中的位置，分别是低边界，当前边界和高边界,(0x00000000d8980000-0x00000000d5f00000)/1024/1024 = 42M,33280K+5120K+5120K=42M(eden space+from space + to space)\n文件输出GC log有时候在运行环境下，需要查看错误信息，就需要将log文件保存在本地，应该使用下面的命令：\n1-Xloggc:F:&#x2F;gc.log\n这样在F盘就出现gc.log文件，打开信息为：\n1234567891011121314Java HotSpot(TM) 64-Bit Server VM (25.192-b12) for windows-amd64 JRE (1.8.0_192-b12), built on Oct  6 2018 17:12:23 by &quot;java_re&quot; with MS VC++ 10.0 (VS2010)Memory: 4k page, physical 8272984k(2132632k free), swap 16544068k(9949684k free)CommandLine flags: -XX:InitialHeapSize&#x3D;132367744 -XX:MaxHeapSize&#x3D;2117883904 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 0.100: [GC (System.gc()) [PSYoungGen: 3020K-&gt;664K(38400K)] 3020K-&gt;672K(125952K), 0.0009640 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] 0.101: [Full GC (System.gc()) [PSYoungGen: 664K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;514K(87552K)] 672K-&gt;514K(125952K), [Metaspace: 2627K-&gt;2627K(1056768K)], 0.0054643 secs] [Times: user&#x3D;0.08 sys&#x3D;0.00, real&#x3D;0.01 secs] Heap PSYoungGen      total 38400K, used 333K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)  eden space 33280K, 1% used [0x00000000d5f00000,0x00000000d5f534a8,0x00000000d7f80000)  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000) ParOldGen       total 87552K, used 514K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)  object space 87552K, 0% used [0x0000000081c00000,0x0000000081c80ba0,0x0000000087180000) Metaspace       used 2633K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 280K, capacity 386K, committed 512K, reserved 1048576K\n监控加载了哪些类1-XX:+TraceClassLoading\n使用这个参数能获取到Java加载到的类。\n12345678910[Opened D:\\myeclipse\\binary\\jdk1.8\\jre\\lib\\rt.jar][Loaded java.lang.Object from D:\\myeclipse\\binary\\jdk1.8\\jre\\lib\\rt.jar][Loaded java.io.Serializable from D:\\myeclipse\\binary\\jdk1.8\\jre\\lib\\rt.jar][Loaded java.lang.Comparable from D:\\myeclipse\\binary\\jdk1.8\\jre\\lib\\rt.jar][Loaded java.lang.CharSequence from D:\\myeclipse\\binary\\jdk1.8\\jre\\lib\\rt.jar][Loaded java.lang.String from D:\\myeclipse\\binary\\jdk1.8\\jre\\lib\\rt.jar][Loaded java.lang.reflect.AnnotatedElement from D:\\myeclipse\\binary\\jdk1.8\\jre\\lib\\rt.jar][Loaded java.lang.reflect.GenericDeclaration from D:\\myeclipse\\binary\\jdk1.8\\jre\\lib\\rt.jar][Loaded java.lang.reflect.Type from D:\\myeclipse\\binary\\jdk1.8\\jre\\lib\\rt.jar].......\n打印类的信息1-XX:+PrintClassHistogram\n按下Ctrl+Break后，打印类的信息(四个参数分别是：序号、实例数量、总大小、类型)：\n12345678 num     #instances         #bytes  class name----------------------------------------------   1:        890617      470266000  [B   2:        890643       21375432  java.util.HashMap$Node   3:        890608       14249728  java.lang.Long   4:            13        8389712  [Ljava.util.HashMap$Node;   5:          2062         371680  [C   6:           463          41904  java.lang.Class\n堆的分配参数指定最大堆和最小堆指定参数：\n12345-Xmx-Xms&#x2F;&#x2F;下面表示最大堆为20m，最小堆是5m-Xmx20m-Xms5m\n获取JVM最大堆数据：\n123456789   &#x2F;&#x2F;获取最大堆大小System.out.print(&quot;Xmx&#x3D;&quot;);System.out.println(Runtime.getRuntime().maxMemory()&#x2F;1024.0&#x2F;1024+&quot;M&quot;);   &#x2F;&#x2F;获取空闲内存大小System.out.print(&quot;free mem&#x3D;&quot;);System.out.println(Runtime.getRuntime().freeMemory()&#x2F;1024.0&#x2F;1024+&quot;M&quot;);   &#x2F;&#x2F;获取总计内存大小System.out.print(&quot;total mem&#x3D;&quot;);System.out.println(Runtime.getRuntime().totalMemory()&#x2F;1024.0&#x2F;1024+&quot;M&quot;);\n输出结果：\n123Xmx&#x3D;1796.0M  free mem&#x3D;121.04998016357422M  total mem&#x3D;123.0M  \n也就是说，我的JVM设置最大堆是1796.0M ，总计123.0M  ，还有121.04998016357422M 可用。那么设置一下-Xmx20m -Xms5m参数，再看一下结果：\n123Xmx&#x3D;18.0Mfree mem&#x3D;4.761444091796875Mtotal mem&#x3D;5.5M\n如果分配1M的数组，再次执行：\n1byte[] b &#x3D; new byte[1*1024*1024];\n分配1M数组后，空闲空间变少：\n123Xmx&#x3D;18.0Mfree mem&#x3D;3.76141357421875Mtotal mem&#x3D;5.5M\n如果空闲空间全部使用完会怎么样呢？那我们创建一个5M的数组，看一下结果：\n1byte[] b &#x3D; new byte[5*1024*1024];\n输出的结果变成了：\n123Xmx&#x3D;18.0Mfree mem&#x3D;5.26141357421875Mtotal mem&#x3D;11.0M\n这里的最大堆没变，还是18M，总的内存大小从5.5M变成了11M，也就是说如果空闲空间不能支撑对象所需容量，那么就会扩容。\n堆的其他参数设置新生代大小(绝对参数，设置多少就是多少):\n1-Xmn\n新生代（eden+2*s）和老年代（不包含永久区）的比值:4表示 新生代:老年代=1:4，即年轻代占堆的1/5\n1-XX:NewRatio\n设置两个Survivor区和eden的比:8表示 两个Survivor :eden=2:8，即一个Survivor占年轻代的1/10\n1-XX:SurvivorRatio\n我们测试一下堆内空间的变化，创建一个10M的数组，数组是循环创建：\n123byte[] b&#x3D;null;for(int i&#x3D;0;i&lt;10;i++)\tb&#x3D;new byte[1*1024*1024];\n先看一下新生代分配1M空间：\n123456789101112配置参数：-Xmx20m -Xms20m -Xmn1m  -XX:+PrintGCDetails [GC (Allocation Failure) [PSYoungGen: 507K-&gt;504K(1024K)] 507K-&gt;504K(19968K), 0.0010025 secs] [Times: user&#x3D;0.05 sys&#x3D;0.02, real&#x3D;0.00 secs] Heap PSYoungGen      total 1024K, used 721K [0x00000000ffe80000, 0x0000000100000000, 0x0000000100000000)  eden space 512K, 42% used [0x00000000ffe80000,0x00000000ffeb6790,0x00000000fff00000)  from space 512K, 98% used [0x00000000fff00000,0x00000000fff7e030,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen       total 18944K, used 10240K [0x00000000fec00000, 0x00000000ffe80000, 0x00000000ffe80000)  object space 18944K, 54% used [0x00000000fec00000,0x00000000ff6000a0,0x00000000ffe80000) Metaspace       used 2633K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 280K, capacity 386K, committed 512K, reserved 1048576KJava HotSpot(TM) 64-Bit Server VM warning: NewSize (1536k) is greater than the MaxNewSize (1024k). A new max generation size of 1536k will be used.\n我用的JDK1.8，这里还报了Java HotSpot(TM) 64-Bit Server VM warning，主要是因为新生代的空间不足，不能分配。我们可以看到，新生代空间不足1M，因此新生代无法分配，就在老年代里面分配了10M空间。新生代发生了一次GC，回收了3K空间，可以忽略不计。那么继续增加新生代空间到15M：\n1234567891011执行参数：-Xmx20m -Xms20m -Xmn15m  -XX:+PrintGCDetailsHeap PSYoungGen      total 13824K, used 11525K [0x00000000ff100000, 0x0000000100000000, 0x0000000100000000)  eden space 12288K, 93% used [0x00000000ff100000,0x00000000ffc41760,0x00000000ffd00000)  from space 1536K, 0% used [0x00000000ffe80000,0x00000000ffe80000,0x0000000100000000)  to   space 1536K, 0% used [0x00000000ffd00000,0x00000000ffd00000,0x00000000ffe80000) ParOldGen       total 5120K, used 0K [0x00000000fec00000, 0x00000000ff100000, 0x00000000ff100000)  object space 5120K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff100000) Metaspace       used 2633K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 280K, capacity 386K, committed 512K, reserved 1048576K\n这里没有发生GC，新生代使用了11525K空间，说明新生代空间足够分配，因此没有触发GC。那么将新生代空间调整到7M会发生什么呢？\n12345678910111213执行参数：-Xmx20m -Xms20m -Xmn7m  -XX:+PrintGCDetails[GC (Allocation Failure) [PSYoungGen: 6036K-&gt;480K(6656K)] 6036K-&gt;1648K(19968K), 0.0012152 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] Heap PSYoungGen      total 6656K, used 5782K [0x00000000ff900000, 0x0000000100000000, 0x0000000100000000)  eden space 6144K, 86% used [0x00000000ff900000,0x00000000ffe2d900,0x00000000fff00000)  from space 512K, 93% used [0x00000000fff00000,0x00000000fff78020,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen       total 13312K, used 1168K [0x00000000fec00000, 0x00000000ff900000, 0x00000000ff900000)  object space 13312K, 8% used [0x00000000fec00000,0x00000000fed24020,0x00000000ff900000) Metaspace       used 2633K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 280K, capacity 386K, committed 512K, reserved 1048576K\n这里发生了一次新生代GC，回收了6036K-1648k= 4388k空间，剩下的5782k在新生代。继续调整，这次调整一下新生代中eden和Survivor的比例，设置-XX:SurvivorRatio=2，增大了Survivor的大小。\n1234567891011121314执行参数：-Xmx20m -Xms20m -Xmn7m   -XX:SurvivorRatio&#x3D;2 -XX:+PrintGCDetails[GC (Allocation Failure) [PSYoungGen: 3922K-&gt;1504K(5632K)] 3922K-&gt;1624K(18944K), 0.0025991 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] [GC (Allocation Failure) [PSYoungGen: 4656K-&gt;1504K(5632K)] 4776K-&gt;1624K(18944K), 0.0114028 secs] [Times: user&#x3D;0.08 sys&#x3D;0.00, real&#x3D;0.01 secs] [GC (Allocation Failure) [PSYoungGen: 4646K-&gt;1504K(5632K)] 4766K-&gt;1632K(18944K), 0.0024505 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] Heap PSYoungGen      total 5632K, used 2610K [0x00000000ff900000, 0x0000000100000000, 0x0000000100000000)  eden space 4096K, 27% used [0x00000000ff900000,0x00000000ffa14930,0x00000000ffd00000)  from space 1536K, 97% used [0x00000000ffd00000,0x00000000ffe78030,0x00000000ffe80000)  to   space 1536K, 0% used [0x00000000ffe80000,0x00000000ffe80000,0x0000000100000000) ParOldGen       total 13312K, used 128K [0x00000000fec00000, 0x00000000ff900000, 0x00000000ff900000)  object space 13312K, 0% used [0x00000000fec00000,0x00000000fec20010,0x00000000ff900000) Metaspace       used 2633K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 280K, capacity 386K, committed 512K, reserved 1048576K\n发生了3次新生代的GC，都是新生代的Minor GC，第一次GC回收了3922K-1624K=2298k，第二次GC回收了4776K-1624K=3152K，第三次GC回收了4766K-1632K=3134k，剩下的2610k在新生代中，还有一部分去了From Survivor中。再看一下，-XX:NewRatio=1的情况：\n12345678910111213执行参数：-Xmx20m -Xms20m -XX:NewRatio&#x3D;1    -XX:SurvivorRatio&#x3D;2 -XX:+PrintGCDetails[GC (Allocation Failure) [PSYoungGen: 4932K-&gt;1688K(7680K)] 4932K-&gt;1696K(17920K), 0.0011783 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] [GC (Allocation Failure) [PSYoungGen: 5884K-&gt;1592K(7680K)] 5892K-&gt;1600K(17920K), 0.0009533 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] Heap PSYoungGen      total 7680K, used 3834K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)  eden space 5120K, 43% used [0x00000000ff600000,0x00000000ff830ad8,0x00000000ffb00000)  from space 2560K, 62% used [0x00000000ffd80000,0x00000000fff0e040,0x0000000100000000)  to   space 2560K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffd80000) ParOldGen       total 10240K, used 8K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec02000,0x00000000ff600000) Metaspace       used 2633K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 280K, capacity 386K, committed 512K, reserved 1048576K\n可以看到，提高新生代空间之后，发生了两次GC，因为新生代能分配更多的空间，避免GC，也没有是用老年代的空间。那么再增加eden空间会怎么样呢？\n123456789101112执行参数：-Xmx20m -Xms20m -XX:NewRatio&#x3D;1   -XX:SurvivorRatio&#x3D;3 -XX:+PrintGCDetails[GC (Allocation Failure) [PSYoungGen: 6036K-&gt;1720K(8192K)] 6036K-&gt;1728K(18432K), 0.0059791 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] Heap PSYoungGen      total 8192K, used 7022K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)  eden space 6144K, 86% used [0x00000000ff600000,0x00000000ffb2d900,0x00000000ffc00000)  from space 2048K, 83% used [0x00000000ffc00000,0x00000000ffdae040,0x00000000ffe00000)  to   space 2048K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x0000000100000000) ParOldGen       total 10240K, used 8K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec02000,0x00000000ff600000) Metaspace       used 2633K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 280K, capacity 386K, committed 512K, reserved 1048576K\n提高Eden空间之后，只发生了一次GC，GC越少，说明系统执行效率越高。\nOOM内存溢出1234567891011-XX:+HeapDumpOnOutOfMemoryErrorOOM时导出堆到文件-XX:+HeapDumpPath导出OOM的路径-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;d:&#x2F;a.dump当发生OOM时，导出到文件a.dump-XX:OnOutOfMemoryError在OOM时，执行一个脚本&quot;-XX:OnOutOfMemoryError&#x3D;D:&#x2F;tools&#x2F;jdk1.7_40&#x2F;bin&#x2F;printstack.bat %p&quot;当程序OOM时，在D:&#x2F;a.txt中将会生成线程的dump可以在OOM时，发送邮件，甚至是重启程序\n默认配置新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2Edem : from : to = 8 : 1 : 1 \n永久区分配参数12-XX:PermSize  -XX:MaxPermSize设置永久区的初始空间和最大空间\n使用CGLIB等库的时候，可能会产生大量的类，这些类，有可能撑爆永久区导致OOM。\n栈空间分配1-Xss\n通常只有几百K,决定了函数调用的深度;每个线程都有独立的栈空间,局部变量、参数 分配在栈上.因为每个线程都需要分配一个栈空间，因此如果想多跑一些线程，就需要将这个值调小，容纳更多线程。\n参考资料1.JAVA 方法区是在堆里面吗2.Java虚拟机：JVM内存分代策略","url":"/2019/01/30/201901/深入理解Java虚拟机内存分代策略及常用参数配置/","link":"","plink":"http://example.com/2019/01/30/201901/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3%E7%AD%96%E7%95%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"},{"title":"Java源码分析--String详解","content":"介绍String类是final修饰，说明不可以被继承，String一旦被创建就不能改变，对String修改就会创建一个新的字符串，因此禁止使用循环修改字符串。\nSring在内存中的位置12345678910111213String str1 &#x3D; new String(&quot;hello&quot;);String str2 &#x3D; new String(&quot;hello&quot;);String str3 &#x3D; &quot;hello&quot;;String str4 &#x3D; &quot;hello&quot;;String str5 &#x3D; &quot;he&quot;+&quot;llo&quot;;String str6 &#x3D; &quot;he&quot;;String str7 &#x3D; &quot;llo&quot;;System.out.println(str1&#x3D;&#x3D;str2);         &#x2F;&#x2F;falseSystem.out.println(str1&#x3D;&#x3D;str3);         &#x2F;&#x2F;falseSystem.out.println(str3&#x3D;&#x3D;str4);         &#x2F;&#x2F;trueSystem.out.println(str4 &#x3D;&#x3D; str5);       &#x2F;&#x2F;trueSystem.out.println(str3&#x3D;&#x3D;&quot;hello&quot;);      &#x2F;&#x2F;trueSystem.out.println(str4&#x3D;&#x3D;(str6+str7));  &#x2F;&#x2F;false\n使用new创建一个String对象，会在堆内分配内存，每个对象地址都不一样，而str3会先在字符串常量池查找，没有才会添加进去，如果存在直接引用地址。最后str6+str7是在JVM运行时才操作，会创建一个新的对象。\n源码继承123public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}    \nString实现了Serializable、Comparable和CharSequence接口\n成员变量123456&#x2F;&#x2F;存放final类型的char数组，不可修改private final char value[];&#x2F;&#x2F;hash值private int hash; private static final ObjectStreamField[] serialPersistentFields &#x3D;        new ObjectStreamField[0];\n构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&#x2F;&#x2F;创建一个空的字符串public String() {    this.value &#x3D; &quot;&quot;.value;}&#x2F;&#x2F;新创建的String是参数String的副本public String(String original) {    this.value &#x3D; original.value;    this.hash &#x3D; original.hash;}&#x2F;&#x2F;传入char数组，直接拷贝数据到valuepublic String(char value[]) {    this.value &#x3D; Arrays.copyOf(value, value.length);}&#x2F;&#x2F;offset是第一个字符的索引，count是字节数，表示char数组从offset开始，获取长度为count的子数组public String(char value[], int offset, int count) {    if (offset &lt; 0) {        throw new StringIndexOutOfBoundsException(offset);    }    if (count &lt;&#x3D; 0) {        if (count &lt; 0) {            throw new StringIndexOutOfBoundsException(count);        }        &#x2F;&#x2F;长度为0        if (offset &lt;&#x3D; value.length) {            this.value &#x3D; &quot;&quot;.value;            return;        }    }    &#x2F;&#x2F; 数组越界    if (offset &gt; value.length - count) {        throw new StringIndexOutOfBoundsException(offset + count);    }    this.value &#x3D; Arrays.copyOfRange(value, offset, offset+count);}&#x2F;&#x2F;Unicode 代码点数组参数一个子数组的字符public String(int[] codePoints, int offset, int count) {    if (offset &lt; 0) {        throw new StringIndexOutOfBoundsException(offset);    }    if (count &lt;&#x3D; 0) {        if (count &lt; 0) {            throw new StringIndexOutOfBoundsException(count);        }        if (offset &lt;&#x3D; codePoints.length) {            this.value &#x3D; &quot;&quot;.value;            return;        }    }    &#x2F;&#x2F; Note: offset or count might be near -1&gt;&gt;&gt;1.    if (offset &gt; codePoints.length - count) {        throw new StringIndexOutOfBoundsException(offset + count);    }    final int end &#x3D; offset + count;    &#x2F;&#x2F; Pass 1: Compute precise size of char[]    int n &#x3D; count;    for (int i &#x3D; offset; i &lt; end; i++) {        int c &#x3D; codePoints[i];        if (Character.isBmpCodePoint(c))            continue;        else if (Character.isValidCodePoint(c))            n++;        else throw new IllegalArgumentException(Integer.toString(c));    }    &#x2F;&#x2F; Pass 2: Allocate and fill in char[]    final char[] v &#x3D; new char[n];    for (int i &#x3D; offset, j &#x3D; 0; i &lt; end; i++, j++) {        int c &#x3D; codePoints[i];        if (Character.isBmpCodePoint(c))            v[j] &#x3D; (char)c;        else            Character.toSurrogates(c, v, j++);    }    this.value &#x3D; v;}&#x2F;&#x2F;不推荐使用@Deprecatedpublic String(byte ascii[], int hibyte, int offset, int count) {    checkBounds(ascii, offset, count);    char value[] &#x3D; new char[count];    if (hibyte &#x3D;&#x3D; 0) {        for (int i &#x3D; count; i-- &gt; 0;) {            value[i] &#x3D; (char)(ascii[i + offset] &amp; 0xff);        }    } else {        hibyte &lt;&lt;&#x3D; 8;        for (int i &#x3D; count; i-- &gt; 0;) {            value[i] &#x3D; (char)(hibyte | (ascii[i + offset] &amp; 0xff));        }    }    this.value &#x3D; value;}&#x2F;&#x2F;不推荐使用@Deprecatedpublic String(byte ascii[], int hibyte) {    this(ascii, hibyte, 0, ascii.length);}&#x2F;&#x2F;public String(byte bytes[], int offset, int length, String charsetName)        throws UnsupportedEncodingException {    if (charsetName &#x3D;&#x3D; null)        throw new NullPointerException(&quot;charsetName&quot;);    checkBounds(bytes, offset, length);    this.value &#x3D; StringCoding.decode(charsetName, bytes, offset, length);}&#x2F;&#x2F;传入字节数组，使用指定字符集public String(byte bytes[], int offset, int length, Charset charset) {    if (charset &#x3D;&#x3D; null)        throw new NullPointerException(&quot;charset&quot;);    checkBounds(bytes, offset, length);    this.value &#x3D;  StringCoding.decode(charset, bytes, offset, length);}   public String(byte bytes[], String charsetName)        throws UnsupportedEncodingException {    this(bytes, 0, bytes.length, charsetName);}public String(byte bytes[], Charset charset) {    this(bytes, 0, bytes.length, charset);}public String(byte bytes[], int offset, int length) {    checkBounds(bytes, offset, length);    this.value &#x3D; StringCoding.decode(bytes, offset, length);}public String(byte bytes[]) {    this(bytes, 0, bytes.length);}public String(StringBuffer buffer) {    synchronized(buffer) {        this.value &#x3D; Arrays.copyOf(buffer.getValue(), buffer.length());    }}public String(StringBuilder builder) {    this.value &#x3D; Arrays.copyOf(builder.getValue(), builder.length());}String(char[] value, boolean share) {    &#x2F;&#x2F; assert share : &quot;unshared not supported&quot;;    this.value &#x3D; value;}\n其他方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345 &#x2F;&#x2F;获取长度 public int length() {     return value.length; }&#x2F;&#x2F;判断是否为空 public boolean isEmpty() {     return value.length &#x3D;&#x3D; 0; } &#x2F;&#x2F;获取char指定索引的值 public char charAt(int index) {     if ((index &lt; 0) || (index &gt;&#x3D; value.length)) {         throw new StringIndexOutOfBoundsException(index);     }     return value[index]; } &#x2F;&#x2F;获取指定索引处的字符（Unicode代码点） public int codePointAt(int index) {     if ((index &lt; 0) || (index &gt;&#x3D; value.length)) {         throw new StringIndexOutOfBoundsException(index);     }     return Character.codePointAtImpl(value, index, value.length); } &#x2F;&#x2F;获取指定索引之前的字符 public int codePointBefore(int index) {     int i &#x3D; index - 1;     if ((i &lt; 0) || (i &gt;&#x3D; value.length)) {         throw new StringIndexOutOfBoundsException(index);     }     return Character.codePointBeforeImpl(value, index, 0); } &#x2F;&#x2F;获取String文本范围内Unicode代码点数 public int codePointCount(int beginIndex, int endIndex) {     if (beginIndex &lt; 0 || endIndex &gt; value.length || beginIndex &gt; endIndex) {         throw new IndexOutOfBoundsException();     }     return Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex); } &#x2F;&#x2F;返回此 String 中从给定的 index 处偏移 codePointOffset 个代码点的索引。  public int offsetByCodePoints(int index, int codePointOffset) {     if (index &lt; 0 || index &gt; value.length) {         throw new IndexOutOfBoundsException();     }     return Character.offsetByCodePointsImpl(value, 0, value.length,             index, codePointOffset); } &#x2F;&#x2F;将字符串中的字符复制到目标数组中，dstBegin是目标数组中的起始偏移量 void getChars(char dst[], int dstBegin) {     System.arraycopy(value, 0, dst, dstBegin, value.length); } &#x2F;&#x2F;同上，要复制字符串中，从srcBegin开始，到srcEnd-1结束 public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {     if (srcBegin &lt; 0) {         throw new StringIndexOutOfBoundsException(srcBegin);     }     if (srcEnd &gt; value.length) {         throw new StringIndexOutOfBoundsException(srcEnd);     }     if (srcBegin &gt; srcEnd) {         throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);     }     System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); } &#x2F;&#x2F;获取命名的字符集字节数组 public byte[] getBytes(String charsetName)         throws UnsupportedEncodingException {     if (charsetName &#x3D;&#x3D; null) throw new NullPointerException();     return StringCoding.encode(charsetName, value, 0, value.length); }&#x2F;&#x2F;获取指定字符集的字节数组 public byte[] getBytes(Charset charset) {     if (charset &#x3D;&#x3D; null) throw new NullPointerException();     return StringCoding.encode(charset, value, 0, value.length); } &#x2F;&#x2F;获取默认字符集的字节数组 public byte[] getBytes() {     return StringCoding.encode(value, 0, value.length); } &#x2F;&#x2F;重写equals方法 public boolean equals(Object anObject) {     &#x2F;&#x2F;如果对象地址相同，就是相同的对象     if (this &#x3D;&#x3D; anObject) {         return true;     }     &#x2F;&#x2F;首先判断是否是String对象     if (anObject instanceof String) {         String anotherString &#x3D; (String)anObject;         int n &#x3D; value.length;         &#x2F;&#x2F;判断长度是否相同，不相同不是相同的字符串         if (n &#x3D;&#x3D; anotherString.value.length) {             char v1[] &#x3D; value;             char v2[] &#x3D; anotherString.value;             int i &#x3D; 0;             &#x2F;&#x2F;判断每一个字符是否相同             while (n-- !&#x3D; 0) {                 if (v1[i] !&#x3D; v2[i])                     return false;                 i++;             }             return true;         }     }     return false; } &#x2F;&#x2F;equals对比的是String对象，contentEquals对比CharSequence或其子类的对象 public boolean contentEquals(StringBuffer sb) {     return contentEquals((CharSequence)sb); }  public boolean contentEquals(CharSequence cs) {     &#x2F;&#x2F; Argument is a StringBuffer, StringBuilder     if (cs instanceof AbstractStringBuilder) {         if (cs instanceof StringBuffer) {             &#x2F;&#x2F;StringBuffer 是线程安全的，用synchronized块             synchronized(cs) {                return nonSyncContentEquals((AbstractStringBuilder)cs);             }         } else {             return nonSyncContentEquals((AbstractStringBuilder)cs);         }     }     &#x2F;&#x2F; 如果是String，就用equals方法     if (cs instanceof String) {         return equals(cs);     }     &#x2F;&#x2F; Argument is a generic CharSequence     char v1[] &#x3D; value;     int n &#x3D; v1.length;     if (n !&#x3D; cs.length()) {         return false;     }     for (int i &#x3D; 0; i &lt; n; i++) {         if (v1[i] !&#x3D; cs.charAt(i)) {             return false;         }     }     return true; }  private boolean nonSyncContentEquals(AbstractStringBuilder sb) {     char v1[] &#x3D; value;     char v2[] &#x3D; sb.getValue();     int n &#x3D; v1.length;     &#x2F;&#x2F;判断长度是否相同     if (n !&#x3D; sb.length()) {         return false;     }     &#x2F;&#x2F;对比每一个字符     for (int i &#x3D; 0; i &lt; n; i++) {         if (v1[i] !&#x3D; v2[i]) {             return false;         }     }     return true; } &#x2F;&#x2F;对比String，忽略大小写 public boolean equalsIgnoreCase(String anotherString) {     return (this &#x3D;&#x3D; anotherString) ? true             : (anotherString !&#x3D; null)             &amp;&amp; (anotherString.value.length &#x3D;&#x3D; value.length)             &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length); } &#x2F;&#x2F;如果字符串等于参数字符串anotherString，返回0；如果字符串小于参数字符串anotherString，返回小于0的值；如果字符串大于参数字符串anotherString，返回大于0的值 public int compareTo(String anotherString) {     int len1 &#x3D; value.length;     int len2 &#x3D; anotherString.value.length;     int lim &#x3D; Math.min(len1, len2);&#x2F;&#x2F;取长度最小的     char v1[] &#x3D; value;     char v2[] &#x3D; anotherString.value;     int k &#x3D; 0;     while (k &lt; lim) {         char c1 &#x3D; v1[k];         char c2 &#x3D; v2[k];         &#x2F;&#x2F;如果不相同，就比较不相同的字符         if (c1 !&#x3D; c2) {             return c1 - c2;         }         k++;     }     &#x2F;&#x2F;上面遍历结束还未返回，如果两个长度相同那说明两个字符串完全相同，返回0     return len1 - len2; } &#x2F;&#x2F;忽略大小写的对比 public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER                                      &#x3D; new CaseInsensitiveComparator(); private static class CaseInsensitiveComparator         implements Comparator&lt;String&gt;, java.io.Serializable {     &#x2F;&#x2F; use serialVersionUID from JDK 1.2.2 for interoperability     private static final long serialVersionUID &#x3D; 8575799808933029326L;     public int compare(String s1, String s2) {         int n1 &#x3D; s1.length();         int n2 &#x3D; s2.length();         int min &#x3D; Math.min(n1, n2);         for (int i &#x3D; 0; i &lt; min; i++) {             char c1 &#x3D; s1.charAt(i);             char c2 &#x3D; s2.charAt(i);             if (c1 !&#x3D; c2) {                 c1 &#x3D; Character.toUpperCase(c1);                 c2 &#x3D; Character.toUpperCase(c2);                 if (c1 !&#x3D; c2) {                     c1 &#x3D; Character.toLowerCase(c1);                     c2 &#x3D; Character.toLowerCase(c2);                     if (c1 !&#x3D; c2) {                         &#x2F;&#x2F; No overflow because of numeric promotion                         return c1 - c2;                     }                 }             }         }         return n1 - n2;     }     private Object readResolve() { return CASE_INSENSITIVE_ORDER; } } &#x2F;&#x2F;忽略大小写 public int compareToIgnoreCase(String str) {     return CASE_INSENSITIVE_ORDER.compare(this, str); }  public int indexOf(int ch) {     return indexOf(ch, 0); } &#x2F;&#x2F;返回指定字符第一次出现的字符串内的索引，从fromIndex开始查找，ch是字符，Unicode代码点 public int indexOf(int ch, int fromIndex) {     final int max &#x3D; value.length;     &#x2F;&#x2F;如果偏移量小于0，则从0开始查     if (fromIndex &lt; 0) {         fromIndex &#x3D; 0;     } else if (fromIndex &gt;&#x3D; max) {         &#x2F;&#x2F; 如果偏移量大于字符数量，那就返回-1，表示没找到         return -1;     }     if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) {         &#x2F;&#x2F; handle most cases here (ch is a BMP code point or a         &#x2F;&#x2F; negative value (invalid code point))         final char[] value &#x3D; this.value;         &#x2F;&#x2F;循环查找，只返回第一次出现的位置         for (int i &#x3D; fromIndex; i &lt; max; i++) {             if (value[i] &#x3D;&#x3D; ch) {                 return i;             }         }         return -1;     } else {         return indexOfSupplementary(ch, fromIndex);     } } &#x2F;&#x2F;增补字符验证 private int indexOfSupplementary(int ch, int fromIndex) {     if (Character.isValidCodePoint(ch)) {         final char[] value &#x3D; this.value;         final char hi &#x3D; Character.highSurrogate(ch);         final char lo &#x3D; Character.lowSurrogate(ch);         final int max &#x3D; value.length - 1;         for (int i &#x3D; fromIndex; i &lt; max; i++) {             if (value[i] &#x3D;&#x3D; hi &amp;&amp; value[i + 1] &#x3D;&#x3D; lo) {                 return i;             }         }     }     return -1; }&#x2F;&#x2F;返回指定字符最后一次出现的位置 public int lastIndexOf(int ch) {     return lastIndexOf(ch, value.length - 1); }  public int lastIndexOf(int ch, int fromIndex) {     if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) {         &#x2F;&#x2F; handle most cases here (ch is a BMP code point or a         &#x2F;&#x2F; negative value (invalid code point))         final char[] value &#x3D; this.value;         int i &#x3D; Math.min(fromIndex, value.length - 1);         for (; i &gt;&#x3D; 0; i--) {             if (value[i] &#x3D;&#x3D; ch) {                 return i;             }         }         return -1;     } else {         return lastIndexOfSupplementary(ch, fromIndex);     } }   private int lastIndexOfSupplementary(int ch, int fromIndex) {     if (Character.isValidCodePoint(ch)) {         final char[] value &#x3D; this.value;         char hi &#x3D; Character.highSurrogate(ch);         char lo &#x3D; Character.lowSurrogate(ch);         int i &#x3D; Math.min(fromIndex, value.length - 2);         for (; i &gt;&#x3D; 0; i--) {             if (value[i] &#x3D;&#x3D; hi &amp;&amp; value[i + 1] &#x3D;&#x3D; lo) {                 return i;             }         }     }     return -1; }  public int indexOf(String str) {     return indexOf(str, 0); }  public int indexOf(String str, int fromIndex) {     return indexOf(value, 0, value.length,             str.value, 0, str.value.length, fromIndex); } &#x2F;&#x2F;去除字符串两端空格 public String trim() {     int len &#x3D; value.length;     int st &#x3D; 0;     char[] val &#x3D; value;    &#x2F;* avoid getfield opcode *&#x2F;     while ((st &lt; len) &amp;&amp; (val[st] &lt;&#x3D; &#39; &#39;)) {         st++;     }     while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;&#x3D; &#39; &#39;)) {         len--;     }     &#x2F;&#x2F;判断前后空格，然后取子集     return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this; }\n其他的不看了。。","url":"/2019/02/07/201902/Java源码分析String详解/","link":"","plink":"http://example.com/2019/02/07/201902/Java%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90String%E8%AF%A6%E8%A7%A3/"},{"title":"Java源码分析--全面解析HashMap","content":"介绍HashMap是基于哈希表的Map接口的实现，并允许使用 null 值和 null 键。HashMap在JDK1.8之前使用的是哈希表+链表的方式存储数据。在JDK1.8之后，如果链表过长则将链表转成红黑树。 \n源码分析继承123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable {}\nHashMap继承了AbstractMap及实现了Map、Cloneable和Serializable接口。\n成员变量1234567891011121314151617181920212223242526private static final long serialVersionUID &#x3D; 362498820763181265L;&#x2F;&#x2F; aka 16 默认的初始容量  1*2*2*2*2 &#x3D; 16static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F;最大容量是2的30次方static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;   &#x2F;&#x2F;填充因子是0.75.如果哈希表中的元素超过了加载因子与当前容量的乘积，就调用rehash方法static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f; &#x2F;&#x2F;阈值，当桶上的链表数大于这个值会转成红黑树static final int TREEIFY_THRESHOLD &#x3D; 8;&#x2F;&#x2F;当桶中的立案表述小于这个值则红黑树转成链表static final int UNTREEIFY_THRESHOLD &#x3D; 6; &#x2F;&#x2F;转成红黑树之前，判断键值对数量大于64才会转换。static final int MIN_TREEIFY_CAPACITY &#x3D; 64;&#x2F;&#x2F;哈希表数组，长度一直为2的幂次transient Node&lt;K,V&gt;[] table;&#x2F;&#x2F;键值对集合transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;&#x2F;&#x2F;键值对的数量transient int size;&#x2F;&#x2F;统计操作次数，迭代的时候判断这个值是否变化，fail-fast抛出ConcurrentModificationExceptiontransient int modCount;&#x2F;&#x2F;阈值，键值对数量大于这个值将开始扩容。threshold &#x3D; table.length * loadFactorint threshold;&#x2F;&#x2F;这个才是填充因子，上面DEFAULT_LOAD_FACTOR是默认的final float loadFactor;\nNode 结点1234567891011121314151617181920212223242526272829303132333435363738394041424344static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    &#x2F;&#x2F;存的结点的hash值    final int hash;      &#x2F;&#x2F;K和V的值，这里V不用final修饰。K用final修饰，说明键只能赋值一次，不能改变，但是值可以改变    final K key;    V value;    &#x2F;&#x2F;指向下一个结点    Node&lt;K,V&gt; next;    &#x2F;&#x2F;创建一个结点    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {        this.hash &#x3D; hash;        this.key &#x3D; key;        this.value &#x3D; value;        this.next &#x3D; next;    }    public final K getKey()        { return key; }    public final V getValue()      { return value; }    public final String toString() { return key + &quot;&#x3D;&quot; + value; }    public final int hashCode() {        return Objects.hashCode(key) ^ Objects.hashCode(value);    }    &#x2F;&#x2F;    public final V setValue(V newValue) {        V oldValue &#x3D; value;        value &#x3D; newValue;        return oldValue;    }    public final boolean equals(Object o) {        if (o &#x3D;&#x3D; this)            return true;        &#x2F;&#x2F;instanceof 判断对象o是否是类Map.Entry的一个实例        if (o instanceof Map.Entry) {            Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;            if (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                return true;        }        return false;    }}\n构造函数1234567891011121314151617181920212223242526272829303132333435363738&#x2F;&#x2F;传入初始容量和填充因子public HashMap(int initialCapacity, float loadFactor) {    &#x2F;&#x2F;判断初始容量是否合法    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                           initialCapacity)    &#x2F;&#x2F;如果传入的初始容量大于最大容量，将用最大容量作为初始容量    if (initialCapacity &gt; MAXIMUM_CAPACITY)        &#x2F;&#x2F;初始容量在这里有啥用？？？        initialCapacity &#x3D; MAXIMUM_CAPACITY;    &#x2F;&#x2F;判断填充因子是否合法    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                           loadFactor);    this.loadFactor &#x3D; loadFactor;    &#x2F;&#x2F;计算出来threshold阈值    this.threshold &#x3D; tableSizeFor(initialCapacity);}&#x2F;*将初始化容量转化为大于等于最接近cap的2的整数次幂|是或运算，&gt;&gt;&gt;是无符号右移，空位0补齐以n &#x3D; 011011，011011 &gt;&gt;&gt; 1 &#x3D; 001101 011011 | 001101 &#x3D; 011111.....然后继续下去，最后得到最高位和后面的都是1，就能保证结果大于等于n，并且n为奇数，最后再加1.因为int为32位，所以最后肯定能让所有位都为1*&#x2F;static final int tableSizeFor(int cap) {    &#x2F;&#x2F;cap减一，是防止传进来的是2的整数次幂，减一后保证最后结果是cap本身    int n &#x3D; cap - 1;    n |&#x3D; n &gt;&gt;&gt; 1;    n |&#x3D; n &gt;&gt;&gt; 2;    n |&#x3D; n &gt;&gt;&gt; 4;    n |&#x3D; n &gt;&gt;&gt; 8;    n |&#x3D; n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}\n12345&#x2F;&#x2F;如果没有传入填充因子，则使用默认的填充因子public HashMap(int initialCapacity) {    this(initialCapacity, DEFAULT_LOAD_FACTOR);}\n12345&#x2F;&#x2F;只默认了填充因子public HashMap() {    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted}\n123456789101112131415161718192021222324252627282930&#x2F;&#x2F;传入一个Map初始化public HashMap(Map&lt;? extends K, ? extends V&gt; m) {    &#x2F;&#x2F;使用默认填充因子    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);}final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {    &#x2F;&#x2F;s是长度    int s &#x3D; m.size();    if (s &gt; 0) {        &#x2F;&#x2F;如果哈希表没有初始化        if (table &#x3D;&#x3D; null) { &#x2F;&#x2F; pre-size            float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F;            int t &#x3D; ((ft &lt; (float)MAXIMUM_CAPACITY) ?                     (int)ft : MAXIMUM_CAPACITY);            &#x2F;&#x2F;计算出来的t大于阈值，则用t初始化阈值            if (t &gt; threshold)                threshold &#x3D; tableSizeFor(t);        } &#x2F;&#x2F;m的个数大于阈值，则进行扩容        else if (s &gt; threshold)            resize();        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {            K key &#x3D; e.getKey();            V value &#x3D; e.getValue();            putVal(hash(key), key, value, false, evict);        }    }}\n其他方法(table.length - 1) &amp; hashHashMap根据key的hashCode计算hash值，知道hash值之后怎么确定key在数组中的位置呢，这里就用到了(table.length - 1) &amp; hash；首先使用(table.length - 1) 和hash进行与操作，不用担心数组越界。那为什么要数组长度减一呢？假设数组长度是16,假设有两个hashcode是8和9:8的二进制：10009的二进制：100116的二进制是：100008 &amp; 16 = 100009 &amp; 16 = 10000这样出现了两个不同的hashcode在一个数组中，增加了查找的次数如果table.length - 1，也就是16-1：15的二进制：11118 &amp; 15 = 10009 &amp; 15 = 1001\nget123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F;传入Key，返回Valuepublic V get(Object key) {    Node&lt;K,V&gt; e;    &#x2F;&#x2F;这里也能看到hashmap可以保存null    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;}&#x2F;&#x2F;传入Key的hash值和key的值final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    &#x2F;&#x2F;判断数组是否是null，数组长度是否大于0，取出来的结点是否为null    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) {        &#x2F;&#x2F;先判断结点的hash值是否相同，再判断key是否相同，都相同就返回这个结点        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            return first;        &#x2F;&#x2F;如果数组中还有其他的结点，就继续查找        if ((e &#x3D; first.next) !&#x3D; null) {            &#x2F;&#x2F;判断first是不是红黑树            if (first instanceof TreeNode)                &#x2F;&#x2F;调用TreeNode中的getTreeNode方法，我还没看TreeNode类，一会写                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            &#x2F;&#x2F;不是红黑树，是链表，开始遍历链表            do {                if (e.hash &#x3D;&#x3D; hash &amp;&amp;                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))                    return e;            } while ((e &#x3D; e.next) !&#x3D; null);        }    }    return null;}\n红黑树红黑树不是严格的平衡二叉树，红黑树比AVL树不平衡最多一层，查询上比AVL最多多一次比较。红黑树在添加和删除结点时比AVL减少旋转次数，旋转三次以内就会解决不平衡，而AVL树追求严格平衡，旋转次数很多。因此大多选用红黑树。\n\n  树根：必须是黑色\n  叶子节点：黑色（NULL）\n  红色节点的子节点都是黑色（不存在两个红色节点连续）\n  从任一节点到每个叶子节点路径包含相同数量的黑色节点\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {    TreeNode&lt;K,V&gt; parent;  &#x2F;&#x2F; 父节点    TreeNode&lt;K,V&gt; left;    TreeNode&lt;K,V&gt; right;    TreeNode&lt;K,V&gt; prev;    &#x2F;&#x2F; 前一个节点    boolean red;  &#x2F;&#x2F;颜色    &#x2F;*    这个构造函数调用了super()，LinkedHashMap.Entry的构造函数中也是调用super();就回到了上面的Node类中：    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {}    *&#x2F;    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {        super(hash, key, val, next);    }    &#x2F;**     * 返回这个节点的根节点，就是不断向上找     *&#x2F;    final TreeNode&lt;K,V&gt; root() {        for (TreeNode&lt;K,V&gt; r &#x3D; this, p;;) {            &#x2F;&#x2F;根节点的父节点是null            if ((p &#x3D; r.parent) &#x3D;&#x3D; null)                return r;            r &#x3D; p;        }    }    &#x2F;**     * 确保传进来的root节点是这个二叉树的根节点     *&#x2F;    static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) {        int n;&#x2F;&#x2F;n是HashMap的数组长度        &#x2F;&#x2F;验证传进来的参数是否合法，tab是HashMap的哈希表        if (root !&#x3D; null &amp;&amp; tab !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0) {            &#x2F;&#x2F;上面解释过了，index是哈希表数组的索引            int index &#x3D; (n - 1) &amp; root.hash;            &#x2F;&#x2F;如果是红黑树的结构，哈希表数组中存储的结点是红黑树的头节点，所以这里直接取tab[index]就是取出来红黑树的头节点，可以看上面的图            TreeNode&lt;K,V&gt; first &#x3D; (TreeNode&lt;K,V&gt;)tab[index];            &#x2F;&#x2F;如果头节点和传进来的root不相同            if (root !&#x3D; first) {                Node&lt;K,V&gt; rn;                &#x2F;&#x2F;直接把root放进去                tab[index] &#x3D; root;                TreeNode&lt;K,V&gt; rp &#x3D; root.prev;&#x2F;&#x2F;rp等于root结点的前一个结点                &#x2F;&#x2F;如果存在下一个结点                &#x2F;*                这里是这样：rp--&gt;root--&gt;rn 现在把root拿出来当红黑树的根结点了变成了：rp--&gt;rn                因为是双向链表,需要：rp&lt;--rn                *&#x2F;                if ((rn &#x3D; root.next) !&#x3D; null)                    &#x2F;&#x2F;下一个结点rn的前驱结点设置为root的前驱rp&lt;--rn                    ((TreeNode&lt;K,V&gt;)rn).prev &#x3D; rp;                if (rp !&#x3D; null)                    &#x2F;&#x2F;rp--&gt;rn                    rp.next &#x3D; rn;                &#x2F;*                这里变成了：root--&gt;frist；null&lt;--root&lt;--frist                *&#x2F;                if (first !&#x3D; null)                    first.prev &#x3D; root;                root.next &#x3D; first;                root.prev &#x3D; null;            }            &#x2F;&#x2F;checkInvariants()方法还没看，这里如果返回false就会抛出AssertionError错误，然后终止执行            assert checkInvariants(root);        }    }    &#x2F;**     * Finds the node starting at root p with the given hash and key.     * The kc argument caches comparableClassFor(key) upon first use     * comparing keys.     h：hash值   k：key   kc:缓存key？     给定hash值和key找到这个节点     *&#x2F;    final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {        &#x2F;&#x2F;从节点p还是查找        TreeNode&lt;K,V&gt; p &#x3D; this;        do {            &#x2F;&#x2F;ph:p节点的hash值； pk:节点p的key            int ph, dir; K pk;            TreeNode&lt;K,V&gt; pl &#x3D; p.left, pr &#x3D; p.right, q;            &#x2F;*                这里能看出来，红黑树是根据hash值来判断一个节点应该去左边还是右边。这里可能会有个疑问，前面判断在哈希表数组索引也是用的hash值，那红黑树中所有的hash值不应该一样吗？其实，前面哈希表数组中判断的hash值是Node节点的hash值：Objects.hashCode(key) ^ Objects.hashCode(value);也就是key的hash值和value的hash值取异或，而这里用到的hash值是key的hash值，还不知道value是多少。            *&#x2F;            &#x2F;&#x2F;h小于p节点的hash值，向左查找            if ((ph &#x3D; p.hash) &gt; h)                p &#x3D; pl;            &#x2F;&#x2F;h大于p节点的hash值，向右查找            else if (ph &lt; h)                p &#x3D; pr;            &#x2F;&#x2F;判断key是否相同，相同就查找到了            else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (k !&#x3D; null &amp;&amp; k.equals(pk)))                return p;            &#x2F;&#x2F;这是出现hash值相同但是key不同的情况？            else if (pl &#x3D;&#x3D; null)                &#x2F;&#x2F;左子树是null就去右子树找                p &#x3D; pr;            else if (pr &#x3D;&#x3D; null)                &#x2F;&#x2F;左子树是null去右子树找                p &#x3D; pl;            &#x2F;&#x2F;comparableClassFor方法是获取k的运行时类型，compareComparables方法先判断，key与运行时kc是同类型，在通过调用k和kc实现的Comparable接口的compareTo进行比较            else if ((kc !&#x3D; null ||                      (kc &#x3D; comparableClassFor(k)) !&#x3D; null) &amp;&amp;                     (dir &#x3D; compareComparables(kc, k, pk)) !&#x3D; 0)                p &#x3D; (dir &lt; 0) ? pl : pr;            &#x2F;&#x2F;在右子树里面递归            else if ((q &#x3D; pr.find(h, k, kc)) !&#x3D; null)                return q;            else                p &#x3D; pl;        } while (p !&#x3D; null);        return null;    }    &#x2F;**     * 从根节点开始查找     *&#x2F;    final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {        &#x2F;&#x2F;parent&#x3D;&#x3D;null 就说明是根结点，否则就找到根结点再查找        return ((parent !&#x3D; null) ? root() : this).find(h, k, null);    }    &#x2F;**        比较两个对象的大小，不会返回0     *&#x2F;    static int tieBreakOrder(Object a, Object b) {        int d;        &#x2F;&#x2F;比较类名，如果相同，调用本地方法为对象生成hashcode值，再继续比较        if (a &#x3D;&#x3D; null || b &#x3D;&#x3D; null ||            (d &#x3D; a.getClass().getName().             compareTo(b.getClass().getName())) &#x3D;&#x3D; 0)            d &#x3D; (System.identityHashCode(a) &lt;&#x3D; System.identityHashCode(b) ?                 -1 : 1);        return d;    }    &#x2F;**     * 链表转成红黑树     *&#x2F;    final void treeify(Node&lt;K,V&gt;[] tab) {        TreeNode&lt;K,V&gt; root &#x3D; null;        for (TreeNode&lt;K,V&gt; x &#x3D; this, next; x !&#x3D; null; x &#x3D; next) {            &#x2F;&#x2F;把x在链表里面取出来，next指向下一个结点            next &#x3D; (TreeNode&lt;K,V&gt;)x.next;            x.left &#x3D; x.right &#x3D; null;&#x2F;&#x2F;设置左右子树为null            &#x2F;&#x2F;如果x是第一个结点，也就是root为null的情况，将父结点指向null，颜色是黑色            if (root &#x3D;&#x3D; null) {                x.parent &#x3D; null;                x.red &#x3D; false;                root &#x3D; x;            }            else {                K k &#x3D; x.key;                int h &#x3D; x.hash;                Class&lt;?&gt; kc &#x3D; null;                &#x2F;&#x2F;下面的代码和find函数差不多，就是找到k应该去的位置。                for (TreeNode&lt;K,V&gt; p &#x3D; root;;) {                    int dir, ph;                    K pk &#x3D; p.key;                    if ((ph &#x3D; p.hash) &gt; h)                        dir &#x3D; -1;                    else if (ph &lt; h)                        dir &#x3D; 1;                    else if ((kc &#x3D;&#x3D; null &amp;&amp;                              (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||                             (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0)                        dir &#x3D; tieBreakOrder(k, pk);                    TreeNode&lt;K,V&gt; xp &#x3D; p;                    &#x2F;&#x2F;dir小于等于0去左边，大于0去右边。这里找到了应该去的位置                    if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) {                        x.parent &#x3D; xp;                        if (dir &lt;&#x3D; 0)                            xp.left &#x3D; x;                        else                            xp.right &#x3D; x;                        &#x2F;&#x2F;旋转节点，保持平衡                        root &#x3D; balanceInsertion(root, x);                        break;                    }                }            }        }        &#x2F;&#x2F;将根节点放进去        moveRootToFront(tab, root);    }    &#x2F;**     * 将树转成链表     *&#x2F;    final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {        Node&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;        for (Node&lt;K,V&gt; q &#x3D; this; q !&#x3D; null; q &#x3D; q.next) {            Node&lt;K,V&gt; p &#x3D; map.replacementNode(q, null);            if (tl &#x3D;&#x3D; null)                hd &#x3D; p;            else                tl.next &#x3D; p;            tl &#x3D; p;        }        return hd;    }    &#x2F;**     * 插入元素     *&#x2F;    final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,                                   int h, K k, V v) {        Class&lt;?&gt; kc &#x3D; null;        boolean searched &#x3D; false;&#x2F;&#x2F;标记是否查找一次        TreeNode&lt;K,V&gt; root &#x3D; (parent !&#x3D; null) ? root() : this; &#x2F;&#x2F;获取根结点        for (TreeNode&lt;K,V&gt; p &#x3D; root;;) {            int dir, ph; K pk;            if ((ph &#x3D; p.hash) &gt; h)                dir &#x3D; -1;            else if (ph &lt; h)                dir &#x3D; 1;            else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (k !&#x3D; null &amp;&amp; k.equals(pk)))                return p;            else if ((kc &#x3D;&#x3D; null &amp;&amp;                      (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||                     (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) {                &#x2F;&#x2F;如果K和PK通过COMPARATO比较之后，如果相同就进来，并且只会进来一次                if (!searched) {                    TreeNode&lt;K,V&gt; q, ch;                    searched &#x3D; true;                    &#x2F;&#x2F;从左子树或者右子树中找到就返回                    if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;                         (q &#x3D; ch.find(h, k, kc)) !&#x3D; null) ||                        ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;                         (q &#x3D; ch.find(h, k, kc)) !&#x3D; null))                        return q;                }                dir &#x3D; tieBreakOrder(k, pk);            }            &#x2F;&#x2F;找到合适的位置，然后插入            TreeNode&lt;K,V&gt; xp &#x3D; p;            if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) {                Node&lt;K,V&gt; xpn &#x3D; xp.next;                &#x2F;&#x2F;创建一个新的节点                TreeNode&lt;K,V&gt; x &#x3D; map.newTreeNode(h, k, v, xpn);                if (dir &lt;&#x3D; 0)                    xp.left &#x3D; x;                else                    xp.right &#x3D; x;                xp.next &#x3D; x;                x.parent &#x3D; x.prev &#x3D; xp;                if (xpn !&#x3D; null)                    ((TreeNode&lt;K,V&gt;)xpn).prev &#x3D; x;                moveRootToFront(tab, balanceInsertion(root, x));                return null;            }        }    }           &#x2F;*        删除结点        1.如果删除的是红色结点则不影响性质        2。如果删除的是黑色结点，那么路径上会少一个黑色结点，破坏了性质     *&#x2F;    final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,                              boolean movable) {        int n;        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)            return;        int index &#x3D; (n - 1) &amp; hash;        &#x2F;&#x2F;找到根结点        TreeNode&lt;K,V&gt; first &#x3D; (TreeNode&lt;K,V&gt;)tab[index], root &#x3D; first, rl;        &#x2F;&#x2F;succ表示下一个结点，pred表示上一个结点        TreeNode&lt;K,V&gt; succ &#x3D; (TreeNode&lt;K,V&gt;)next, pred &#x3D; prev;        &#x2F;&#x2F;如果要删除根结点，直接将下一个结点提上来        if (pred &#x3D;&#x3D; null)            tab[index] &#x3D; first &#x3D; succ;        &#x2F;&#x2F;否则就直接将当前结点的上一个结点指向当前结点的下一个结点        else            pred.next &#x3D; succ;        if (succ !&#x3D; null)            succ.prev &#x3D; pred;        if (first &#x3D;&#x3D; null)            return;        &#x2F;&#x2F;根结点赋值到root        if (root.parent !&#x3D; null)            root &#x3D; root.root();        &#x2F;&#x2F;红黑树结点太少，转换成链表返回        if (root &#x3D;&#x3D; null            || (movable                &amp;&amp; (root.right &#x3D;&#x3D; null                    || (rl &#x3D; root.left) &#x3D;&#x3D; null                    || rl.left &#x3D;&#x3D; null))) {            tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small            return;        }        TreeNode&lt;K,V&gt; p &#x3D; this, pl &#x3D; left, pr &#x3D; right, replacement;        &#x2F;*        找到结点之后，需要删除结点，红黑树删除结点分为几种情况：        情况1：删除的结点左右子树都非空（按其他二叉树删除的方式处理，转变成其他的下面的三种情况）        情况2：删除的结点左子树为空，右子树非空        情况3：删除的结点右子树为空，左子树非空        情况4：删除的结点左右子树都为空        *&#x2F;        &#x2F;&#x2F;情况1        if (pl !&#x3D; null &amp;&amp; pr !&#x3D; null) {            &#x2F;&#x2F;这里s指向的是当前结点p的右节点            TreeNode&lt;K,V&gt; s &#x3D; pr, sl;            &#x2F;&#x2F;不断找要删除结点的右子树里面的最左结点，赋值给s            while ((sl &#x3D; s.left) !&#x3D; null) &#x2F;&#x2F; find successor                s &#x3D; sl;            &#x2F;&#x2F;交换要删除结点右子树的最左叶子节点s和要删除结点p的颜色            boolean c &#x3D; s.red; s.red &#x3D; p.red; p.red &#x3D; c; &#x2F;&#x2F; swap colors            TreeNode&lt;K,V&gt; sr &#x3D; s.right;            TreeNode&lt;K,V&gt; pp &#x3D; p.parent;            &#x2F;&#x2F;特殊情况，如果p结点的右结点s没有左孩子            if (s &#x3D;&#x3D; pr) { &#x2F;&#x2F; p was s&#39;s direct parent                &#x2F;&#x2F;直接交换p结点和s结点                p.parent &#x3D; s;                s.right &#x3D; p;            }            else {                TreeNode&lt;K,V&gt; sp &#x3D; s.parent;                &#x2F;&#x2F;还是交换s结点和p结点                if ((p.parent &#x3D; sp) !&#x3D; null) {                    if (s &#x3D;&#x3D; sp.left)                        sp.left &#x3D; p;                    else                        sp.right &#x3D; p;                }                if ((s.right &#x3D; pr) !&#x3D; null)                    pr.parent &#x3D; s;            }            p.left &#x3D; null;            &#x2F;&#x2F;如果s存在右结点，就将p设置为sr的父结点            if ((p.right &#x3D; sr) !&#x3D; null)                sr.parent &#x3D; p;            &#x2F;&#x2F;p的左结点给s            if ((s.left &#x3D; pl) !&#x3D; null)                pl.parent &#x3D; s;            &#x2F;&#x2F;p的父结点给s            if ((s.parent &#x3D; pp) &#x3D;&#x3D; null)                root &#x3D; s;            else if (p &#x3D;&#x3D; pp.left)                pp.left &#x3D; s;            else                pp.right &#x3D; s;            &#x2F;&#x2F;如果s有右结点，则replacement等于右结点，否则为p            if (sr !&#x3D; null)                replacement &#x3D; sr;            else                replacement &#x3D; p;        }        &#x2F;&#x2F;情况3        else if (pl !&#x3D; null)            replacement &#x3D; pl;        &#x2F;&#x2F;情况2        else if (pr !&#x3D; null)            replacement &#x3D; pr;        else       &#x2F;&#x2F;情况4            replacement &#x3D; p;        &#x2F;&#x2F;当p有孩子或者s有孩子，进行删除结点操作        if (replacement !&#x3D; p) {            TreeNode&lt;K,V&gt; pp &#x3D; replacement.parent &#x3D; p.parent;            if (pp &#x3D;&#x3D; null)                root &#x3D; replacement;            else if (p &#x3D;&#x3D; pp.left)                pp.left &#x3D; replacement;            else                pp.right &#x3D; replacement;            p.left &#x3D; p.right &#x3D; p.parent &#x3D; null;        }        &#x2F;&#x2F;对红黑树进行调整        TreeNode&lt;K,V&gt; r &#x3D; p.red ? root : balanceDeletion(root, replacement);        &#x2F;&#x2F;当p结点没有孩子，或者s结点没有孩子，进行删除操作        if (replacement &#x3D;&#x3D; p) {  &#x2F;&#x2F; detach            TreeNode&lt;K,V&gt; pp &#x3D; p.parent;            p.parent &#x3D; null;            if (pp !&#x3D; null) {                if (p &#x3D;&#x3D; pp.left)                    pp.left &#x3D; null;                else if (p &#x3D;&#x3D; pp.right)                    pp.right &#x3D; null;            }        }        if (movable)            moveRootToFront(tab, r);    }    &#x2F;**        红黑树扩容时调用拆分方法，将红黑树拆成两个链表     *&#x2F;    final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {        TreeNode&lt;K,V&gt; b &#x3D; this;        &#x2F;&#x2F; Relink into lo and hi lists, preserving order        TreeNode&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;        TreeNode&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;        &#x2F;&#x2F;两个变量计数，如果很小将变成链表，否则变成红黑树        int lc &#x3D; 0, hc &#x3D; 0;        for (TreeNode&lt;K,V&gt; e &#x3D; b, next; e !&#x3D; null; e &#x3D; next) {            next &#x3D; (TreeNode&lt;K,V&gt;)e.next;            e.next &#x3D; null;            if ((e.hash &amp; bit) &#x3D;&#x3D; 0) {                if ((e.prev &#x3D; loTail) &#x3D;&#x3D; null)                    loHead &#x3D; e;                else                    loTail.next &#x3D; e;                loTail &#x3D; e;                ++lc;            }            else {                if ((e.prev &#x3D; hiTail) &#x3D;&#x3D; null)                    hiHead &#x3D; e;                else                    hiTail.next &#x3D; e;                hiTail &#x3D; e;                ++hc;            }        }        if (loHead !&#x3D; null) {            &#x2F;&#x2F;UNTREEIFY_THRESHOLD &#x3D; 6  ,如果拆分后小于这个值就转成链表，否则就转成红黑树            if (lc &lt;&#x3D; UNTREEIFY_THRESHOLD)                tab[index] &#x3D; loHead.untreeify(map);            else {                tab[index] &#x3D; loHead;                if (hiHead !&#x3D; null) &#x2F;&#x2F; (else is already treeified)                    loHead.treeify(tab);            }        }        if (hiHead !&#x3D; null) {            if (hc &lt;&#x3D; UNTREEIFY_THRESHOLD)                tab[index + bit] &#x3D; hiHead.untreeify(map);            else {                tab[index + bit] &#x3D; hiHead;                if (loHead !&#x3D; null)                    hiHead.treeify(tab);            }        }    }    &#x2F;* ------------------------------------------------------------ *&#x2F;    &#x2F;&#x2F; Red-black tree methods, all adapted from CLR    &#x2F;&#x2F;下面是左旋和右旋调整结点，在我另外一篇博客中已经将清楚了[算法导论学习笔记--红黑树](https:&#x2F;&#x2F;www.gwt.fun&#x2F;articles&#x2F;2017&#x2F;08&#x2F;26&#x2F;1546585401831.html#%E6%97%8B%E8%BD%AC)    &#x2F;&#x2F;左旋    static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,                                          TreeNode&lt;K,V&gt; p) {        TreeNode&lt;K,V&gt; r, pp, rl;        if (p !&#x3D; null &amp;&amp; (r &#x3D; p.right) !&#x3D; null) {            if ((rl &#x3D; p.right &#x3D; r.left) !&#x3D; null)                rl.parent &#x3D; p;            if ((pp &#x3D; r.parent &#x3D; p.parent) &#x3D;&#x3D; null)                (root &#x3D; r).red &#x3D; false;            else if (pp.left &#x3D;&#x3D; p)                pp.left &#x3D; r;            else                pp.right &#x3D; r;            r.left &#x3D; p;            p.parent &#x3D; r;        }        return root;    }    &#x2F;&#x2F;右旋    static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,                                           TreeNode&lt;K,V&gt; p) {        TreeNode&lt;K,V&gt; l, pp, lr;        if (p !&#x3D; null &amp;&amp; (l &#x3D; p.left) !&#x3D; null) {            if ((lr &#x3D; p.left &#x3D; l.right) !&#x3D; null)                lr.parent &#x3D; p;            if ((pp &#x3D; l.parent &#x3D; p.parent) &#x3D;&#x3D; null)                (root &#x3D; l).red &#x3D; false;            else if (pp.right &#x3D;&#x3D; p)                pp.right &#x3D; l;            else                pp.left &#x3D; l;            l.right &#x3D; p;            p.parent &#x3D; l;        }        return root;    }    &#x2F;*    插入结点后调整方法，插入结点遵循下面的规则：    1、插入的结点重视红色    2、如果插入结点的父结点是黑色，能保证性质    3、如果是红色，则破坏了性质，必须进行重新染色或者旋转    插入过程详解过程：https:&#x2F;&#x2F;www.gwt.fun&#x2F;articles&#x2F;2017&#x2F;08&#x2F;26&#x2F;1546585401831.html#%E6%8F%92%E5%85%A5    *&#x2F;    static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,                                                TreeNode&lt;K,V&gt; x) {        x.red &#x3D; true; &#x2F;&#x2F;先设置插入的结点为红色        &#x2F;&#x2F;xp：x的父结点；xpp：x的父结点的父结点，也就是爷爷结点；xppl：爷爷结点的左节点；xppr：爷爷结点的右结点        for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) {            &#x2F;&#x2F;如果x的父结点是null，表示x是根结点，直接返回x            if ((xp &#x3D; x.parent) &#x3D;&#x3D; null) {                x.red &#x3D; false;                return x;            }            &#x2F;&#x2F;如果父结点是黑色或者不存在爷爷结点，就直接返回            else if (!xp.red || (xpp &#x3D; xp.parent) &#x3D;&#x3D; null)                return root;            &#x2F;&#x2F;如果父结点是爷爷结点的左结点            if (xp &#x3D;&#x3D; (xppl &#x3D; xpp.left)) {                &#x2F;&#x2F;如果爷爷结点的右结点存在，并且该结点是红色                if ((xppr &#x3D; xpp.right) !&#x3D; null &amp;&amp; xppr.red) {                    &#x2F;&#x2F;这里结合图看的会更明白，把叔叔结点设置成黑色，父结点设置为黑色，爷爷结点设置成红色                    xppr.red &#x3D; false;                    xp.red &#x3D; false;                    xpp.red &#x3D; true;                    &#x2F;&#x2F;爷爷结点赋值给x，继续循环                    x &#x3D; xpp;                }                &#x2F;&#x2F;爷爷结点的右结点不存在或者叔叔结点是黑色                else {                    &#x2F;&#x2F;判断x是否是父结点的右节点                    if (x &#x3D;&#x3D; xp.right) {                        &#x2F;&#x2F;x上升至父结点，并左旋                        root &#x3D; rotateLeft(root, x &#x3D; xp);                        xpp &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.parent;                    }                    if (xp !&#x3D; null) {                        &#x2F;&#x2F;x是左孩子，x的父结点设置为黑色，x的爷爷改成红色然后右旋                        xp.red &#x3D; false;                        if (xpp !&#x3D; null) {                            xpp.red &#x3D; true;                            root &#x3D; rotateRight(root, xpp);                        }                    }                }            }            else {  &#x2F;&#x2F;将上面的过程反过来                if (xppl !&#x3D; null &amp;&amp; xppl.red) {                    xppl.red &#x3D; false;                    xp.red &#x3D; false;                    xpp.red &#x3D; true;                    x &#x3D; xpp;                }                else {                    if (x &#x3D;&#x3D; xp.left) {                        root &#x3D; rotateRight(root, x &#x3D; xp);                        xpp &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.parent;                    }                    if (xp !&#x3D; null) {                        xp.red &#x3D; false;                        if (xpp !&#x3D; null) {                            xpp.red &#x3D; true;                            root &#x3D; rotateLeft(root, xpp);                        }                    }                }            }        }    }    &#x2F;*    删除结点后调整规则：    1、如果删除红色结点，不破坏规则    2、如果是黑色，就少了一个黑色        https:&#x2F;&#x2F;www.gwt.fun&#x2F;articles&#x2F;2017&#x2F;08&#x2F;26&#x2F;1546585401831.html#%E5%88%A0%E9%99%A4    *&#x2F;    static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,                                               TreeNode&lt;K,V&gt; x) {        for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) {            &#x2F;&#x2F;删除后结点是null或者是根结点，不调整            if (x &#x3D;&#x3D; null || x &#x3D;&#x3D; root)                return root;            &#x2F;&#x2F;x成为根结点，将x设置为黑色            else if ((xp &#x3D; x.parent) &#x3D;&#x3D; null) {                x.red &#x3D; false;                return x;            }            &#x2F;&#x2F;如果x是红的，设置成黑            else if (x.red) {                x.red &#x3D; false;                return root;            }            &#x2F;&#x2F;x是父亲的左孩子            else if ((xpl &#x3D; xp.left) &#x3D;&#x3D; x) {                &#x2F;&#x2F;x的兄弟是红色的                if ((xpr &#x3D; xp.right) !&#x3D; null &amp;&amp; xpr.red) {                    xpr.red &#x3D; false;                    xp.red &#x3D; true;                    root &#x3D; rotateLeft(root, xp);                    xpr &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.right;                }                &#x2F;&#x2F;没有兄弟，则x到父结点位置                if (xpr &#x3D;&#x3D; null)                    x &#x3D; xp;                else {                    TreeNode&lt;K,V&gt; sl &#x3D; xpr.left, sr &#x3D; xpr.right;                    if ((sr &#x3D;&#x3D; null || !sr.red) &amp;&amp;                        (sl &#x3D;&#x3D; null || !sl.red)) {                        &#x2F;&#x2F;如果x结点的兄弟是黑色的，并且左右结点都是黑色                        xpr.red &#x3D; true;                        x &#x3D; xp;                    }                    else {                        if (sr &#x3D;&#x3D; null || !sr.red) {                            &#x2F;&#x2F;x的兄弟是黑色，右结点是黑色，左结点是红色                            if (sl !&#x3D; null)                                sl.red &#x3D; false;                            &#x2F;&#x2F;将x的兄弟结点变成红色,然后右旋                            &#x2F;&#x2F;下面的不写了，就是那几个过程，看明白就行，代码看不看都可以                            xpr.red &#x3D; true;                            root &#x3D; rotateRight(root, xpr);                            xpr &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ?                                null : xp.right;                        }                        if (xpr !&#x3D; null) {                            xpr.red &#x3D; (xp &#x3D;&#x3D; null) ? false : xp.red;                            if ((sr &#x3D; xpr.right) !&#x3D; null)                                sr.red &#x3D; false;                        }                        if (xp !&#x3D; null) {                            xp.red &#x3D; false;                            root &#x3D; rotateLeft(root, xp);                        }                        x &#x3D; root;                    }                }            }            else { &#x2F;&#x2F; 反过来的                if (xpl !&#x3D; null &amp;&amp; xpl.red) {                    xpl.red &#x3D; false;                    xp.red &#x3D; true;                    root &#x3D; rotateRight(root, xp);                    xpl &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.left;                }                if (xpl &#x3D;&#x3D; null)                    x &#x3D; xp;                else {                    TreeNode&lt;K,V&gt; sl &#x3D; xpl.left, sr &#x3D; xpl.right;                    if ((sl &#x3D;&#x3D; null || !sl.red) &amp;&amp;                        (sr &#x3D;&#x3D; null || !sr.red)) {                        xpl.red &#x3D; true;                        x &#x3D; xp;                    }                    else {                        if (sl &#x3D;&#x3D; null || !sl.red) {                            if (sr !&#x3D; null)                                sr.red &#x3D; false;                            xpl.red &#x3D; true;                            root &#x3D; rotateLeft(root, xpl);                            xpl &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ?                                null : xp.left;                        }                        if (xpl !&#x3D; null) {                            xpl.red &#x3D; (xp &#x3D;&#x3D; null) ? false : xp.red;                            if ((sl &#x3D; xpl.left) !&#x3D; null)                                sl.red &#x3D; false;                        }                        if (xp !&#x3D; null) {                            xp.red &#x3D; false;                            root &#x3D; rotateRight(root, xp);                        }                        x &#x3D; root;                    }                }            }        }    }    &#x2F;**     * 从根结点开始检查红黑树，是否符合红黑树的性质     *&#x2F;    static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) {        TreeNode&lt;K,V&gt; tp &#x3D; t.parent, tl &#x3D; t.left, tr &#x3D; t.right,            tb &#x3D; t.prev, tn &#x3D; (TreeNode&lt;K,V&gt;)t.next;        if (tb !&#x3D; null &amp;&amp; tb.next !&#x3D; t)            return false;        if (tn !&#x3D; null &amp;&amp; tn.prev !&#x3D; t)            return false;        if (tp !&#x3D; null &amp;&amp; t !&#x3D; tp.left &amp;&amp; t !&#x3D; tp.right)            return false;        if (tl !&#x3D; null &amp;&amp; (tl.parent !&#x3D; t || tl.hash &gt; t.hash))            return false;        if (tr !&#x3D; null &amp;&amp; (tr.parent !&#x3D; t || tr.hash &lt; t.hash))            return false;        if (t.red &amp;&amp; tl !&#x3D; null &amp;&amp; tl.red &amp;&amp; tr !&#x3D; null &amp;&amp; tr.red)            return false;        if (tl !&#x3D; null &amp;&amp; !checkInvariants(tl))            return false;        if (tr !&#x3D; null &amp;&amp; !checkInvariants(tr))            return false;        return true;    }}\nput(K,V)终于看完了TreeNode类，现在继续看HashMap。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    &#x2F;&#x2F;如果tab是空或者长度为0，就扩容    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)        n &#x3D; (tab &#x3D; resize()).length;    &#x2F;&#x2F;如果哈希表数组中是空，就创建一个结点放进去    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)        tab[i] &#x3D; newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        &#x2F;&#x2F;hash 相同，并且key相同        if (p.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            e &#x3D; p;        &#x2F;&#x2F;如果是红黑树        else if (p instanceof TreeNode)            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            &#x2F;&#x2F;遍历链表            for (int binCount &#x3D; 0; ; ++binCount) {                &#x2F;&#x2F;如果遍历完链表也没找到，就直接加在最后                if ((e &#x3D; p.next) &#x3D;&#x3D; null) {                    p.next &#x3D; newNode(hash, key, value, null);                    &#x2F;&#x2F;如果链表长度大于等于8就变成红黑树，同理，红黑树小于6就转成链表                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st                        treeifyBin(tab, hash);                    break;                }                &#x2F;&#x2F;在链表中找到                if (e.hash &#x3D;&#x3D; hash &amp;&amp;                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))                    break;                p &#x3D; e;            }        }        &#x2F;&#x2F;更新value值        if (e !&#x3D; null) { &#x2F;&#x2F; existing mapping for key            &#x2F;&#x2F;            V oldValue &#x3D; e.value;            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)                e.value &#x3D; value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    &#x2F;&#x2F;threshold是阈值，超过就要扩容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}\nresize()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788final Node&lt;K,V&gt;[] resize() {        Node&lt;K,V&gt;[] oldTab &#x3D; table;        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length; &#x2F;&#x2F;获取旧哈希表长度        int oldThr &#x3D; threshold; &#x2F;&#x2F;获取旧阈值        int newCap, newThr &#x3D; 0;        if (oldCap &gt; 0) {            &#x2F;&#x2F;超过Integer最大值，就不能加了            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) {                threshold &#x3D; Integer.MAX_VALUE;                return oldTab;            }            &#x2F;&#x2F;扩容2倍            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)                newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold        }        else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold            newCap &#x3D; oldThr;        &#x2F;&#x2F;调用了无参构造函数，使用默认容量16，阈值为0.75*16        else {               &#x2F;&#x2F; zero initial threshold signifies using defaults            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        }        &#x2F;&#x2F;如果新阈值为0，则重新计算，如果超过了Integer最大值，就直接赋值最大值        if (newThr &#x3D;&#x3D; 0) {            float ft &#x3D; (float)newCap * loadFactor;            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        }        threshold &#x3D; newThr;&#x2F;&#x2F;更新阈值        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];        table &#x3D; newTab;        &#x2F;&#x2F;如果旧tab里面有数据        if (oldTab !&#x3D; null) {            &#x2F;&#x2F;遍历每一个哈希表数组            for (int j &#x3D; 0; j &lt; oldCap; ++j) {                Node&lt;K,V&gt; e;                &#x2F;&#x2F;临时将结点赋值给e                if ((e &#x3D; oldTab[j]) !&#x3D; null) {                    oldTab[j] &#x3D; null;                    &#x2F;&#x2F;如果e只有一个结点，就重新计算然后存到新tab里面                    if (e.next &#x3D;&#x3D; null)                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;                    &#x2F;&#x2F;如果结点多，是红黑树，就拆分                    else if (e instanceof TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    else { &#x2F;&#x2F; preserve order                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;                        Node&lt;K,V&gt; next;                        do {                            next &#x3D; e.next;                            &#x2F;*                            e.hash &amp; oldCap,这个也非常的巧妙，刚在红黑树的split中看这个式子还没闷过来弯，在这里看明白了。(table.length - 1) &amp; hash是查找索引，而这里没有减一。                            这样就得出来两个值，0或者oldCap，这样就能拆成两个链表                                                                                    *&#x2F;                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) {                                if (loTail &#x3D;&#x3D; null)                                    loHead &#x3D; e;                                else                                    loTail.next &#x3D; e;                                loTail &#x3D; e;                            }                            else {                                if (hiTail &#x3D;&#x3D; null)                                    hiHead &#x3D; e;                                else                                    hiTail.next &#x3D; e;                                hiTail &#x3D; e;                            }                        } while ((e &#x3D; next) !&#x3D; null);                        if (loTail !&#x3D; null) {                            loTail.next &#x3D; null;                            newTab[j] &#x3D; loHead;                        }                        if (hiTail !&#x3D; null) {                            hiTail.next &#x3D; null;                            newTab[j + oldCap] &#x3D; hiHead;                        }                    }                }            }        }        return newTab;    }\ntreeifyBin()这个方法的作用是将链表转成红黑树\n12345678910111213141516171819202122final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    &#x2F;&#x2F;如果链表达到了转换成红黑树的阈值，但是tab的数量没到变成红黑树的阈值，也不会变化。MIN_TREEIFY_CAPACITY &#x3D; 64    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) {        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;        do {            TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);            if (tl &#x3D;&#x3D; null)                hd &#x3D; p;            else {                p.prev &#x3D; tl;                tl.next &#x3D; p;            }            tl &#x3D; p;        } while ((e &#x3D; e.next) !&#x3D; null);        if ((tab[index] &#x3D; hd) !&#x3D; null)            hd.treeify(tab);    }}\n参考资料1.hashcode()和hash()","url":"/2019/01/26/201901/Java源码分析全面解析HashMap/","link":"","plink":"http://example.com/2019/01/26/201901/Java%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90HashMap/"}]

      function getIndexByWord(word, text, caseSensitive) {
        var wordLen = word.length;

        if (wordLen === 0) {
          return [];
        }

        var startPosition = 0,
          position = [],
          index = [];

        if (!caseSensitive) {
          text = text.toLowerCase();
          word = word.toLowerCase();
        }

        while ( (position = text.indexOf(word, startPosition) ) > -1) {
          index.push({
            position: position,
            word: word
          });

          startPosition = position + wordLen;
        }
        return index;
      }

      function highlightKeyword(text, slice) {
        var result = '';
        var prevEnd = slice.start;
        slice.hits.forEach(function (hit) {
          result += text.substring(prevEnd, hit.position);
          var end = hit.position + hit.length;
          result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
          prevEnd = end;
        });
        result += text.substring(prevEnd, slice.end);
        return result;
      }

      function searchFunc(search_id, content_id) {

        var DB = searchData;
        var input = document.getElementById(search_id);
        var resultContent = document.getElementById(content_id);

        var inputEventFunction = function () {
          var searchText = input.value.trim().toLowerCase();

          if(!searchText){
            return;
          }

          var keywords = searchText.split(/[\s\-]+/);
          if (keywords.length > 1) {
            keywords.push(searchText);
          }

          var resultItems = [];

          if (searchText.length > 0) {

            DB.forEach(function (item) {
              var isMatch = false;
              var hitCount = 0;
              var searchTextCount = 0;
              var title = item.title ? item.title.trim() : '';
              var titleInLowerCase = title.toLowerCase();
              var content = item.content ? item.content.trim().replace(/<[^>]+>/g, "") : '';
              var contentInLowerCase = content.toLowerCase();
              var articleUrl = decodeURIComponent(item.url);

              var indexOfTitle = [];
              var indexOfContent = [];

              keywords.forEach(function (keyword) {
                indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
              });


              if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                isMatch = true;
                hitCount = indexOfTitle.length + indexOfContent.length;
              }

              if (isMatch) {

                [indexOfTitle, indexOfContent].forEach(function (index) {
                  index.sort(function (itemLeft, itemRight) {
                    if (itemRight.position !== itemLeft.position) {
                      return itemRight.position - itemLeft.position;
                    } else {
                      return itemLeft.word.length - itemRight.word.length;
                    }
                  });
                });

                function mergeIntoSlice(text, start, end, index) {
                  var item = index[index.length - 1];
                  var position = item.position;
                  var word = item.word;
                  var hits = [];
                  var searchTextCountInSlice = 0;
                  while (position + word.length <= end && index.length != 0) {
                    if (word === searchText) {
                      searchTextCountInSlice++;
                    }
                    hits.push({ position: position, length: word.length });
                    var wordEnd = position + word.length;

                    index.pop();
                    while (index.length != 0) {
                      item = index[index.length - 1];
                      position = item.position;
                      word = item.word;
                      if (wordEnd > position) {
                        index.pop();
                      } else {
                        break;
                      }
                    }
                  }
                  searchTextCount += searchTextCountInSlice;
                  return {
                    hits: hits,
                    start: start,
                    end: end,
                    searchTextCount: searchTextCountInSlice
                  };
                }

                var slicesOfTitle = [];
                if (indexOfTitle.length != 0) {
                  slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                }

                var slicesOfContent = [];
                while (indexOfContent.length != 0) {
                  var item = indexOfContent[indexOfContent.length - 1];
                  var position = item.position;
                  var word = item.word;

                  var start = position - 20;
                  var end = position + 80;
                  if (start < 0) {
                    start = 0;
                  }
                  if (end < position + word.length) {
                    end = position + word.length;
                  }
                  if (end > content.length) {
                    end = content.length;
                  }
                  slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                }

                slicesOfContent.sort(function (sliceLeft, sliceRight) {
                  if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                    return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                  } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                    return sliceRight.hits.length - sliceLeft.hits.length;
                  } else {
                    return sliceLeft.start - sliceRight.start;
                  }
                });

                slicesOfContent = slicesOfContent.slice(0, 2);

                var resultItem =  "<li class='item'><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + (slicesOfTitle.length? highlightKeyword(title, slicesOfTitle[0]) : title)+ "</a>";

                slicesOfContent.forEach(function (slice) {
                  resultItem += "<a target='_blank' class='search-result-link' href='" + articleUrl + "'>" +
                    "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                    "...</p>" + "</a>";
                });

                resultItem += "</li>";
                resultItems.push({
                  item: resultItem,
                  searchTextCount: searchTextCount,
                  hitCount: hitCount,
                  id: resultItems.length
                });
              }
            })
            Jcount.innerHTML = resultItems.length;
          };

          if (keywords.length === 1 && keywords[0] === "") {
            resultContent.innerHTML = '<div id="no-result"></div>'
          } else if (resultItems.length === 0) {
            resultContent.innerHTML = '<div id="no-result"></div>'
          } else {
            resultItems.sort(function (resultLeft, resultRight) {
              if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                return resultRight.searchTextCount - resultLeft.searchTextCount;
              } else if (resultLeft.hitCount !== resultRight.hitCount) {
                return resultRight.hitCount - resultLeft.hitCount;
              } else {
                return resultRight.id - resultLeft.id;
              }
            });
            var searchResultList = '<ul class=\"search-result-list\">';
            resultItems.forEach(function (result) {
              searchResultList += result.item;
            })
            searchResultList += "</ul>";
            resultContent.innerHTML = searchResultList;
          }
        }

        input.addEventListener('input', inputEventFunction);
        input.addEventListener('keydown', (e)=>{
          if (e.keyCode=='13') {
            inputEventFunction()
          }
        });
      }
      searchFunc('Jinput', 'JresList')
    </script>
  </div>
</article>
        </div>
        
        
      </div>
      <footer id="footer" class="inner">
        © 2021 - Gavin -
        <span id="busuanzi_container_site_pv">PV <span id="busuanzi_value_site_pv"></span></span>
        <p>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/thinkerchan/hexo-theme-greyshade">GreyShade</a></p>
      </footer>
    </div>
  </div>
  
  <script async defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
</body>
</html>